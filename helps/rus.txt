
Оглавление

Предисловие
I. Введение

    1. Выделения Neo4j
    2. Понятия Базы данных графика
    3. База данных Графика Neo4j

II. Учебные руководства

    4. Начинание с Кодом
    5. Примеры Моделирования данных
    6. Языки

III. Язык Запроса кода

    7. Введение
    8. Синтаксис
    9. Общие оговорки
    10. Чтение Пунктов
    11. Запись Пунктов
    12. Функции
    13. Схема
    14. От SQL до Кода

IV. Ссылка

    15. Возможности
    16. Управление транзакцией
    17. Импорт данных
    18. Алгоритмы графика
    19. API REST
    20. Осуждения

V. Операции

    21. Установка & Развертывание
    22. Конфигурация & Производительность
    23. Высокая доступность
    24. Резервное копирование
    25. Безопасность
    26. Контроль

VI. Инструменты

    27. Веб-Интерфейс
    28. Neo4j Shell

VII. Сообщество

    29. Общественная поддержка
    30. Содействие Neo4j

VIII. Усовершенствованное Использование

    31. Расширение Сервера Neo4j
    32. Используя Neo4j, встроенный в приложения Java
    33. Платформа Обхода
    34. Индексация наследства
    35. Пакетная Вставка

A. Страницы справочника

    neo4j - управление Сервером Neo4j
    neo4j-установщик - установка Сервера Neo4j и перемещение
    neo4j-оболочка - инструмент командной строки для исследования и управления графика
        база данных
    neo4j-резервное-копирование - Резервный Инструмент Neo4j
    neo4j-арбитр - Арбитр Neo4j для Кластеров высокой доступности


-------------------------------------------------------------------------------

Предисловие

-------------------------------------------------------------------------------

Это - справочник для версии 2.0.0 Neo4j, созданной Neo4j
Команда.

Основные части справочника:

  * Первая часть, "Введение"   -  introducing понятия базы данных графика и Neo4j.
  * Вторая часть, "Учебные руководства"   -  learn, как использовать Neo4j.
  * Часть III, “Язык Запроса Кода”   -  details на Коде запрашивает язык.
  * IV Части, "Ссылка"   -  detailed информация о Neo4j.
  * Часть V, "Операции"   -  how, чтобы установить и поддержать Neo4j.
  * Часть VI, "Инструменты"   -  guides на инструментах.
  * Часть VII, "Сообщество"   -  getting помогает от, способствуя.
  * Часть VIII, “Усовершенствованное Использование”   -  using Neo4j более усовершенствованными способами.
  * Приложение A, Страницы справочника  -  документация командной строки.

Материал является практичным, техническим, и сосредоточился на том, чтобы отвечать определенный
вопросы. Это адресуется, как вещи работают, что сделать и что избежать к
успешно выполненный Neo4j в продуктивной среде.

Цель состоит в том, чтобы быть, просматривают и дружественное эмпирическое правило.

Каждый раздел должен стоять самостоятельно, таким образом, Вы можете скачкообразно переместить право на что
проценты Вы. Когда возможный, разделы дистиллируют "эмпирические правила" который Вы
может иметь в виду всякий раз, когда Вы блуждаете из дома без этого справочника в
Ваш задний карман.

Включенные примеры кода выполняются, когда Neo4j создан и протестирован. Кроме того,
остальные запрос API и примеры реакции получены от реального взаимодействия
с сервером Neo4j. Таким образом, примеры всегда находятся в синхронизации с как Neo4j
фактически работает.

Есть другие ресурсы документации помимо справочника также:

  * Код Neo4j Refcard, см. http://docs.neo4j.org/ <http://документы neo4j.org/>
    для доступных версий.
  * Neo4j GraphGist, онлайновый инструмент для того, чтобы создать интерактивные веб-страницы с
    исполнимые операторы Cypher: http://gist.neo4j.org/ <http://суть neo4j.org
    />.
  * основной сайт Neo4j в http://www.neo4j.org/ <http://www.neo4j.org/> является a
    хорошая начальная точка, чтобы узнать о Neo4j.

Кто должен считать это?

Темы должны относиться к архитекторам, администраторам, разработчикам и
персонал операций.

Первая часть. Введение

Эта часть дает вид с высоты птичьего полета того, что база данных графика, и затем
схемы некоторые специфические особенности Neo4j.

Оглавление

1. Выделения Neo4j
2. Понятия Базы данных графика

    2.1. Какова База данных Графика?
    2.2. Сравнение Моделей Базы данных

3. База данных Графика Neo4j

    3.1. Вершины
    3.2. Отношения
    3.3. Свойства
    3.4. Метки
    3.5. Пути
    3.6. Обход
    3.7. Схема

Выделения главы 1. Neo4j

Как устойчивая, масштабируемая и эффективная база данных, Neo4j является соответствующим для полного
развертывание предприятия или подмножество полного сервера могут использоваться в легком весе
проекты.

Это обладает:

  * истинные транзакции ACID,
  * высокая доступность,
  * масштабируется к миллиардам вершин и отношений,
  * высокая скорость, запрашивающая через обходы,
  * декларативный язык запроса графика.

Присущее поведение ACID - основа надежности данных. Neo4j осуществляет это
все операции, которые модифицируют данные, происходят в пределах транзакции, гарантируя
непротиворечивые данные. Эта устойчивость расширяется от встроенных графиков единственного экземпляра
к высоконадежным установкам мультисервера. Для получения дополнительной информации, см. Главу 16,
Управление транзакцией.

Достоверное хранение графика может легко быть прибавлено к любому приложению. График может
масштаб в размере и сложности как приложение развивается, с небольшим соударением на
производительность. Ли запуск новой разработки, или увеличиваясь существующий
функциональность, Neo4j только ограничен материальными аппаратными средствами.

Единственный экземпляр сервера может обработать график миллиардов вершин и
отношения. Когда пропускная способность данных недостаточна, база данных графика может быть
распределенный среди разнообразных серверов в высоконадежной конфигурации. См.
Глава 23, Высокая доступность, чтобы учиться больше.

Хранение базы данных графика сияет, храня богато соединенные данные. Запросы
выполняется через обходы, которые могут выполнить миллионы шагов обхода
в секунду. Шаг обхода напоминает соединение в RDBMS.

Глава 2. Понятия Базы данных графика

Эта глава содержит введение в модель данных графика и также сравнивается
это к другим моделям данных, используемым, сохраняя данные.

2.1. Какова База данных Графика?

2.1.1. График содержит Вершины и Отношения
2.1.2. Отношения организуют График
2.1.3. Метки группируют Вершины
2.1.4. Запросите График с Обходом
2.1.5. Индексирует Вершины поиска или Отношения
2.1.6. Neo4j - База данных Графика

База данных графика хранит данные в графике, самой универсальной из структур данных,
способный к изящному представлению любого вида данных очень доступным способом.
Пустите нам следовать вдоль некоторых графиков, используя их, чтобы выразить понятия графика. Мы будем
"считайте" график следующими стрелками вокруг схемы, чтобы сформировать предложения.

2.1.1. График содержит Вершины и Отношения

    “График - записывает данные в → Вершинах - у которых есть → Свойства”

Самый простой график - единственная Вершина, запись, которая назвала значения
называемый Свойствами. Вершина могла запуститься с единственного Свойства и вырасти
к нескольким миллионам Свойств, хотя это может получить немного неуклюжим. В некоторых
точка имеет смысл распределять данные в разнообразные вершины, организованные с
явные Отношения.

graphdb-GVE.svg

2.1.2. Отношения организуют График

    “Вершины - организованы → Отношениями - у которых также есть → Свойства”

Отношения организуют Вершины в произвольные строения, позволяя График
напомните Список, Дерево, Карту, или составной Объект - любой из которых может быть
объединенный во все же более комплексные, богато соединенные строения.

2.1.3. Метки группируют Вершины

    “Вершины - сгруппированы Метками → - в Наборы →”

Метки - средство группировки вершин в графике. Они могут привыкнуть к
ограничьте запросы подмножествами графика, так же как включение дополнительной модели
ограничения и индексирующие правила.

2.1.4. Запросите График с Обходом

    “Обход - перемещается по  График; это - идентифицирует → Пути - которые упорядочивают →
    Вершины”

Обход - то, как Вы запрашиваете График, перемещающийся от запускающихся Вершин до связанного
Вершины согласно алгоритму, обнаруживая ответы на вопросы как, "что музыка
сделайте моих друзей как этот, мне еще не принадлежит,” или, "если этот источник питания теряет работоспособность,
на какие веб-сервисы влияют?”

graphdb-traversal.svg

2.1.5. Индексирует Вершины поиска или Отношения

    “Индексирование - отображается от → Свойств - или к → Вершинам или к Отношениям”

Часто, Вы хотите обнаружить определенную Вершину или Отношение согласно Свойству
это имеет. Вместо того, чтобы пересекать весь график, используйте Индексирование, чтобы выполнить a
поиск, для вопросов как “новое месторождение Учетная запись за ведущее устройство графиков имени пользователя.”

graphdb-indexes.svg

2.1.6. Neo4j - База данных Графика

    “База данных Графика - управляет → Графиком, и - также управляет, связанный → Индексирует”

Neo4j - коммерчески поддерживаемая база данных графика с открытым исходным кодом. Это было разработано
и созданный с нуля, чтобы быть достоверной базой данных, оптимизированной для графика
строения вместо таблиц. Работая с Neo4j, Ваше приложение добирается весь
выразительность графика, со всей надежностью Вы ожидаете из a
база данных.

graphdb-overview.svg

2.2. Сравнение Моделей Базы данных

2.2.1. База данных Графика преобразовывает RDBMS
2.2.2. База данных Графика разрабатывает Хранилище Значения ключа
2.2.3. База данных Графика связывает семейство столбца
2.2.4. База данных Графика перемещается по Хранилищу Документа

База данных Графика хранит данные, структурированные в Вершинах и Отношениях a
график. Как это сравнивается с другими моделями персистентности? Поскольку график - a
универсальное строение, пустите нам сравниваться, как несколько моделей смотрели бы в графике.

2.2.1. База данных Графика преобразовывает RDBMS

Опрокиньте штабели записей в реляционной базе данных, сохраняя весь
отношения, и Вы будете видеть график. Где RDBMS оптимизирован для
агрегированные данные, Neo4j оптимизирован для чрезвычайно соединенных данных.

Рисунок 2.1. RDBMS

graphdb-compare-rdbms.svg


Рисунок 2.2. База данных графика как RDBMS

graphdb-compare-rdbms-g.svg


2.2.2. База данных Графика разрабатывает Хранилище Значения ключа

Модель Значения ключа является большой для поисков простых значений или списков. Когда
значения самостоятельно соединены, у Вас есть график. Neo4j пускает Вам
разработайте простые структуры данных в более комплексные, соединенные данные.

Рисунок 2.3. Хранилище значения ключа

graphdb-compare-kvstore.svg


K* представляет ключ, V* значение. Заметьте, что некоторые ключи указывают на другие ключи как
хорошо как простые значения.

Рисунок 2.4. База данных графика как Хранилище Значения ключа

graphdb-compare-kvstore-g.svg


2.2.3. База данных Графика связывает семейство столбца

Семейство столбца (BigTable-стиль) базы данных является развитием значения ключа, используя
"семейства", чтобы позволить группироваться строк. Сохраненный в графике, семейства могли
станьте иерархическими, и отношения среди данных становится явным.

2.2.4. База данных Графика перемещается по Хранилищу Документа

Контейнерная иерархия базы данных документа размещает хороший, без схем
данные, которые могут легко быть представлены как дерево. Который является, конечно, графиком.
Сошлитесь на другие документы (или элементы документа) в пределах того дерева, и у Вас есть a
более выразительное представление тех же самых данных. Когда в Neo4j, тех
отношения легко судоходны.

Рисунок 2.5. Хранилище документа

graphdb-compare-docdb.svg


D=Document, S=Subdocument, V=Value, D2/S2 = ссылка на поддокумент в (другом)
документ.

Рисунок 2.6. База данных графика как Хранилище Документа

graphdb-compare-docdb-g.svg


Глава 3. База данных Графика Neo4j

Эта глава проникает в большее количество деталей на модели данных и поведении Neo4j.

3.1. Вершины

Основные единицы, которые формируют график, являются вершинами и отношениями. В Neo4j,
и вершины и отношения могут содержать свойства.

Вершины часто используются, чтобы представить объекты, но в зависимости от домена
отношения могут использоваться с этой целью также.

Кроме свойств и отношений, вершины могут также быть маркированы нулем или
больше меток.

graphdb-nodes-overview.svg

Пустите нам начинать с действительно простым графиком, содержа только единственную вершину с
одно свойство:

graphdb-nodes.svg

3.2. Отношения

Отношения между вершинами - ключевая роль базы данных графика. Они учитывают
обнаружение связанных данных. Точно так же как вершины у отношений могут быть свойства.

graphdb-rels-overview.svg

У отношения соединяет две вершины, и, как гарантируют, будет допустимый запуск и
конечные узлы.

graphdb-rels.svg

Поскольку отношения всегда направляются, они могут быть просмотрены как выход или
поступление относительно вершины, которая полезна, пересекая график:

graphdb-rels-dir.svg

Отношения одинаково хорошо пересечены в любом направлении. Это означает это
нет никакой потребности прибавить двойные отношения в противоположном направлении (с
расцените к обходу или производительности).

В то время как у отношений всегда есть направление, Вы можете игнорировать направление где
это не полезно в Вашем приложении.

Заметьте, что у вершины могут быть отношения к себе также:

graphdb-rels-loop.svg

Чтобы далее улучшить обход графика, у всех отношений есть тип отношения.
Заметьте, что тип слова мог бы вводить в заблуждение здесь, Вы могли скорее думать о нем
как метка. Следующий пример показывает простую социальную сеть с два
типы отношения.

graphdb-rels-twitter.svg

Таблица 3.1. Используя направление отношения и тип

Что, Как
доберитесь, за кем следует человек, выход следует за отношениями, глубина один

доберитесь следящие механизмы человека, поступающего, следует за отношениями, глубина один

доберитесь, кто человек блокирует исходящие блочные отношения, глубина один

доберитесь, кто человек блокирован, поступая блочные отношения, глубина один


3.3. Свойства

У и вершин и отношений могут быть свойства.

Свойства - пары значения ключа, где ключ - строка. Значения свойств могут
будьте или примитивом или массивом одного типа примитива. Например Строка,
интервал и интервал [] значения допустимы для свойств.

Замечание

НУЛЬ не допустимое значение свойства. НУЛИ могут вместо этого быть смоделированы отсутствием
из ключа.

graphdb-properties.svg

Таблица 3.2. Типы значения свойства

Введите диапазон Значения Описания
булева истина/ложь

байт 8-разрядное целое число-128 к 127, включительно

короткое 16-разрядное целое число-32768 к 32767, включительно

международное 32-разрядное целое число-2147483648 к 2147483647,
                                             включительно

длинное 64-разрядное целое число-9223372036854775808 к
                                             9223372036854775807, включительно

пустите в ход 32-разрядный IEEE 754, с плавающей точкой
        номер

удвойте 64-разрядный IEEE 754, с плавающей точкой
        номер

обожгите 16-разрядных целых без знака u0000 к uffff (от 0 до 65535)
        представление символов Unicode

Строковая последовательность символов Unicode


Для получения дальнейшей информации на значениях плавающих/двойных, см. Спецификацию языка Java
<http://docs.oracle.com/javase/specs/jls/se5.0/html/typesValues.html#4.2.3>.

3.4. Метки

3.4.1. Имена метки

Метка - именованная конструкция графика, которая привыкла к групповым вершинам в наборы; все
вершины, маркированные той же самой меткой, принадлежат тому же самому набору. Многие база данных
запросы могут работать с этими наборами вместо целого графика, делая запросы
легче записать и более эффективный. Вершина может быть маркирована любым номером
метки, включая ни один, делая не маркируют дополнительное прибавление к графику.

graphdb-labels.svg

Метки используются, определяя contraints, и добавление индексирует для свойств.

Примером была бы метка под названием Пользователь, что Вы маркируете все свои вершины
представление пользователей с. С этим на месте, Вы можете попросить, чтобы Neo4j выполнил
операции только на Ваших пользовательских вершинах, таких как обнаружение всех пользователей с данным
имя.

Однако, Вы можете использовать метки для намного больше. Например, так как метки могут быть
прибавленный и удаленный во время времени выполнения, они могут использоваться, чтобы отметить временные состояния для
Ваши вершины. Вы могли бы создать Офлайновую метку для телефонов, которые являются офлайновыми, a
Счастливая метка для счастливых домашних животных, и так далее.

3.4.1. Имена метки

Любой непустеет, строка unicode может использоваться в качестве имени метки. В Коде Вы можете
потребность использовать обратную галочку (`) синтаксис, чтобы избежать столкновений с идентификатором Кода
правила. Условно, метки записаны с нотацией CamelCase, с
первая буква в верхнем регистре. Например, Пользователь или CarOwner.

У меток есть пространство идентификатора интервала, означая максимальное число меток
база данных может делиться без остатка, примерно 2 миллиарда.

3.5. Пути

Путь - одна или более вершин с соединяющимися отношениями, обычно получаемыми
как запрос или результат обхода.

graphdb-path.svg

Самый короткий путь имеет нуль длины и похож на это:

graphdb-path-example1.svg

Путь длины один:

graphdb-path-example2.svg

Другой путь длины один:

graphdb-path-example-loop.svg

3.6. Обход

Полигонометрия график означает посещать свои вершины, после отношений соответственно
к небольшому количеству правил. В большинстве случаев только подграф посещают, как Вы уже знаете
где в графике интересные вершины и отношения найдены.

Код обеспечивает декларативный способ запросить график, основанный обходами и
другие методы. См. Часть III, “Язык Запроса Кода” для получения дополнительной информации.

Neo4j идет с базируемым API обхода обратного вызова, который пускает Вам определять
правила обхода. На базовом уровне есть выбор между полигонометрией ширины -
или в глубину.

Для всестороннего введения в платформу обхода, см. Главу 33,
Платформа обхода. Для Java примеры кода видят Раздел 32.7, "Обход".

3.7. Схема

3.7.1. Индексирует
3.7.2. Ограничения

Neo4j - дополнительная схемой база данных графика. Вы можете использовать Neo4j ни с кем
схема. Дополнительно Вы можете представить это, чтобы получить производительность или
моделирование преимуществ. Это позволяет способу работать, где схема не добирается
в Вашем пути, пока Вы не на этапе, где Вы хотите жать преимущества
наличие того.

3.7.1. Индексирует

Замечание

Эта функция была представлена в Neo4j 2.0, и не является тем же самым как наследством
индексирует (см. Главу 34, Индексацию Наследства).

Производительность получена созданием, индексирует, которые улучшают скорость взгляда
вершины в базе данных. Как только Вы определили который свойства индексировать,
Neo4j удостоверится Ваш, индексирует, усовершенствованы, поскольку Ваш график развивается.
Любая работа, которая ищет вершины недавно индексированными свойствами, будет видеть a
существенное усиление производительности.

Индексирует в Neo4j, в конечном счете доступны. Это означает что когда Вы сначала
создайте индексирование, работа сразу возвращается. Индексирование заполняет в
фон и так не сразу доступен для запросов. Когда индексирование
был полностью заполнен это в конечном счете прибудет онлайн. Это означает, что это
теперь готовый использоваться в запросах.

Если что-то должно пойти не так, как надо с индексированием, это может закончиться отказавшем состоянии.
Когда это будет отказавшим, это не будет использоваться, чтобы ускорить запросы. Восстановить это, Вы
может отбросить и воссоздать индексирование. Взгляд на журналы для подсказок об отказе.

Вы можете отследить состояние Вашего индексировать, прося индексировать состояние через
API Вы используете. Заметьте, однако, что это еще не возможно через
Код.

То, как использовать, индексирует в различных API:

  * Код: Раздел 13.1, "Индексирует"
  * API REST: Раздел 19.13, "Индексируя"
  * Перечисление Индексирует через Shell: Раздел 28.6.11, “Перечисление Индексирует и
    Ограничения”
  * API ядра Java: Раздел 32.4, “Пользовательская база данных с индексирует”

3.7.2. Ограничения

Замечание

Эта функция была представлена в Neo4j 2.0.

Neo4j может помочь Вам содержать свои данные в чистоте. Это делает так ограничения использования, что
позвольте Вам определять правила для того, на что должны быть похожими Ваши данные. Любые изменения
это нарушает эти правила, будет отрицаться.

В этой версии уникальные ограничения - единственный доступный ограничительный тип.

Как использовать ограничения в различных API:

  * Код: Раздел 13.2, "Ограничения"
  * API REST: Раздел 19.14, "Ограничения"
  * Перечисление Ограничений через Shell: Раздел 28.6.11, “Перечисление Индексирует и
    Ограничения”

Вторая часть. Учебные руководства

Учебная часть описывает как использование Neo4j. Это берет Вас от Привет Мира до
усовершенствованное использование графиков.

Оглавление

4. Начинание с Кодом

    4.1. Создайте вершины и отношения
    4.2. База данных фильма
    4.3. Социальная База данных Фильма
    4.4. Обнаружение Путей
    4.5. Метки, Ограничения и Индексируют

5. Примеры Моделирования данных

    5.1. Связанные списки
    5.2. Сериалы
    5.3. Строения ACL в графиках
    5.4. Гиперкрая
    5.5. Основной друг, обнаруживающий основанный на социальном окружении
    5.6. Cо-favorited места
    5.7. Обнаружьте людей основанными на подобном избранном
    5.8. Обнаружьте людей основанными на общих друзьях и группах
    5.9. Обнаружьте друзей основанными на подобном тегировании
    5.10. Мультиреляционные (социальные) графики
    5.11. Реализация новостных каналов в графике
    5.12. Усиление результатов рекомендации
    5.13. Вычисление кластеризирующегося коэффициента сети
    5.14. Симпатичные графики
    5.15. Многоуровневое строение индексации (дерево пути)
    5.16. Комплексные вычисления подобия
    5.17. Потоковая модель действия Graphity
    5.18. Пользовательские роли в графиках

6. Языки

    6.1. Как использовать остальных API от Java

Глава 4. Начинание с Кодом

Эта глава будет вести Вас через Ваши первые шаги с Кодом.

В онлайновом выпуске этого справочника все запросы в этом разделе могут быть
выполняемый в интерактивном режиме, не устанавливая Neo4j на Вашем компьютере.

Иначе, сначала получите сервер Neo4j, работающий, чтобы испытать вещи локально.
Инструкции найдены в Разделе 21.2, “Установка Сервера”. С сервером
выполнение, Вы можете хотеть выпускать запросы Кода от любого веб-интерфейс
или оболочка Neo4j. См. Главу 27, Веб-Интерфейс или Главу 28, Neo4j Shell.

4.1. Создайте вершины и отношения

Создайте вершину для агента Том Хэнкс:

СОЗДАЙТЕ (n:Actor {имя: "Том Хэнкс"});

Пустите нам обнаруживать вершину, которую мы создали:

СООТВЕТСТВИЕ (actor:Actor {имя: "Том Хэнкс"})
ВОЗВРАТИТЕ агента;

Теперь пустите нам создавать фильм и соединять это с вершиной Тома Хэнкса с ACTED_IN
отношение:

СООТВЕТСТВИЕ (actor:Actor)
ГДЕ actor.name = "Том Хэнкс"
СОЗДАЙТЕ (movie:Movie {заголовок:'Sleepless В Сиэтле'})
СОЗДАЙТЕ (агент) - [:ACTED_IN]-> (фильм);

Используя, ГДЕ пункт в запросе выше, чтобы получить вершину Тома Хэнкса делает то же самое
вещь как модель в пункте СООТВЕТСТВИЯ предыдущего запроса.

Это - то, как наш график смотрит теперь:

cypherdoc-created-first-movie-e8e6e816.svg

Мы можем сделать больше работы в единственном пункте. СОЗДАЙТЕ УНИКАЛЬНЫЙ, удостоверится мы
не создавайте двойные модели. Используя это: [r:ACTED_IN] пускает нам возвращаться
отношение.

СООТВЕТСТВИЕ (actor:Actor {имя: "Том Хэнкс"})
СОЗДАЙТЕ УНИКАЛЬНЫЙ (агент) - [r:ACTED_IN]-> (movie:Movie {заголовок: "Форрест Гамп"})
ВОЗВРАТИТЕ r;

Установите свойство на вершине:

СООТВЕТСТВИЕ (actor:Actor {имя: "Том Хэнкс"})
Агент НАБОРА. DoB = 1944
ВОЗВРАТИТЕ actor.name, агента. DoB;

Агент меток и Фильм помогают нам организовать график. Пустите нам перечислять весь Фильм
вершины:

СООТВЕТСТВИЕ (movie:Movie)
ВОЗВРАТИТЕ AS фильма `Все Фильмы`;

+-------------------------------------+
Фильмы |All |
|-------------------------------------|
|2 строки |
|-------------------------------------|
|Node [1] {заголовок: "Бессонный в Сиэтле"} |
|-------------------------------------|
|Node [2] {заголовок: "Форрест Гамп"} |
+-------------------------------------+

4.2. База данных фильма

Наши составы графика в качестве примера фильмов с заголовком и год и агенты с a
имя. У агентов есть отношения ACTS_IN к фильмам, который представляет роль
они играли. У этого отношения также есть ролевой атрибут.

Мы пойдем с тремя фильмами и тремя агентами:

СОЗДАЙТЕ (matrix1:Movie {заголовок: 'Матрица', год: '1999-03-31'})
СОЗДАЙТЕ (matrix2:Movie {заголовок: 'Матрица: Перезагрузка', год: '2003-05-07'})
СОЗДАЙТЕ (matrix3:Movie {заголовок: 'Матричные Обороты, год: '2003-10-27'})
СОЗДАЙТЕ (keanu:Actor {называют:' Киану Ривза'}),
СОЗДАЙТЕ (laurence:Actor {называют:' Лоуренса Фишберна'}),
СОЗДАЙТЕ (carrieanne:Actor {называют:'карри-Энн Мосс}),
СОЗДАЙТЕ (keanu) - [:ACTS_IN {роль: 'Нео'}]-> (matrix1)
СОЗДАЙТЕ (keanu) - [:ACTS_IN {роль: 'Нео'}]-> (matrix2)
СОЗДАЙТЕ (keanu) - [:ACTS_IN {роль: 'Нео'}]-> (matrix3)
СОЗДАЙТЕ (laurence) - [:ACTS_IN {роль: 'Морфей'}]-> (matrix1)
СОЗДАЙТЕ (laurence) - [:ACTS_IN {роль: 'Морфей'}]-> (matrix2)
СОЗДАЙТЕ (laurence) - [:ACTS_IN {роль: 'Морфей'}]-> (matrix3)
СОЗДАЙТЕ (carrieanne) - [:ACTS_IN {роль: 'Троица'}]-> (matrix1)
СОЗДАЙТЕ (carrieanne) - [:ACTS_IN {роль: 'Троица'}]-> (matrix2)
СОЗДАЙТЕ (carrieanne) - [:ACTS_IN {роль: 'Троица'}]-> (matrix3)

Это дает нам следующий график, чтобы играть с:

cypherdoc - 3b7c1848.svg

Пустите нам проверять, сколько вершин мы имеем теперь:

СООТВЕТСТВИЕ (n)
ВОЗВРАТИТЕ "Привет График с "+ количество (*) +" Вершины!" Приветствие AS;

Возвратите единственную вершину, по имени:

СООТВЕТСТВИЕ (movie:Movie {заголовок: 'Матрица'})
ВОЗВРАТИТЕ фильм;

Возвратите заголовок и дату матричной вершины:

СООТВЕТСТВИЕ (movie:Movie {заголовок: 'Матрица'})
ВОЗВРАТИТЕ movie.title, movie.year;

Который следует:

+-------------------------+
|movie.title |movie.year |
|-------------------------|
|1 строка |
|-------------------------|
| "Матрица" | "1999-03-31" |
+-------------------------+

Покажите всех агентов:

СООТВЕТСТВИЕ (actor:Actor)
ВОЗВРАТИТЕ агента;

Возвратите только имя, и упорядочьте их по имени:

СООТВЕТСТВИЕ (actor:Actor)
ВОЗВРАТИТЕ actor.name
ПОРЯДОК actor.name;

Подсчитайте агентов:

СООТВЕТСТВИЕ (actor:Actor)
ВОЗВРАТИТЕ количество (*);

Получите только агентов, имена которых заканчиваются “s”:

СООТВЕТСТВИЕ (actor:Actor)
ГДЕ actor.name = ~ ".*s$"
ВОЗВРАТИТЕ actor.name;

Вот некоторые исследовательские запросы для неизвестных наборов данных. Не делайте этого на переменном
производственные базы данных!

Вершины графа:

СООТВЕТСТВИЕ (n)
ВОЗВРАТИТЕ количество (*);

Типы отношения графа:

СООТВЕТСТВИЕ (n) - [r]-> ()
ВОЗВРАТИТЕ тип (r), количество (*);

+-------------------+
|type (r) |count (*) |
|-------------------|
|1 строка |
|-------------------|
| "ACTS_IN" |9 |
+-------------------+

Перечислите все вершины и их отношения:

СООТВЕТСТВИЕ (n) - [r]-> (m)
ВОЗВРАТИТЕ n AS из, r AS `->`, м. AS к;

+-----------------------------------------------------------------------------+
|from |-> |to |
|-----------------------------------------------------------------------------|
|9 строк |
|-----------------------------------------------------------------------------|
|Node [3] {имя: "Киану |:ACTS_IN [0] |Node [0] {заголовок: "|
|Reeves"} | {роль: "Нео"} |Matrix", год: "1999-03-31"} |
|---------------------+------------------+------------------------------------|
|Node [3] {имя: "Киану |:ACTS_IN [1] |Node [1] {заголовок: "Матрица |
|Reeves"} | {роль: "Нео"} |Reloaded", год: "2003-05-07"} |
|---------------------+------------------+------------------------------------|
|Node [3] {имя: "Киану |:ACTS_IN [2] |Node [2] {заголовок: "Матрица |
|Reeves"} | {роль: "Нео"} |Revolutions", год: "2003-10-27"} |
|---------------------+------------------+------------------------------------|
|Node [4] |:ACTS_IN [3] |Node [0] {заголовок: "|
| {имя: "Лоуренс | {роль: "Морфей"} |Matrix", год: "1999-03-31"} |
|Fishburne"} | | |
|---------------------+------------------+------------------------------------|
|Node [4] |:ACTS_IN [4] |Node [1] {заголовок: "Матрица |
| {имя: "Лоуренс | {роль: "Морфей"} |Reloaded", год: "2003-05-07"} |
|Fishburne"} | | |
|---------------------+------------------+------------------------------------|
|Node [4] |:ACTS_IN [5] |Node [2] {заголовок: "Матрица |
| {имя: "Лоуренс | {роль: "Морфей"} |Revolutions", год: "2003-10-27"} |
|Fishburne"} | | |
|---------------------+------------------+------------------------------------|
|Node [5] |:ACTS_IN [6] |Node [0] {заголовок: "|
| {имя: "Кэрри-Энн | {роль: "Троица"} |Matrix", год: "1999-03-31"} |
|Moss"} | | |
|---------------------+------------------+------------------------------------|
|Node [5] |:ACTS_IN [7] |Node [1] {заголовок: "Матрица |
| {имя: "Кэрри-Энн | {роль: "Троица"} |Reloaded", год: "2003-05-07"} |
|Moss"} | | |
|---------------------+------------------+------------------------------------|
|Node [5] |:ACTS_IN [8] |Node [2] {заголовок: "Матрица |
| {имя: "Кэрри-Энн | {роль: "Троица"} |Revolutions", год: "2003-10-27"} |
|Moss"} | | |
+-----------------------------------------------------------------------------+

4.3. Социальная База данных Фильма

Наши составы графика в качестве примера фильмов с заголовком и год и агенты с a
имя. У агентов есть отношения ACTS_IN к фильмам, который представляет роль
они играли. У этого отношения также есть ролевой атрибут.

До сих пор, мы запрашивали данные фильма; теперь пустите нам обновлять график также.

СОЗДАЙТЕ (matrix1:Movie {заголовок: 'Матрица', год: '1999-03-31'})
СОЗДАЙТЕ (matrix2:Movie {заголовок: 'Матрица: Перезагрузка', год: '2003-05-07'})
СОЗДАЙТЕ (matrix3:Movie {заголовок: 'Матричные Обороты, год: '2003-10-27'})
СОЗДАЙТЕ (keanu:Actor {называют:' Киану Ривза'}),
СОЗДАЙТЕ (laurence:Actor {называют:' Лоуренса Фишберна'}),
СОЗДАЙТЕ (carrieanne:Actor {называют:'карри-Энн Мосс}),
СОЗДАЙТЕ (keanu) - [:ACTS_IN {роль: 'Нео'}]-> (matrix1)
СОЗДАЙТЕ (keanu) - [:ACTS_IN {роль: 'Нео'}]-> (matrix2)
СОЗДАЙТЕ (keanu) - [:ACTS_IN {роль: 'Нео'}]-> (matrix3)
СОЗДАЙТЕ (laurence) - [:ACTS_IN {роль: 'Морфей'}]-> (matrix1)
СОЗДАЙТЕ (laurence) - [:ACTS_IN {роль: 'Морфей'}]-> (matrix2)
СОЗДАЙТЕ (laurence) - [:ACTS_IN {роль: 'Морфей'}]-> (matrix3)
СОЗДАЙТЕ (carrieanne) - [:ACTS_IN {роль: 'Троица'}]-> (matrix1)
СОЗДАЙТЕ (carrieanne) - [:ACTS_IN {роль: 'Троица'}]-> (matrix2)
СОЗДАЙТЕ (carrieanne) - [:ACTS_IN {роль: 'Троица'}]-> (matrix3)

Мы прибавим нас, друзей и оценки фильма.

Вот то, как прибавить вершину для вас непосредственно и возвратить это, скажем, Ваше имя
"Я":

СОЗДАЙТЕ (me:User {имя: "Я"})
ВОЗВРАТИТЕ меня;

+------------------+
|me |
|------------------|
|1 строка |
|------------------|
|Nodes создал: 1 |
|------------------|
|Properties устанавливают: 1 |
|------------------|
|Labels добавлялся: 1 |
|------------------|
|Node [6] {имя: "Я"} |
+------------------+

Пустите нам проверять, ли вершина там:

СООТВЕТСТВИЕ (me:User {имя: "Я"})
ВОЗВРАТИТЕ me.name;

Прибавьте оценку фильма:

СООТВЕТСТВИЕ (me:User {имя: "Я"}), (movie:Movie {заголовок: "Матрица"})
СОЗДАЙТЕ (меня) - [:RATED {звезды: 5, комментарий: "Я люблю тот фильм!"}]-> (фильм);

Какие фильмы я оценивал?

СООТВЕТСТВИЕ (me:User {имя: "Я"}), (я) - [rating:RATED]-> (фильм)
ВОЗВРАТИТЕ movie.title, rating.stars, rating.comment;

+----------------------------------------------+
|movie.title |rating.stars|rating.comment |
|----------------------------------------------|
|1 строка |
|----------------------------------------------|
| "Матрица" |5 | "Я люблю тот фильм!" |
+----------------------------------------------+

Мы нуждаемся в друге!

СОЗДАЙТЕ (friend:User {имя: "Друг"})
ВОЗВРАТИТЕ друга;

Прибавьте нашу дружбу идемпотентным образом, таким образом, мы можем запустить повторно запрос, не прибавляя это
несколько раз. Мы возвращаем отношение, чтобы проверить, что оно не было создано
несколько раз.

СООТВЕТСТВИЕ (me:User {имя: "Я"}), (friend:User {имя: "Друг"})
СОЗДАЙТЕ УНИКАЛЬНЫЙ (меня) - [friendship:FRIEND]-> (друг)
ВОЗВРАТИТЕ дружбу;

Вы можете запустить повторно запрос, видеть, что он ничего не изменяет во второй раз!

Пустите нам обновлять нашу дружбу с начиная со свойства:

СООТВЕТСТВИЕ (me:User {имя: "Я"}) - [friendship:FRIEND]-> (friend:User {имя: "Друг"})
НАБОР friendship.since ='forever'
ВОЗВРАТИТЕ дружбу;

Пустите нам симулировать нас являющийся нашим другом и желающий видеть который фильмы наши друзья
оценили.

СООТВЕТСТВИЕ (me:User {имя: "Друг"}) - [:FRIEND] - (друг) - [rating:RATED]-> (фильм)
ВОЗВРАТИТЕ movie.title, в среднем (rating.stars) звезды AS, соберите (rating.comment) комментарии AS, количество (*);

+--------------------------------------------------+
|movie.title |stars|comments |count (*) |
|--------------------------------------------------|
|1 строка |
|--------------------------------------------------|
| "Матрица" |5.0 | ["Я люблю тот фильм!"] |1 |
+--------------------------------------------------+

Это - слишком небольшие данные, пустите нам прибавлять еще некоторых друзей и дружбу.

СООТВЕТСТВИЕ (me:User {имя: "Я"})
FOREACH (я В диапазоне (1,10) | СОЗДАЮ (friend:User {имя: "Друг" + i}), (я) - [:FRIEND]-> (друг));

Покажите всем нашим друзьям:

СООТВЕТСТВИЕ (me:User {имя: "Я"}) - [r:FRIEND]-> (друг)
ВОЗВРАТИТЕ дружбу AS типа (r), friend.name;

+-----------------------+
|friendship|friend.name |
|-----------------------|
|11 строк |
|-----------------------|
| "ДРУГ" | "Друг" |
|----------+------------|
| "ДРУГ" | "Друг 1" |
|----------+------------|
| "ДРУГ" | "Друг 2" |
|----------+------------|
| "ДРУГ" | "Друг 3" |
|----------+------------|
| "ДРУГ" | "Друг 4" |
|----------+------------|
| "ДРУГ" | "Друг 5" |
|----------+------------|
| "ДРУГ" | "Друг 6" |
|----------+------------|
| "ДРУГ" | "Друг 7" |
|----------+------------|
| "ДРУГ" | "Друг 8" |
|----------+------------|
| "ДРУГ" | "Друг 9" |
|----------+------------|
| "ДРУГ" | "Друг 10" |
+-----------------------+

4.4. Обнаружение Путей

Наши составы графика в качестве примера фильмов с заголовком и год и агенты с a
имя. У агентов есть отношения ACTS_IN к фильмам, который представляет роль
они играли. У этого отношения также есть ролевой атрибут.

Мы запрашивали и до сих пор обновляли данные, теперь пустите нам обнаруживать интересным
совокупности, a.k.a. пути.

СОЗДАЙТЕ (matrix1:Movie {заголовок: 'Матрица', год: '1999-03-31'})
СОЗДАЙТЕ (matrix2:Movie {заголовок: 'Матрица: Перезагрузка', год: '2003-05-07'})
СОЗДАЙТЕ (matrix3:Movie {заголовок: 'Матричные Обороты, год: '2003-10-27'})
СОЗДАЙТЕ (keanu:Actor {называют:' Киану Ривза'}),
СОЗДАЙТЕ (laurence:Actor {называют:' Лоуренса Фишберна'}),
СОЗДАЙТЕ (carrieanne:Actor {называют:'карри-Энн Мосс}),
СОЗДАЙТЕ (keanu) - [:ACTS_IN {роль: 'Нео'}]-> (matrix1)
СОЗДАЙТЕ (keanu) - [:ACTS_IN {роль: 'Нео'}]-> (matrix2)
СОЗДАЙТЕ (keanu) - [:ACTS_IN {роль: 'Нео'}]-> (matrix3)
СОЗДАЙТЕ (laurence) - [:ACTS_IN {роль: 'Морфей'}]-> (matrix1)
СОЗДАЙТЕ (laurence) - [:ACTS_IN {роль: 'Морфей'}]-> (matrix2)
СОЗДАЙТЕ (laurence) - [:ACTS_IN {роль: 'Морфей'}]-> (matrix3)
СОЗДАЙТЕ (carrieanne) - [:ACTS_IN {роль: 'Троица'}]-> (matrix1)
СОЗДАЙТЕ (carrieanne) - [:ACTS_IN {роль: 'Троица'}]-> (matrix2)
СОЗДАЙТЕ (carrieanne) - [:ACTS_IN {роль: 'Троица'}]-> (matrix3)

Все другие фильмы, что агенты в “Матрице” действовали в упорядоченном по возникновению:

СООТВЕТСТВИЕ (:Movie {заголовок: "Матрица"}) <-[:ACTS_IN] - (агент) - [:ACTS_IN]-> (фильм)
ВОЗВРАТИТЕ movie.title, количество (*)
ПОРЯДОК количеством (*) DESC;

+---------------------------------+
|movie.title |count (*) |
|---------------------------------|
|2 строки |
|---------------------------------|
| "Матрица: Революция" |3 |
|------------------------+--------|
| "Матрица: Перезагрузка" |3 |
+---------------------------------+

Пустите нам видеть, кто действовал в каждом из этих фильмов:

СООТВЕТСТВИЕ (:Movie {заголовок: "Матрица"}) <-[:ACTS_IN] - (агент) - [:ACTS_IN]-> (фильм)
ВОЗВРАТИТЕ movie.title, соберитесь (actor.name), количество (*) количество AS
ПОРЯДОК количеством DESC;

+-----------------------------------------------------------------------------+
|movie.title |collect (actor.name) |count |
|-----------------------------------------------------------------------------|
|2 строки |
|-----------------------------------------------------------------------------|
| "Матрица | ["Киану Ривз", "Лоуренс Фишберн", "Кэрри-Анне|3 |
|Revolutions" |Moss"] | |
|---------------------+-------------------------------------------------+-----|
| "Матрица: Перезагрузка" | ["Киану Ривз", "Лоуренс Фишберн", "Кэрри-Анне|3 |
| |Moss"] | |
+-----------------------------------------------------------------------------+

Что относительно согласия, которое является агентами, которые действовали вместе:

СООТВЕТСТВИЕ (:Movie {заголовок: "Матрица"
  }) <-[:ACTS_IN] - (агент) - [:ACTS_IN]-> (фильм) <-[:ACTS_IN] - (коллега)
ВОЗВРАТИТЕ actor.name, соберитесь (ЯВНЫЙ colleague.name);

+--------------------------------------------------------------+
|actor.name |collect (явный colleague.name) |
|--------------------------------------------------------------|
|3 строки |
|--------------------------------------------------------------|
| "Кэрри-Энн Мосс" | ["Киану Ривз", "Лоуренс Фишберн"] |
|--------------------+-----------------------------------------|
| "Лоуренс Фишберн" | ["Киану Ривз", "Кэрри-Энн Мосс"] |
|--------------------+-----------------------------------------|
| "Киану Ривз" | ["Лоуренс Фишберн", "Кэрри-Энн Мосс"] |
+--------------------------------------------------------------+

Кто из тех других агентов действовал чаще всего с кем-либо от матричного броска?

СООТВЕТСТВИЕ (:Movie {заголовок: "Матрица"
  }) <-[:ACTS_IN] - (агент) - [:ACTS_IN]-> (фильм) <-[:ACTS_IN] - (коллега)
ВОЗВРАТИТЕ colleague.name, количество (*)
ПОРЯДОК количеством (*) ПРЕДЕЛ DESC 10;

+------------------------------+
|colleague.name |count (*) |
|------------------------------|
|3 строки |
|------------------------------|
| "Кэрри-Энн Мосс" |4 |
|---------------------+--------|
| "Киану Ривз" |4 |
|---------------------+--------|
| "Лоуренс Фишберн" |4 |
+------------------------------+

Запускаясь с путей, путь - последовательность вершин и отношений от a
запустите вершину к конечному узлу.

Мы знаем, что Троица любит Нео, но сколько путей существует между своими агентами?
Мы ограничим длину пути и запрос, поскольку это исчерпывающе ищет график
иначе

СООТВЕТСТВУЙТЕ p = (:Actor {имя: "Киану Ривз"}) - [:ACTS_IN*0.. 5] - (:Actor {имя: "Кэрри-Энн Мосс"})
ВОЗВРАТИТЕ p, длина (p)
ПРЕДЕЛ 10;

+-----------------------------------------------------------------------------+
|p |length |
| | (p) |
|-----------------------------------------------------------------------------|
|9 строк |
|-----------------------------------------------------------------------------|
| [Вершина [3] {имя: "Киану Ривз"}:ACTS_IN [0] {роль: "Нео"}, Вершина [0] |4 |
| {заголовок: "Матрица", год: "1999-03-31"}:ACTS_IN [3] | |
| {роль: "Морфей"}, Вершина [4] {имя: "Лоуренс Фишберн"}:ACTS_IN [4] | |
| {роль: "Морфей"}, Вершина [1] {заголовок: "Матрица | |
|Reloaded", год: "2003-05-07"}:ACTS_IN [7] {роль: "Троица"}, Вершина [5] | |
| {имя: "Кэрри-Энн Мосс"}] | |
|----------------------------------------------------------------------+------|
| [Вершина [3] {имя: "Киану Ривз"}:ACTS_IN [0] {роль: "Нео"}, Вершина [0] |4 |
| {заголовок: "Матрица", год: "1999-03-31"}:ACTS_IN [3] | |
| {роль: "Морфей"}, Вершина [4] {имя: "Лоуренс Фишберн"}:ACTS_IN [5] | |
| {роль: "Морфей"}, Вершина [2] {заголовок: "Матрица | |
|Revolutions", год: "2003-10-27"}:ACTS_IN [8] {роль: "Троица"}, Вершина [5] | |
| {имя: "Кэрри-Энн Мосс"}] | |
|----------------------------------------------------------------------+------|
| [Вершина [3] {имя: "Киану Ривз"}:ACTS_IN [0] {роль: "Нео"}, Вершина [0] |2 |
| {заголовок: "Матрица", год: "1999-03-31"}:ACTS_IN [6] | |
| {роль: "Троица"}, Вершина [5] {имя: "Кэрри-Энн Мосс"}] | |
|----------------------------------------------------------------------+------|
| [Вершина [3] {имя: "Киану Ривз"}:ACTS_IN [1] {роль: "Нео"}, Вершина [1] |4 |
| {заголовок: "Матрица: Перезагрузка", год: "2003-05-07"}:ACTS_IN [4] | |
| {роль: "Морфей"}, Вершина [4] {имя: "Лоуренс Фишберн"}:ACTS_IN [3] | |
| {роль: "Морфей"}, Вершина [0] {заголовок: "| |
|Matrix", год: "1999-03-31"}:ACTS_IN [6] {роль: "Троица"}, Вершина [5] | |
| {имя: "Кэрри-Энн Мосс"}] | |
|----------------------------------------------------------------------+------|
| [Вершина [3] {имя: "Киану Ривз"}:ACTS_IN [1] {роль: "Нео"}, Вершина [1] |4 |
| {заголовок: "Матрица: Перезагрузка", год: "2003-05-07"}:ACTS_IN [4] | |
| {роль: "Морфей"}, Вершина [4] {имя: "Лоуренс Фишберн"}:ACTS_IN [5] | |
| {роль: "Морфей"}, Вершина [2] {заголовок: "Матрица | |
|Revolutions", год: "2003-10-27"}:ACTS_IN [8] {роль: "Троица"}, Вершина [5] | |
| {имя: "Кэрри-Энн Мосс"}] | |
|----------------------------------------------------------------------+------|
| [Вершина [3] {имя: "Киану Ривз"}:ACTS_IN [1] {роль: "Нео"}, Вершина [1] |2 |
| {заголовок: "Матрица: Перезагрузка", год: "2003-05-07"}:ACTS_IN [7] | |
| {роль: "Троица"}, Вершина [5] {имя: "Кэрри-Энн Мосс"}] | |
|----------------------------------------------------------------------+------|
| [Вершина [3] {имя: "Киану Ривз"}:ACTS_IN [2] {роль: "Нео"}, Вершина [2] |4 |
| {заголовок: "Матрица: Революция", год: "2003-10-27"}:ACTS_IN [5] | |
| {роль: "Морфей"}, Вершина [4] {имя: "Лоуренс Фишберн"}:ACTS_IN [3] | |
| {роль: "Морфей"}, Вершина [0] {заголовок: "| |
|Matrix", год: "1999-03-31"}:ACTS_IN [6] {роль: "Троица"}, Вершина [5] | |
| {имя: "Кэрри-Энн Мосс"}] | |
|----------------------------------------------------------------------+------|
| [Вершина [3] {имя: "Киану Ривз"}:ACTS_IN [2] {роль: "Нео"}, Вершина [2] |4 |
| {заголовок: "Матрица: Революция", год: "2003-10-27"}:ACTS_IN [5] | |
| {роль: "Морфей"}, Вершина [4] {имя: "Лоуренс Фишберн"}:ACTS_IN [4] | |
| {роль: "Морфей"}, Вершина [1] {заголовок: "Матрица | |
|Reloaded", год: "2003-05-07"}:ACTS_IN [7] {роль: "Троица"}, Вершина [5] | |
| {имя: "Кэрри-Энн Мосс"}] | |
|----------------------------------------------------------------------+------|
| [Вершина [3] {имя: "Киану Ривз"}:ACTS_IN [2] {роль: "Нео"}, Вершина [2] |2 |
| {заголовок: "Матрица: Революция", год: "2003-10-27"}:ACTS_IN [8] | |
| {роль: "Троица"}, Вершина [5] {имя: "Кэрри-Энн Мосс"}] | |
+-----------------------------------------------------------------------------+

Колючка это - много данных, мы только, хочет смотреть на имена и заголовки
вершины пути.

СООТВЕТСТВУЙТЕ p = (:Actor {имя: "Киану Ривз"}) - [:ACTS_IN*0.. 5] - (:Actor {имя: "Кэрри-Энн Мосс"})
ВОЗВРАТИТЕСЬ вытяжка (n В вершинах (p) | объединяют (n.title, n.name)), AS `имена И заголовки`, длина (p)
ПОРЯДОК длиной (p)
ПРЕДЕЛ 10;

+-----------------------------------------------------------------------------+
|names и заголовки |length |
| | (p) |
|-----------------------------------------------------------------------------|
|9 строк |
|-----------------------------------------------------------------------------|
| ["Киану Ривз", "Матрица", "Кэрри-Энн Мосс"] |2 |
|----------------------------------------------------------------------+------|
| ["Киану Ривз", "Матрица: Перезагрузка", "Кэрри-Энн Мосс"] |2 |
|----------------------------------------------------------------------+------|
| ["Киану Ривз", "Матрица: Революция", "Кэрри-Энн Мосс"] |2 |
|----------------------------------------------------------------------+------|
| ["Киану Ривз", "Матрица", "Лоуренс Фишберн", "Матрица |4 |
|Reloaded", "Кэрри-Энн Мосс"] | |
|----------------------------------------------------------------------+------|
| ["Киану Ривз", "Матрица", "Лоуренс Фишберн", "Матрица |4 |
|Revolutions", "Кэрри-Энн Мосс"] | |
|----------------------------------------------------------------------+------|
| ["Киану Ривз", "Матрица: Перезагрузка", "Лоуренс Фишберн", "|4 |
|Matrix", "Кэрри-Энн Мосс"] | |
|----------------------------------------------------------------------+------|
| ["Киану Ривз", "Матрица: Перезагрузка", "Лоуренс Фишберн", "Matrix|4 |
|Revolutions", "Кэрри-Энн Мосс"] | |
|----------------------------------------------------------------------+------|
| ["Киану Ривз", "Матрица: Революция", "Лоуренс Фишберн", "|4 |
|Matrix", "Кэрри-Энн Мосс"] | |
|----------------------------------------------------------------------+------|
| ["Киану Ривз", "Матрица: Революция", "Лоуренс Фишберн", "|4 |
|Matrix, Перезагруженный", "Кэрри-Энн Мосс"] | |
+-----------------------------------------------------------------------------+

4.5. Метки, Ограничения и Индексируют

Метки - удобный способ собрать в группу вершины. Они используются, чтобы ограничить
запросы, определите ограничения и создайте, индексирует.

Следующее даст пример того, как использовать метки. Пустите нам начинать добавляться
ограничение  -  в этом случае, мы решили, что все заголовки вершины Фильма должны быть
уникальный.

СОЗДАЙТЕ ОГРАНИЧЕНИЕ НА (movie:Movie), УТВЕРЖДАЮТ movie.title УНИКАЛЬНЫЙ IS

Заметьте, что добавление уникального ограничения прибавит индексирование на том свойстве, таким образом,
мы не будем делать этого отдельно. Если мы отбрасываем ограничение, мы должны будем добавиться
индексируйте вместо этого, как необходимый.

В этом случае мы хотим, чтобы индексирование ускорило агентов обнаружения по имени в
база данных:

СОЗДАЙТЕ ИНДЕКСИРУЮТ НА:Actor (имя)

Индексирует может быть прибавлен в любое время. Ограничения могут быть прибавлены после того, как метка
уже в использовании, но это требует, чтобы существующие данные выполнили
ограничения. Заметьте, что это займет время для индексирования, чтобы прибыть онлайн когда
есть существующие данные.

Теперь, пустите нам прибавлять некоторые данные.

СОЗДАЙТЕ (actor:Actor {имя: "Том Хэнкс"}), (movie:Movie {заголовок:'Sleepless В Сиэтле'}),
  (агент) - [:ACTED_IN]-> (фильм);

Обычно Вы не определяете, индексирует, запрашивая для данных. Они будут использоваться
автоматически. Это означает, что мы можем просто искать вершину Тома Хэнкса, и
индексируйте умрет негласно, чтобы усилить производительность.

СООТВЕТСТВИЕ (actor:Actor {имя: "Том Хэнкс"})
ВОЗВРАТИТЕ агента;

Теперь скажем, мы хотим прибавить другую метку для вершины. Вот то, как сделать это:

СООТВЕТСТВИЕ (actor:Actor {имя: "Том Хэнкс"})
Агент НАБОРА:American;

Чтобы переместить метку от вершин, это - то, что сделать:

СООТВЕТСТВИЕ (actor:Actor {имя: "Том Хэнкс"})
ПЕРЕМЕЩЕНИЕ actor:American;

Для получения дополнительной информации по меткам и связанным разделам, см.:

  * Раздел 3.4, "Метки"
  * Глава 13, Схема
  * Раздел 13.2, "Ограничения"
  * Раздел 13.1, "Индексирует"
  * Раздел 9.7, "Используя"
  * Раздел 11.4, "Набор"
  * Раздел 11.6, "Перемещение"

Глава 5. Примеры Моделирования данных

Следующие главы содержат упрощенные примеры того, как различные домены могут
будьте смоделированы, используя Neo4j. Цель не состоит в том, чтобы дать полные примеры, но предложить
возможные способы думать, используя вершины, отношения, модели графика и данные
местоположение в обходах.

Код использования в качестве примера запрашивает много, считайте Часть III, “Язык Запроса Кода”
для получения дополнительной информации.

5.1. Связанные списки

Мощная функция использования базы данных графика, то, что Вы можете создать свое собственное
структуры данных в графике  -  например связанный список.

Эта структура данных использует единственную вершину в качестве ссылки списка. Ссылка имеет
исходящее отношение голове списка, и входящее отношение
от последнего элемента списка. Если список будет пуст, то ссылка будет
укажите на себя.

Чтобы прояснить, что происходит, мы покажем, как график заботится о каждом
запрос.

Чтобы инициализировать пустой связанный список, мы просто создаем вершину, и заставляем это соединиться
к себе. В отличие от фактических элементов списка, у этого нет свойства значения.

СОЗДАЙТЕ (корень {имя: 'КОРЕНЬ'}) - [:LINK]-> (корень)
ВОЗВРАТИТЕ корень

cypherdoc - cf38d218.svg

Добавление значений сделано, обнаруживая отношение, где новое значение должно быть
размещенный в, и замена этого с новой вершиной, и двумя отношениями к этому. Мы
также должны обработать факт, что прежде и после того, как вершины могли быть тем же самым
как корневой узел. Случай, где прежде, после и корневой узел весь
то же самое, заставляет использовать, СОЗДАЮТ УНИКАЛЬНЫЙ, чтобы не создать две новых вершины значения
по ошибке.

СООТВЕТСТВИЕ (корень) - [:LINK*0..]-> (прежде), (после) - [:LINK*0..]-> (корень), (прежде) - [old:LINK]-> (после)
ГДЕ root.name = 'БАЗИРУЮТСЯ' И (before.value <25 ИЛИ прежде = корень) И (25 <after.value ИЛИ после =
  корень)
СОЗДАЙТЕ УНИКАЛЬНЫЙ (прежде) - [:LINK]-> ({value:25}) - [:LINK]-> (после)
СОТРИТЕ старый

cypherdoc - 89a53f24.svg

Пустите нам прибавлять еще одно значение:

СООТВЕТСТВИЕ (корень) - [:LINK*0..]-> (прежде), (после) - [:LINK*0..]-> (корень), (прежде) - [old:LINK]-> (после)
ГДЕ root.name = 'БАЗИРУЮТСЯ' И (before.value <10 ИЛИ прежде = корень) И (10 <after.value ИЛИ после =
  корень)
СОЗДАЙТЕ УНИКАЛЬНЫЙ (прежде) - [:LINK]-> ({value:10}) - [:LINK]-> (после)
СОТРИТЕ старый

cypherdoc - d546bacf.svg

Удаление значения, наоборот, сделано, обнаруживая вершину со значением, и
эти два отношения, входящие и из этого, и заменяющие отношения
с новым.

СООТВЕТСТВИЕ (корень) - [:LINK*0..]-> (прежде), (прежде) - [delBefore:LINK]-> (del) - [delAfter:LINK]-> (после),
  (после) - [:LINK*0..]-> (корень)
ГДЕ root.name = 'КОРЕНЬ' И del.value = 10
СОЗДАЙТЕ УНИКАЛЬНЫЙ (прежде) - [:LINK]-> (после)
СОТРИТЕ del, delBefore, delAfter

cypherdoc - 89a53f24.svg

Удаление последней вершины значения состоит в том тем, что требует, чтобы мы использовали, СОЗДАЮТ УНИКАЛЬНЫЙ когда
замена отношений. Иначе, мы закончили бы с двумя отношениями
от корневого узла до себя, и как прежде и как после того, как вершины равны
корневой узел, означая модель соответствовал бы дважды.

СООТВЕТСТВИЕ (корень) - [:LINK*0..]-> (прежде), (прежде) - [delBefore:LINK]-> (del) - [delAfter:LINK]-> (после),
  (после) - [:LINK*0..]-> (корень)
ГДЕ root.name = 'КОРЕНЬ' И del.value = 25
СОЗДАЙТЕ УНИКАЛЬНЫЙ (прежде) - [:LINK]-> (после)
СОТРИТЕ del, delBefore, delAfter

cypherdoc - cf38d218.svg

5.2. Сериалы

5.2.1. Модель данных
5.2.2. Демонстрационные Данные
5.2.3. Информация для шоу
5.2.4. Информация для агента

Это шоу в качестве примера, как сериалы с Сезонами, Эпизодами, Символами, Агентами,
Пользователи и Отзывы могут быть смоделированы в базе данных графика.

5.2.1. Модель данных

Пустите нам начинать с моделью отношения объекта домена под рукой:

modeling-tvshow-er-diagram.svg

Чтобы реализовать это в Neo4j, мы будем использовать следующие типы отношения:

Описание Типа отношения
ХЭС_СИСОН Коннектс шоу с его сезонами.

HAS_EPISODE Соединяет сезон со своими эпизодами.

FEATURED_CHARACTER Соединяет эпизод со своими символами.

PLAYED_CHARACTER Соединяет агентов с символами. Замечание
                   то, что агент может играть разнообразный
                   символы в эпизоде, и что
                   тот же самый символ может играться разнообразным
                   агенты также.

HAS_REVIEW Соединяет эпизод со своими отзывами.

WROTE_REVIEW Соединяет пользователей с отзывами они
                   внесенный.

5.2.2. Демонстрационные Данные

Пустите нам создавать некоторые данные и видеть, как домен теряет значение практически:

СОЗДАЙТЕ (himym:TVShow {имя: "Как я Встретил Ваш Родительский элемент"}),
СОЗДАЙТЕ (himym_s1:Season {имя: "Сезон HIMYM 1"})
СОЗДАЙТЕ (himym_s1_e1:Episode {имя: "Пилот"})
СОЗДАЙТЕ (ted:Character {имя: "Тед Мосби"})
СОЗДАЙТЕ (joshRadnor:Actor {имя: "Джош Рэднор"})
СОЗДАЙТЕ УНИКАЛЬНЫЙ (joshRadnor) - [:PLAYED_CHARACTER]-> (Тед)
СОЗДАЙТЕ УНИКАЛЬНЫЙ (himym) - [:HAS_SEASON]-> (himym_s1)
СОЗДАЙТЕ УНИКАЛЬНЫЙ (himym_s1) - [:HAS_EPISODE]-> (himym_s1_e1)
СОЗДАЙТЕ УНИКАЛЬНЫЙ (himym_s1_e1) - [:FEATURED_CHARACTER]-> (Тед)
СОЗДАЙТЕ (himym_s1_e1_review1 {заголовок: "Встретьте Меня В Баре В 15 Минутах & Экипируйтесь",
  контент: "Это было удивительным"}),
СОЗДАЙТЕ (wakenPayne:User {имя: "WakenPayne"})
СОЗДАЙТЕ (wakenPayne) - [:WROTE_REVIEW]-> (himym_s1_e1_review1) <-[:HAS_REVIEW] - (himym_s1_e1)

Это - то, как данные смотрят в базе данных:

cypherdoc - 573a3ce5.svg

Заметьте это даже при том, что мы, возможно, смоделировали отзывы как отношения с
заголовок и свойства контента на них, мы сделали их вершинами вместо этого. Мы получаем много
из гибкости таким образом, например если мы хотим соединить комментарии с каждым
анализ.

Теперь пустите нам прибавлять больше данных:

СООТВЕТСТВИЕ (himym:TVShow {имя: "Как я Встретил Ваш Родительский элемент"}), (himym_s1:Season),
  (himym_s1_e1:Episode {имя: "Пилот"}),
  (himym) - [:HAS_SEASON]-> (himym_s1) - [:HAS_EPISODE]-> (himym_s1_e1)
СОЗДАЙТЕ (marshall:Character {имя: "Маршал Эриксен"})
СОЗДАЙТЕ (robin:Character {имя: "Робин Щербацкий"})
СОЗДАЙТЕ (barney:Character {имя: "Барни Стинсон"})
СОЗДАЙТЕ (lily:Character {имя: "Лили Олдрин"})
СОЗДАЙТЕ (jasonSegel:Actor {имя: "Джейсон Сегель"})
СОЗДАЙТЕ (cobieSmulders:Actor {имя: "Cobie Smulders"})
СОЗДАЙТЕ (neilPatrickHarris:Actor {имя: "Нил Патрик Харрис"})
СОЗДАЙТЕ (alysonHannigan:Actor {имя: "Ализон Хэннигэн"})
СОЗДАЙТЕ УНИКАЛЬНЫЙ (jasonSegel) - [:PLAYED_CHARACTER]-> (Маршалл)
СОЗДАЙТЕ УНИКАЛЬНЫЙ (cobieSmulders) - [:PLAYED_CHARACTER]-> (малиновка)
СОЗДАЙТЕ УНИКАЛЬНЫЙ (neilPatrickHarris) - [:PLAYED_CHARACTER]-> (толкач)
СОЗДАЙТЕ УНИКАЛЬНЫЙ (alysonHannigan) - [:PLAYED_CHARACTER]-> (лилия)
СОЗДАЙТЕ УНИКАЛЬНЫЙ (himym_s1_e1) - [:FEATURED_CHARACTER]-> (Маршалл)
СОЗДАЙТЕ УНИКАЛЬНЫЙ (himym_s1_e1) - [:FEATURED_CHARACTER]-> (малиновка)
СОЗДАЙТЕ УНИКАЛЬНЫЙ (himym_s1_e1) - [:FEATURED_CHARACTER]-> (толкач)
СОЗДАЙТЕ УНИКАЛЬНЫЙ (himym_s1_e1) - [:FEATURED_CHARACTER]-> (лилия)
СОЗДАЙТЕ (himym_s1_e1_review2 {заголовок: "Какой великий пилот для шоу :)",
  контент: "Юмор является большим."})
СОЗДАЙТЕ (atlasredux:User {имя: "atlasredux"})
СОЗДАЙТЕ (atlasredux) - [:WROTE_REVIEW]-> (himym_s1_e1_review2) <-[:HAS_REVIEW] - (himym_s1_e1)

5.2.3. Информация для шоу

Для определенного сериала, покажите все сезоны и все эпизоды и весь
отзывы и все актеры от того шоу, которое является всей информацией
соединенный с тем сериалом.

СООТВЕТСТВИЕ (tvShow:TVShow) - [:HAS_SEASON]-> (сезон) - [:HAS_EPISODE]-> (эпизод)
ГДЕ tvShow.name =, "Как я Встретил Ваш Родительский элемент"
ВОЗВРАТИТЕ season.name, episode.name

+------------------------------+
|season.name |episode.name |
|------------------------------|
|1 строка |
|------------------------------|
| "Сезон HIMYM 1" | "Пилот" |
+------------------------------+

Мы могли также захватить отзывы, если есть кто-либо, немного настраивая запрос:

СООТВЕТСТВИЕ (tvShow:TVShow) - [:HAS_SEASON]-> (сезон) - [:HAS_EPISODE]-> (эпизод)
ГДЕ tvShow.name =, "Как я Встретил Ваш Родительский элемент"
С сезоном, эпизодом
ДОПОЛНИТЕЛЬНОЕ СООТВЕТСТВИЕ (эпизод) - [:HAS_REVIEW]-> (анализ)
ВОЗВРАТИТЕ season.name, episode.name, анализ

+-----------------------------------------------------------------------------+
|season.name|episode.name|review |
|-----------------------------------------------------------------------------|
|2 строки |
|-----------------------------------------------------------------------------|
| "HIMYM | "Экспериментальный" |Node [5] {заголовок: "Встретьте Меня В Баре В 15 Минутах & |
|Season 1" | |Suit", контент: "Это было удивительным"} |
|-----------+------------+----------------------------------------------------|
| "HIMYM | "Экспериментальный" |Node [15] {заголовок: "Какой великий пилот для шоу :) |
|Season 1" | | ", контент: "Юмор является большим."} |
+-----------------------------------------------------------------------------+

Теперь пустите нам перечислять символы, которыми обладают на шоу. Заметьте это в этом запросе мы
только помещенные идентификаторы на вершинах мы фактически используем позже. Другие вершины
модель пути определяется ().

СООТВЕТСТВИЕ (tvShow:TVShow) - [:HAS_SEASON]-> () - [:HAS_EPISODE]-> () - [:FEATURED_CHARACTER]-> (символ)
ГДЕ tvShow.name =, "Как я Встретил Ваш Родительский элемент"
ВОЗВРАТИТЕ ЯВНЫЙ character.name

+-------------------+
|character.name |
|-------------------|
|5 строк |
|-------------------|
| "Тед Мосби" |
|-------------------|
| "Маршал Эриксен" |
|-------------------|
| "Робин Щербацкий" |
|-------------------|
| "Барни Стинсон" |
|-------------------|
| "Лили Олдрин" |
+-------------------+

Теперь пустите нам смотреть на то, как получить всех актеров шоу.

СООТВЕТСТВИЕ
  (tvShow:TVShow) - [:HAS_SEASON]-> () - [:HAS_EPISODE]-> (эпизод) - [:FEATURED_CHARACTER]-> () <-[:PLAYED_CHARACTER] - (агент)
ГДЕ tvShow.name =, "Как я Встретил Ваш Родительский элемент"
ВОЗВРАТИТЕ ЯВНЫЙ actor.name

+---------------------+
|actor.name |
|---------------------|
|5 строк |
|---------------------|
| "Джош Рэднор" |
|---------------------|
| "Джейсон Сегель" |
|---------------------|
| "Cobie Smulders" |
|---------------------|
| "Нил Патрик Харрис" |
|---------------------|
| "Ализон Хэннигэн" |
+---------------------+

5.2.4. Информация для агента

Сначала пустите нам прибавлять другой сериал, в котором появился Джош Рэднор:

СОЗДАЙТЕ (er:TVShow {имя: "ER"})
СОЗДАЙТЕ (er_s9:Season {имя: "ER S7"})
СОЗДАЙТЕ (er_s9_e17:Episode {имя: "Продвижение Питера"})
СОЗДАЙТЕ (tedMosby:Character {имя: "Защитник"})
СОЗДАЙТЕ УНИКАЛЬНЫЙ (er) - [:HAS_SEASON]-> (er_s9)
СОЗДАЙТЕ УНИКАЛЬНЫЙ (er_s9) - [:HAS_EPISODE]-> (er_s9_e17)
С er_s9_e17
СООТВЕТСТВИЕ (actor:Actor), (episode:Episode)
ГДЕ actor.name = "Джош Рэднор" И episode.name = "Продвижение Питера"
С агентом, эпизодом
СОЗДАЙТЕ (keith:Character {имя: "Кит"})
СОЗДАЙТЕ УНИКАЛЬНЫЙ (агент) - [:PLAYED_CHARACTER]-> (keith)
СОЗДАЙТЕ УНИКАЛЬНЫЙ (эпизод) - [:FEATURED_CHARACTER]-> (keith)

И теперь мы создадим запрос, чтобы обнаружить эпизоды, в которых он появился:

СООТВЕТСТВИЕ (actor:Actor) - [:PLAYED_CHARACTER]-> (символ) <-[:FEATURED_CHARACTER] - (эпизод)
ГДЕ actor.name = "Джош Рэднор"
ВОЗВРАТИТЕ episode.name Эпизод AS, character.name Символ AS

+-------------------------------+
|Episode |Character |
|-------------------------------|
|2 строки |
|-------------------------------|
| "Пилот" | "Тед Мосби" |
|-------------------+-----------|
| "Продвижение Питера" | "Кит" |
+-------------------------------+

Теперь пустите нам идти для подобного запроса, но прибавлять сезон и показывать этому также.

СООТВЕТСТВИЕ (actor:Actor) - [:PLAYED_CHARACTER]-> (символ) <-[:FEATURED_CHARACTER] - (эпизод),
  (эпизод) <-[:HAS_EPISODE] - (сезон) <-[:HAS_SEASON] - (tvshow)
ГДЕ actor.name = "Джош Рэднор"
ВОЗВРАТИТЕ tvshow.name Шоу AS, season.name Сезон AS, episode.name Эпизод AS,
  Символ AS character.name

+-----------------------------------------------------------------------+
|Show |Season |Episode |Character |
|-----------------------------------------------------------------------|
|2 строки |
|-----------------------------------------------------------------------|
| "Как я Встретил Ваш Родительский элемент" | "Сезон HIMYM 1" | "Пилот" | "Тед Мосби" |
|-----------------------+----------------+------------------+-----------|
| "ER" | "ER S7" | "Продвижение Питера" | "Кит" |
+-----------------------------------------------------------------------+

5.3. Строения ACL в графиках

5.3.1. Универсальный подход
5.3.2. Пример разрешения чтения

Этот пример дает универсальный краткий обзор подхода к обработке Управления доступом
Списки (ACLs) в графиках, и упрощенный пример с бетонными запросами.

5.3.1. Универсальный подход

Во многих сценариях приложение должно обработать безопасность на некоторой форме
управляемые объекты. Этот пример описывает одну модель, чтобы обработать это через
использование строения графика и траверс, которые создают полное строение полномочий
для любого управляемого объекта с исключают и включают возможности переопределения. Это
результаты в динамической конструкции ACLs, основанного на позиции и контексте
управляемый объект.

Результат - комплексная схема безопасности, которая может легко быть реализована в a
строение графика, поддерживая переопределение полномочий, принципал и контент
композиция, не копируя данные где угодно.

ACL.png

5.3.1.1. Метод

Как замечено в расположении графика в качестве примера, в этом домене есть некоторые ключевые понятия
модель:

  * управляемый контент (приборы для испытания на излом и файлы), которые соединены
    Отношения HAS_CHILD_CONTENT
  * Основное поддерево, указывающее на принципалы, которые могут действовать как элементы ACL,
    указанный ОСНОВНЫМИ отношениями.
  * агрегация принципалов в группы, соединенные IS_MEMBER_OF
    отношение. Один принципал (пользователь или группа) может быть частью многих групп в
    то же самое время.
  * БЕЗОПАСНОСТЬ  -  отношения, соединяя контент составляют строение к
    основное составное строение, содержа модификатор прибавления/перемещения
    свойство (" +RW").

5.3.1.2. Построение ACL

Вычисление эффективных полномочий (например, Чтение, Запись, Выполняются) для a
принципал для любой данной управляемой ACL вершины (контент) следует за многими правилами
это будет закодировано в обход полномочий:

5.3.1.3. "Покрывайте вниз Обход"

Этот подход пустит Вам определять универсальную модель разрешения на корне
контент, и затем совершенствует это для определенных вершин подконтента и определенный
принципалы.

 1. Запустите в рассматриваемом траверзе вершины контента вверх к корню контента
    вершина, чтобы определить путь к этому.
 2. Запустите с эффективного оптимистического списка полномочий "всех разрешенных" (111
    в немного закодированном случае ReadWriteExecute) или 000, если Вам нравится пессимистичный
    обработка безопасности (все запрещено если явно не позволено).
 3. Начало от самой верхней вершины контента, ищите любую БЕЗОПАСНОСТЬ
    отношения на этом.
 4. Если найдено, смотрите, если рассматриваемый принципал - часть принципала конца
    отношение БЕЗОПАСНОСТИ.
 5. Если да, добавьтесь "+" модификаторы разрешения к существующему разрешению
    копируйте, отмените "-" модификаторы разрешения от модели.
 6. Если две основных вершины соединяются с той же самой вершиной контента, сначала применяются больше
    универсальные prinipals модификаторы.
 7. Повторите поиск модификатора безопасности полностью вниз к целевому контенту
    вершина, таким образом переопределяя больше универсальных полномочий с набором на вершинах ближе
    к целевой вершине.

Тот же самый алгоритм применим для подхода снизу вверх, в основном только
полигонометрия от целевой вершины контента вверх и применяя безопасность
модификаторы динамически как траверса восстанавливают работоспособность.

5.3.1.4. Пример

Теперь, чтобы получить следующие права доступа для например, "пользователя 1" на "Мой File.pdf"
в Нисходящем подходе к модели в графике выше пошел бы как:

 1. Перемещаясь вверх, мы запускаем с "Корневого каталога", и устанавливаем полномочия в
    11 первоначально (только рассматривающий Чтение, Запись).
 2. Есть два отношения БЕЗОПАСНОСТИ к тому прибору для испытания на излом. Пользователь 1 содержится в
    они оба, но "корень" более универсальны, так примените его сначала тогда "Все
    принципалы" +W +R → 11.
 3. "Домой" не имеет никаких инструкций SECURITY, продолжать.
 4. "у user1 Домой" есть БЕЗОПАСНОСТЬ. Сначала примените "Обычных пользователей" (-R-W) → 00, Затем
    "пользователь 1" (+R +W) → 11.
 5. У целевой вершины "Мой File.pdf" нет никаких модификаторов БЕЗОПАСНОСТИ на этом, таким образом,
    эффективными полномочиями для "Пользователя 1" на "Мой File.pdf" является ReadWrite → 11.

5.3.2. Пример разрешения чтения

В этом примере мы собираемся исследовать древовидную структуру каталогов и
файлы. Кроме того, есть пользователи, которым принадлежат файлы и роли, которые могут быть присвоены
пользователи. У ролей могут быть полномочия на каталоге или строениях файлов (здесь мы
модель только canRead, в противоположность полным rwx полномочиям Unix) и быть вложенным. A
более полный пример моделирования строений ACL может быть найден в том, Как Создать
Основанное на роли Управление доступом в SQL <http://www.xaprb.com/blog/2006/08/16/
how-to-build-role-based-access-control-in-sql/>.

The-Domain-Structure-ACL-structures-in-graphs.svg

5.3.2.1. Обнаружьте все файлы в структуре каталогов

Чтобы обнаружить, что все файлы делились без остатка в этом строении, мы нуждаемся в переменной
запрос длины, который следует за всем, содержит отношения и получает вершины в
другой конец листовых отношений.

СООТВЕТСТВИЕ ({имя: 'FileRoot'}) - [:contains*0..]-> (parentDir) - [:leaf]-> (файл)
ВОЗВРАТИТЕ файл

следование:

+----------------------+
|file |
|----------------------|
|2 строки |
|----------------------|
|Node [10] {имя: "File1"} |
|----------------------|
|Node [9] {имя: "File2"} |
+----------------------+

5.3.2.2. Какие файлы принадлежат кого?

Если мы представляем понятие владения на файлах, мы тогда можем попросить
владельцам файлов, через которые мы обнаруживаем  -  соединенным, принадлежат отношения, чтобы зарегистрировать вершины.

СООТВЕТСТВИЕ ({имя: 'FileRoot'}) - [:contains*0..]-> () - [:leaf]-> (файл) <-[:owns] - (пользователь)
ВОЗВРАТИТЕ файл, пользователя

Возврат владельцев всех файлов ниже вершины FileRoot.

+--------------------------------------------+
|file |user |
|--------------------------------------------|
|2 строки |
|--------------------------------------------|
|Node [10] {имя: "File1"} |Node [7] {имя: "User1"} |
|----------------------+---------------------|
|Node [9] {имя: "File2"} |Node [6] {имя: "User2"} |
+--------------------------------------------+

5.3.2.3. У кого есть доступ к Файлу?

Если мы теперь хотим проверить, какие пользователи считали доступ ко всем Файлам, и определяют
наш ACL как

  * У корневого каталога нет никакого предоставленного доступа.
  * Любой пользователь, имеющий роль, которой предоставили canRead доступ к одному из
    родительские приборы для испытания на излом Файла считали доступ.

Чтобы обнаружить пользователей, которые могут считать любую часть родительской иерархии прибора для испытания на излом
выше файлов Код обеспечивает дополнительный путь переменной длины.

СООТВЕТСТВИЕ (файл) <-[:leaf] - () <-[:contains*0..] - (dir)
ДОПОЛНИТЕЛЬНОЕ СООТВЕТСТВИЕ (dir) <-[:canRead] - (роль) - [:member]-> (readUser)
ГДЕ file.name = ~ 'File. *'
ВОЗВРАТИТЕ file.name, dir.name, role.name, readUser.name

Это возвратит файл, и каталог, где у пользователя есть canRead
разрешение наряду с пользователем и их ролью.

+--------------------------------------------+
|file.name|dir.name |role.name|readUser.name |
|--------------------------------------------|
|9 строк |
|--------------------------------------------|
| "File1" | "HomeU1" | <нуль> | <нуль> |
|---------+----------+---------+-------------|
| "File1" | "Домой" | <нуль> | <нуль> |
|---------+----------+---------+-------------|
| "File1" | "FileRoot" | "SUDOers" | "Admin1" |
|---------+----------+---------+-------------|
| "File1" | "FileRoot" | "SUDOers" | "Admin2" |
|---------+----------+---------+-------------|
| "File2" | "Рабочий стол" | <нуль> | <нуль> |
|---------+----------+---------+-------------|
| "File2" | "HomeU2" | <нуль> | <нуль> |
|---------+----------+---------+-------------|
| "File2" | "Домой" | <нуль> | <нуль> |
|---------+----------+---------+-------------|
| "File2" | "FileRoot" | "SUDOers" | "Admin1" |
|---------+----------+---------+-------------|
| "File2" | "FileRoot" | "SUDOers" | "Admin2" |
+--------------------------------------------+

Упомянутые выше результаты содержат нуль для дополнительных сегментов пути, которые могут быть
смягченный или выяснением нескольких запросов или возвратом только действительно необходимый
значения.

5.4. Гиперкрая

5.4.1. Find Groups
5.4.2. Обнаружьте все группы и роли для пользователя
5.4.3. Обнаружьте общие группы основанными на совместно используемых ролях

Вообразите пользователя, являющегося частью различных групп. Группа может иметь отличающийся
роли, и пользователь могут быть частью различных групп. Он также может иметь отличающийся
роли в различных группах кроме членства. Ассоциация Пользователя,
Группа и Роль могут упоминаться как HyperEdge. Однако, это может быть легко
смоделированный в графике свойства как вершина, которая получает это отношение не, как
изображенный ниже в вершине U1G2R1.

Рисунок 5.1. График

cypher-hyperedge-graph.svg


5.4.1. Find Groups

Узнать в том, какие роли пользователь являются для детали группами (здесь Group2),
следующий запрос может пересечь эту вершину HyperEdge и обеспечить ответы.

Запрос.

СООТВЕТСТВИЕ ({имя: 'User1'}) - [:hasRoleInGroup]-> (гиперкрай) - [:hasGroup]-> ({имя: 'Group2'}),
  (гиперкрай) - [:hasRole]-> (роль)
ВОЗВРАТИТЕ role.name

Роль User1 возвращена:

Таблица 5.1. Результат

+---------+
|role.name |
|---------|
|1 строка |
|---------|
| "Role1" |
+---------+


5.4.2. Обнаружьте все группы и роли для пользователя

Здесь, обнаружьте все группы и роли, которые пользователь имеет, сортированный именем роли.

Запрос.

СООТВЕТСТВИЕ ({имя: 'User1'}) - [:hasRoleInGroup]-> (гиперкрай) - [:hasGroup]-> (группа),
  (гиперкрай) - [:hasRole]-> (роль)
ВОЗВРАТИТЕ role.name, group.name
ПОРЯДОК role.name ASC

Группы и роли User1 возвращены:

Таблица 5.2. Результат

+---------------------+
|role.name|group.name |
|---------------------|
|2 строки |
|---------------------|
| "Role1" | "Group2" |
|---------+-----------|
| "Role2" | "Group1" |
+---------------------+


5.4.3. Обнаружьте общие группы основанными на совместно используемых ролях

Примите более сложный график:

 1. Две пользовательских вершины User1, User2.
 2. User1 находится в Group1, Group2, Group3.
 3. У User1 есть Role1, Role2 в Group1; Role2, Role3 в Group2; Role3, Role4 в
    Group3 (hyper края).
 4. User2 находится в Group1, Group2, Group3.
 5. У User2 есть Role2, Role5 в Group1; Role3, Role4 в Group2; Role5, Role6 в
    Group3 (hyper края).

График для этого похож на следующий (вершины как представление U1G2R23
HyperEdges):

Рисунок 5.2. График

cypher-hyperedgecommongroups-graph.svg


Чтобы возвратить Group1 и Group2 как, User1 и User2 совместно используют по крайней мере одну общую роль
в этих двух группах запрос похож на это:

Запрос.

СООТВЕТСТВИЕ (u1) - [:hasRoleInGroup]-> (hyperEdge1) - [:hasGroup]-> (группа), (hyperEdge1) - [:hasRole]-> (роль),
  (u2) - [:hasRoleInGroup]-> (hyperEdge2) - [:hasGroup]-> (группа), (hyperEdge2) - [:hasRole]-> (роль)
ГДЕ u1.name = 'User1' И u2.name = 'User2'
ВОЗВРАТИТЕ group.name, количество (роль)
ПОРЯДОК group.name ASC

Группы, где User1 и User2 совместно используют по крайней мере одну общую роль:

Таблица 5.3. Результат

+-----------------------+
|group.name|count (роль) |
|-----------------------|
|2 строки |
|-----------------------|
| "Group1" |1 |
|----------+------------|
| "Group2" |1 |
+-----------------------+


5.5. Основной друг, обнаруживающий основанный на социальном окружении

Вообразите график в качестве примера как следующий:

Рисунок 5.3. График

cypher-collabfiltering-graph.svg


Узнать друзей друзей Джо, которые уже не являются его друзьями,
запрос похож на это:

Запрос.

СООТВЕТСТВИЕ (joe {имя: 'Джо'}) - [:knows*2.. 2] - (friend_of_friend)
ГДЕ НЕ (joe) - [:knows] - (friend_of_friend)
ВОЗВРАТИТЕ friend_of_friend.name, ГРАФ (*)
ПОРЯДОК ГРАФОМ (*) DESC, friend_of_friend.name

Это возвращает список друзей друзей, упорядоченных номером соединений
им, и во-вторых их именем.

Таблица 5.4. Результат

+-------------------------------+
|friend_of_friend.name |COUNT (*) |
|-------------------------------|
|3 строки |
|-------------------------------|
| "Иэн" |2 |
|----------------------+--------|
| "Деррик" |1 |
|----------------------+--------|
| "Джилл" |1 |
+-------------------------------+


5.6. Cо-favorited места

5.6.1. Cо-favorited места  -  пользователи, которым нравится x также как y
5.6.2. Cо-теговые места  -  места имели отношение через теги

Рисунок 5.4. График

cypher-cofavoritedplaces-graph.svg


5.6.1. Cо-favorited места  -  пользователи, которым нравится x также как y

Новое месторождение размещает это люди также как кто фаворит это место:

  * Определяют, у кого есть место favorited x.
  *, у Чего еще есть они favorited, который не является местом x.

Запрос.

СООТВЕТСТВИЕ (место) <-[:favorite] - (человек) - [:favorite]-> (материал)
ГДЕ place.name = 'CoffeeShop1'
ВОЗВРАТИТЕ stuff.name, количество (*)
ПОРЯДОК количеством (*) DESC, stuff.name

Список мест, которые являются favorited людьми что favorited место запуска.

Таблица 5.5. Результат

+----------------------+
|stuff.name |count (*) |
|----------------------|
|3 строки |
|----------------------|
| "MelsPlace" |2 |
|-------------+--------|
| "CoffeShop2" |1 |
|-------------+--------|
| "SaunaX" |1 |
+----------------------+


5.6.2. Cо-теговые места  -  места имели отношение через теги

Места нового месторождения, которые тегированы с теми же самыми тегами:

  * Определяют теги для места x.
  *, Что еще тегировано то же самое как x, который не является x.

Запрос.

СООТВЕТСТВИЕ (место) - [:tagged]-> (тег) <-[:tagged] - (otherPlace)
ГДЕ place.name = 'CoffeeShop1'
ВОЗВРАТИТЕ otherPlace.name, соберитесь (tag.name)
ПОРЯДОК длиной (собираются (tag.name)), DESC, otherPlace.name

Этот запрос возвращает другие места чем CoffeeShop1, которые совместно используют те же самые теги;
они упорядочены номером тегов.

Таблица 5.6. Результат

+---------------------------------+
|otherPlace.name|collect (tag.name) |
|---------------------------------|
|3 строки |
|---------------------------------|
| "MelsPlace" | ["Холодный", "Удобный"] |
|---------------+-----------------|
| "CoffeeShop2" | ["Холодный"] |
|---------------+-----------------|
| "CoffeeShop3" | ["Удобный"] |
+---------------------------------+


5.7. Обнаружьте людей основанными на подобном избранном

Рисунок 5.5. График

cypher-peoplesimilarityfavorites-graph.svg


Узнать возможных новых друзей, основанных на них любящий подобные вещи как
спрашивая человека, используйте запрос как это:

Запрос.

СООТВЕТСТВИЕ (я {имя: 'Джо'}) - [:favorite]-> (материал) <-[:favorite] - (человек)
ГДЕ НЕ (я) - [:friend] - (человек)
ВОЗВРАТИТЕ person.name, количество (материал)
ПОРЯДОК количеством (материал) DESC

Список возможных друзей, упорядоченных ими любящий подобный материал, которые не являются
все же друзья возвращены.

Таблица 5.7. Результат

+-------------------------+
|person.name|count (материал) |
|-------------------------|
|2 строки |
|-------------------------|
| "Деррик" |2 |
|-----------+-------------|
| "Джилл" |1 |
+-------------------------+


5.8. Обнаружьте людей основанными на общих друзьях и группах

Рисунок 5.6. График

cypher-mutualfriendsandgroups-graph.svg


В этом сценарии проблема состоит в том, чтобы определить общих друзей и группы, если
любой, между людьми. Если никакие взаимные группы или друзья не найдены, должно быть
0 возвратился.

Запрос.

СООТВЕТСТВИЕ (я {имя: 'Джо'}), (другой)
ГДЕ other.name В ['Джилл', 'Боб']
ДОПОЛНИТЕЛЬНОЕ СООТВЕТСТВИЕ pGroups = (я) - [:member_of_group]-> (мг) <-[:member_of_group] - (другой)
ДОПОЛНИТЕЛЬНОЕ СООТВЕТСТВИЕ pMutualFriends = (я) - [:knows]-> (средняя частота) <-[:knows] - (другой)
ВОЗВРАТИТЕ other.name имя AS, количество (ЯВНЫЙ pGroups) AS mutualGroups,
  количество (ЯВНЫЙ pMutualFriends) AS mutualFriends
ПОРЯДОК mutualFriends DESC

Вопросом, который мы задаем, является  - , сколько уникальных путей там между мной и
Джилл, пути, являющиеся общими составами группы, и общими друзьями. Если
пути обязательны, никакие результаты не будут возвращены если меня и отсутствие Боба никто распространенный
друзья, и мы не хотим это. Чтобы сделать путь дополнительным, Вы должны сделать в
наименьшее количество одно из этого - дополнительные отношения. Это делает целый путь дополнительным.

Таблица 5.8. Результат

+---------------------------------+
|name |mutualGroups|mutualFriends |
|---------------------------------|
|2 строки |
|---------------------------------|
| "Джилл" |1 |1 |
|------+------------+-------------|
| "Отвес" |1 |0 |
+---------------------------------+


5.9. Обнаружьте друзей основанными на подобном тегировании

Рисунок 5.7. График

cypher-peoplesimilaritytags-graph.svg


Обнаружить людей подобными мне основанный на taggings их favorited элементов,
один подход мог быть:

  * Определяют теги, связанные с какой я фаворит.
  *, Что еще тегировано с теми тегами?
  *, Кто элементы избранного тегированы с теми же самыми тегами?
  * Сортируют результат сколько из тех же самых вещей эти люди как.

Запрос.

СООТВЕТСТВИЕ
  (я) - [:favorite]-> (myFavorites) - [:tagged]-> (тег) <-[:tagged] - (theirFavorites) <-[:favorite] - (люди)
ГДЕ me.name = 'Джо' И НЕ me=people
ВОЗВРАТИТЕ people.name имя AS, количество (*) AS similar_favs
ПОРЯДОК similar_favs DESC

Запрос возвращает список возможных друзей, упорядоченных ими любящий подобный
материал, которые еще не являются друзьями.

Таблица 5.9. Результат

+-----------------------+
|name |similar_favs |
|-----------------------|
|2 строки |
|-----------------------|
| "Сара" |2 |
|---------+-------------|
| "Деррик" |1 |
+-----------------------+


5.10. Мультиреляционные (социальные) графики

Рисунок 5.8. График

cypher-multirelationalsocialnetwork-graph.svg


Этот пример показывает мультиреляционную сеть между людьми и вещами они
как. Мультиреляционный график - график с больше чем одним отчасти
отношение между вершинами.

Запрос.

СООТВЕТСТВИЕ (я {имя: 'Джо'}) - [r1:FOLLOWS |:LOVES]-> (другой) - [r2]-> (я)
ГДЕ тип (r1) =type (r2)
ВОЗВРАТИТЕ other.name, тип (r1)

Запрос возвращает людей, который СЛЕДУЕТ или ЛЮБИТ Джо назад.

Таблица 5.10. Результат

+---------------------+
|other.name |type (r1) |
|---------------------|
|3 строки |
|---------------------|
| "Сара" | "СЛЕДУЕТ" |
|-----------+---------|
| "Мария" | "СЛЕДУЕТ" |
|-----------+---------|
| "Мария" | "ЛЮБИТ" |
+---------------------+


5.11. Реализация новостных каналов в графике

cypher-newsfeed-graph.svg

Реализация новостного канала или функции временной шкалы - частое требование для
социальные приложения. Следующие экс-клены вдохновлены функцией Новостного канала
основанный Базой данных Графика Neo4j <http://techfin.in/2012/10/
newsfeed-feature-powered-by-neo4j-graph-database/>. Запрос, который спрашивают здесь:

Запускаясь во мне, получите упорядоченный временем канал состояния корректировок данных
меня и и все друзья, которые соединены через ПОДТВЕРЖДЕННОГО ДРУГА отношение
мне.

Запрос.

СООТВЕТСТВИЕ (я {имя: 'Джо'}) - [rels:FRIEND*0.. 1] - (myfriend)
ГДЕ ВСЕ (r В рэлах, ГДЕ r.status = 'ПОДТВЕРЖДЕННЫЙ')
С myfriend
СООТВЕТСТВИЕ (myfriend) - [:STATUS] - (latestupdate) - [:NEXT*0.. 1] - (statusupdates)
ВОЗВРАТИТЕ myfriend.name имя AS, statusupdates.date дата AS, statusupdates.text текст AS
ПОРЯДОК statusupdates.date DESC ОГРАНИЧИВАЕТ 3

Чтобы понять стратегию, пустите нам делить запрос на пять шагов:

 1. Сначала Получите список всех моих друзей (наряду со мной) через ДРУГА
    отношение (СООТВЕТСТВИЕ (я {имя: 'Джо'}) - [rels:FRIEND*0.. 1] - (myfriend)).
    Кроме того, ГДЕ предикат может быть прибавлен к проверке ли друг запрос
    находится на рассмотрении или подтвержден.
 2. Получите самую последнюю корректировку данных моих друзей через отношение Состояния
    (СООТВЕТСТВУЙТЕ myfriend-[:STATUS]-latestupdate).
 3. Получите последовательные корректировки данных (наряду с самым последним) моих друзей
    через отношения NEXT (СООТВЕТСТВИЕ (myfriend) - [:STATUS] - (latestupdate) -
    [:NEXT*0.. 1] - (statusupdates)), который даст Вам самое последнее и один
    дополнительный statusupdate; приспособьтесь 0.. 1 к любым костюмам Ваш случай.
 4. Сортируйте корректировки данных отправленной датой (ПОРЯДОК statusupdates.date DESC).
 5. ОГРАНИЧЬТЕ номер обновлений, в которых Вы нуждаетесь в каждом запросе (ОГРАНИЧЬТЕ 3).

Таблица 5.11. Результат

+--------------------------+
|name |date|text |
|--------------------------|
|3 строки |
|--------------------------|
| "Джо" |6 | "Джо status2" |
|-----+----+---------------|
| "Отвес" |4 | "отвесы status2" |
|-----+----+---------------|
| "Джо" |3 | "Джо status1" |
+--------------------------+


Здесь, пример показывает, как прибавить новую корректировку данных в существующие данные
для пользователя.

Запрос.

СООТВЕТСТВУЙТЕ (меня)
ГДЕ me.name =' Боб'
ДОПОЛНИТЕЛЬНЫЙ СООТВЕТСТВУЮТ (меня) - [r:STATUS] - (secondlatestupdate)
СОТРИТЕ r
СОЗДАЙТЕ (меня) - [:STATUS]-> (latest_update {текст:'Status', date:123})
С latest_update, соберите (secondlatestupdate) секунды AS
FOREACH (x В секундах | СОЗДАЮТ latest_update-[:NEXT]-> x)
ВОЗВРАТИТЕ latest_update.text AS new_status

Деля запрос на шаги, этот запрос напоминает добавляющийся новый элемент в середине
из двунаправленного связанного списка:

 1. Получите самое последнее обновление (если оно существует) пользователя через СОСТОЯНИЕ
    отношение (ДОПОЛНИТЕЛЬНЫЙ СООТВЕТСТВУЮТ (меня) - [r:STATUS] - (secondlatestupdate)).
 2. Сотрите отношение СОСТОЯНИЯ между пользователем и secondlatestupdate (если это
    существует), поскольку это стало бы вторым самым последним обновлением теперь и только
    самое последнее обновление было бы прибавлено через отношение СОСТОЯНИЯ; все ранее
    обновления были бы соединены с их последовательными обновлениями через NEXT
    отношение. (СОТРИТЕ r).
 3. Теперь, создайте новую statusupdate вершину (с текстом и датой как свойства)
    и соединитесь, это с пользователем через отношение СОСТОЯНИЯ (СОЗДАЙТЕ меня -
    [:STATUS]-> (latest_update {текст:'Status', date:123})).
 4. Передайте по каналу по statusupdate или пустому набору к следующей части запроса (С
    latest_update, соберите (secondlatestupdate) секунды AS).
 5. Теперь, создайте отношение NEXT между самой последней корректировкой данных и
    вторая самая последняя корректировка данных (если это существует) (FOREACH (x в секундах | СОЗДАЮТ
    latest_update-[:NEXT]-> x)).

Таблица 5.12. Результат

+------------------------+
|new_status |
|------------------------|
|1 строка |
|------------------------|
|Nodes создал: 1 |
|------------------------|
|Relationships создал: 2 |
|------------------------|
|Properties устанавливают: 2 |
|------------------------|
|Relationships стирал: 1 |
|------------------------|
| "Состояние" |
+------------------------+

cypher-insertstatusupdate-graph.svg

5.12. Усиление результатов рекомендации

Рисунок 5.9. График

cypher-boostingrecommendationresults-graph.svg


Этот запрос обнаруживает рекомендуемых друзей для источника, которые работают в
то же самое место как источник, или знают человека, которого источник знает, также,
источник не должен уже знать цель. Эта рекомендация взвешена для
вес отношения r2, и усиленный с фактором 2, если есть
свойство действия на том отношении

Запрос.

СООТВЕТСТВИЕ (источник) - [r1:KNOWS|WORKS_AT] - (c) - [r2:KNOWS|WORKS_AT] - (кандидат)
ГДЕ origin.name = "Кларк Кент" И тип (r1) =type (r2) И НЕ (источник) - [:KNOWS] - (кандидат)
ВОЗВРАТИТЕ origin.name источник AS, candidate.name кандидат AS, СУММА (ОКРУЖНОСТЬ (r2.weight
  + (ОБЪЕДИНИТЕ (r2.activity,
  0) * 2))) усиление AS
ПОРЯДОК усилением ПРЕДЕЛ DESC 10

Это возвращает рекомендуемых друзей для вершин источника и их
метка рекомендации.

Таблица 5.13. Результат

+------------------------------------+
|origin |candidate |boost |
|------------------------------------|
|2 строки |
|------------------------------------|
| "Кларк Кент" | "Перри Вайт" |22 |
|------------+-----------------+-----|
| "Кларк Кент" | "Андерсон Купер" |4 |
+------------------------------------+


5.13. Вычисление кластеризирующегося коэффициента сети

Рисунок 5.10. График

cypher-clusteringcoefficient-graph.svg


В этом примере, адаптированном от сообщения в блоге Нико Гэмулинса на Neo4j для Социального
Сетевой Анализ <http://mypetprojects.blogspot.se/2012/06/
social-network-analysis-with-neo4j.html>, рассматриваемый график показывает
Отношения с 2 транзитными участками демонстрационного человека как вершины со ЗНАЮТ отношения.

Кластеризирующийся коэффициент <http://en.wikipedia.org/wiki/
Clustering_coefficient> выбранной вершины определен как вероятность это
два в произвольном порядке выбранных соседа соединены друг с другом. С номером
соседи как n и номер взаимных соединений между соседями r
вычисление:

Номер возможных соединений между двумя соседями - n! / (2! (n-2)!) = 4! /
(2! (4-2)!) = 24/4 = 6, где n - номер соседей n = 4 и фактическое
r номера соединений 1. Поэтому кластеризирующийся коэффициент вершины 1
1/6.

n и r довольно просты получить через следующий запрос:

Запрос.

СООТВЕТСТВИЕ ({имя: "startnode"}) - (b)
С a, количество (ЯВНЫЙ b) AS n
СООТВЕТСТВИЕ (a) - () - [r] - () - (a)
ВОЗВРАТИТЕ n, количество (ЯВНЫЙ r) AS r

Это возвращает n и r для вышеупомянутых вычислений.

Таблица 5.14. Результат

+-----+
|n |r |
|-----|
|1 строка |
|-----|
|4 |1 |
+-----+


5.14. Симпатичные графики

5.14.1. Звездообразный график
5.14.2. График колеса
5.14.3. Полный график
5.14.4. График дружбы

Этот раздел показывает, как создать некоторые из именованных симпатичных графиков на
Википедия <http://en.wikipedia.org/wiki/Gallery_of_named_graphs>.

5.14.1. Звездообразный график

График создается первым созданием центральной вершины, и затем однажды на элемент
в диапазоне, создает листовую вершину и соединяет это с центром.

Запрос.

СОЗДАЙТЕ (центрируются)
FOREACH (x В диапазоне (1,6) | СОЗДАЮТ (лист), (центр) - [:X]-> (лист)),
ВОЗВРАТИТЕ идентификатор (центр) идентификатор AS;

Запрос возвращает идентификатор центральной вершины.

Таблица 5.15. Результат

+------------------------+
|id |
|------------------------|
|1 строка |
|------------------------|
|Nodes создал: 7 |
|------------------------|
|Relationships создал: 6 |
|------------------------|
|7 |
+------------------------+


Рисунок 5.11. График

cypher-prettygraphsstar-graph.svg


5.14.2. График колеса

Этот график создается во многих шагах:

  * Создают центральную вершину.
  * Однажды на элемент в диапазоне, создайте лист и соедините это с центром.
  * Соединяют соседние листы.
  * Новое месторождение минимальный и максимальный лист и соединяют их.
  * Возврат идентификатор центральной вершины.

Запрос.

СОЗДАЙТЕ (центрируются)
FOREACH (x В диапазоне (1,6) | СОЗДАЮТ (лист {count:x}), (центр) - [:X]-> (лист)),
С центром
СООТВЕТСТВИЕ (large_leaf) <-(центр)-> (small_leaf)
ГДЕ large_leaf.count = small_leaf.count + 1
СОЗДАЙТЕ (small_leaf) - [:X]-> (large_leaf)
С центром, минута (small_leaf.count) минута AS, максимальный (large_leaf.count) максимальный AS
СООТВЕТСТВИЕ (first_leaf) <-(центр)-> (last_leaf)
ГДЕ first_leaf.count = минута И last_leaf.count = максимальный
СОЗДАЙТЕ (last_leaf) - [:X]-> (first_leaf)
ВОЗВРАТИТЕ идентификатор (центр) идентификатор AS

Запрос возвращает идентификатор центральной вершины.

Таблица 5.16. Результат

+-------------------------+
|id |
|-------------------------|
|1 строка |
|-------------------------|
|Nodes создал: 7 |
|-------------------------|
|Relationships создал: 12 |
|-------------------------|
|Properties устанавливают: 6 |
|-------------------------|
|7 |
+-------------------------+


Рисунок 5.12. График

cypher-prettygraphswheel-graph.svg


5.14.3. Полный график

Для этого графика корневой узел создается, и используется, чтобы подвесить много вершин
от. Затем, две вершины выбраны, зависая от центра, с
требование, чтобы идентификатор первого был меньше чем идентификатор следующего. Это
предотвратить двойные отношения и сам отношения. Используя сказанное соответствие,
отношения между всеми этими вершинами создаются. Наконец, центральная вершина и
удалены все отношения, соединенные с этим.

Запрос.

СОЗДАЙТЕ (центрируются)
FOREACH (x В диапазоне (1,6) | СОЗДАЮТ (лист {количество: x}), (центр) - [:X]-> (лист))
С центром
СООТВЕТСТВИЕ (leaf1) <-(центр)-> (leaf2)
ГДЕ идентификатор (leaf1) <идентификатор (leaf2)
СОЗДАЙТЕ (leaf1) - [:X]-> (leaf2)
С центром
СООТВЕТСТВИЕ (центр) - [r]-> ()
СОТРИТЕ центр, r;

Ничто не возвращено этим запросом.

Таблица 5.17. Результат

+-------------------------+
|Nodes создал: 7 |
|-------------------------|
|Relationships создал: 21 |
|-------------------------|
|Properties устанавливают: 6 |
|-------------------------|
|Nodes стирал: 1 |
|-------------------------|
|Relationships стирал: 6 |
|-------------------------|
| (освободите результат), |
+-------------------------+


Рисунок 5.13. График

cypher-prettygraphscompletegraph-graph.svg


5.14.4. График дружбы

Этот запрос сначала создает центральную вершину, и затем однажды на элемент в диапазоне,
создает график цикла и соединяет это с центром

Запрос.

СОЗДАЙТЕ (центрируются)
FOREACH (x В диапазоне (1,3) | СОЗДАЮТ (leaf1), (leaf2), (центр) - [:X]-> (leaf1), (центр) - [:X]-> (leaf2),
  (leaf1) - [:X]-> (leaf2))
ВОЗВРАТИТЕ ID (центр) идентификатор AS

Идентификатор центральной вершины возвращен запросом.

Таблица 5.18. Результат

+------------------------+
|id |
|------------------------|
|1 строка |
|------------------------|
|Nodes создал: 7 |
|------------------------|
|Relationships создал: 9 |
|------------------------|
|7 |
+------------------------+


Рисунок 5.14. График

cypher-prettygraphsfriendshipgraph-graph.svg


5.15. Многоуровневое строение индексации (дерево пути)

5.15.1. Возвратите нулевой диапазон
5.15.2. Возвратите полный спектр
5.15.3. Возврат частично совместно использовал диапазоны пути

В этом примере многоуровневая древовидная структура используется, чтобы индексировать вершины события
(здесь Event1, Event2 и Event3, в этом случае со "ДНЕМ МЕСЯЦА ГОДА"
гранулярность, делая это строение индексации временной шкалы. Однако, этот подход
должен работать на широкий диапазон многоуровневых диапазонов.

Строение следует за несколькими правилами:

  * События могут быть индексированы многократно, соединяя строение индексации
    листы с событиями через отношение ЗНАЧЕНИЯ.
  * запросы сделаны способом диапазона пути. Таким образом, запуск - и конец
    путь от корня индексации до запуска и листов конца в дереве
    расчетный
  * Используя Код, запросы после различных стратегий могут быть выражены
    как разделы пути и соединенный использование одного единственного запроса.

График ниже изображает строение с 3 Событиями, бывшими присоединенными к индексированию
строение в различных листах.

Рисунок 5.15. График

cypher-pathtree-layout-path.svg


5.15.1. Возвратите нулевой диапазон

Здесь, только события, индексированные под одним листом (2010-12-31), возвращены.
запросите только потребности один сегмент пути rootPath (покрасьте Грина) посредством индексирования.

Рисунок 5.16. График

cypher-pathtree-layout-zero-range.svg


Запрос.

СООТВЕТСТВУЙТЕ rootPath = (корень) - [: `2010`]-> () - [: `12`]-> () - [: `31`]-> (лист), (лист) - [:VALUE]-> (событие)
ГДЕ root.name = 'Корень'
ВОЗВРАТИТЕ event.name
ПОРЯДОК event.name ASC

Возврат всех событий в день 31.12.2010, в этом случае Event1 и Event2

Таблица 5.19. Результат

+----------+
|event.name |
|----------|
|2 строки |
|----------|
| "Event1" |
|----------|
| "Event2" |
+----------+


5.15.2. Возвратите полный спектр

В этом случае, диапазон идет сначала в последний лист индексировать дерева.
Здесь, startPath (красят Greenyellow) и endPath (красят Грина) перекрывают
диапазон, valuePath (красят Синим) тогда соединяет листы, и значения могут
будьте считаны из средней вершины, зависающий от значений (покрасьте Красный цвет), путь.

Рисунок 5.17. График

cypher-pathtree-layout-full-range-path.svg


Запрос.

СООТВЕТСТВУЙТЕ startPath = (корень) - [: `2010`]-> () - [: `12`]-> () - [: `31`]-> (startLeaf),
  endPath = (корень) - [: `2011`]-> () - [: `01`]-> () - [: `03`]-> (endLeaf),
  valuePath = (startLeaf) - [:NEXT*0..]-> (середина) - [:NEXT*0..]-> (endLeaf),
  vals = (середина) - [:VALUE]-> (событие)
ГДЕ root.name = 'Корень'
ВОЗВРАТИТЕ event.name
ПОРЯДОК event.name ASC

Возврат всех событий между 31.12.2010 и 03.01.2011, в этом случае все
события.

Таблица 5.20. Результат

+----------+
|event.name |
|----------|
|4 строки |
|----------|
| "Event1" |
|----------|
| "Event2" |
|----------|
| "Event2" |
|----------|
| "Event3" |
+----------+


5.15.3. Возврат частично совместно использовал диапазоны пути

Здесь, диапазон запроса следует частично совместно используемыми путями, запрашивая индексирование,
представление и общий сегмент пути commonPath (красят Сажу),
необходимый, прежде, чем перекрыть startPath (красят Greenyellow) и endPath (цвет
Darkgreen). После того, как это, valuePath (красят Синим) соединяет листы и
индексированные значения возвращены от значений (покрасьте Красный цвет), путь.

Рисунок 5.18. График

cypher-pathtree-layout-shared-root-path.svg


Запрос.

СООТВЕТСТВУЙТЕ commonPath = (корень) - [: `2011`]-> () - [: `01`]-> (commonRootEnd),
  startPath = (commonRootEnd) - [: `01`]-> (startLeaf), endPath = (commonRootEnd) - [: `03`]-> (endLeaf),
  valuePath = (startLeaf) - [:NEXT*0..]-> (середина) - [:NEXT*0..]-> (endLeaf),
  vals = (середина) - [:VALUE]-> (событие)
ГДЕ root.name = 'Корень'
ВОЗВРАТИТЕ event.name
ПОРЯДОК event.name ASC

Возврат всех событий между 01.01.2011 и 03.01.2011, в этом случае Event2 и
Event3.

Таблица 5.21. Результат

+----------+
|event.name |
|----------|
|2 строки |
|----------|
| "Event2" |
|----------|
| "Event3" |
+----------+


5.16. Комплексные вычисления подобия

5.16.1. Вычислите общие черты комплексными вычислениями

5.16.1. Вычислите общие черты комплексными вычислениями

Здесь, подобие между двумя проигрывателями в игре вычислено номером
времена они съели ту же самую еду.

Запрос.

СООТВЕТСТВИЕ (я {имя: 'я'}) - [r1:ATE]-> (еда) <-[r2:ATE] - (Вы)
СО мной, количество (ЯВНЫЙ r1) AS H1, количество (ЯВНЫЙ r2) AS H2, Вы
СООТВЕТСТВУЙТЕ (меня) - [r1:ATE]-> (еда) <-[r2:ATE] - (Вы)
ВОЗВРАТИТЕ сумму ((1 ABS (r1.times/H1-r2.times/H2)) * (r1.times+r2.times) / (H1+H2)) подобие AS

Эти два проигрывателя и их мера по подобию.

Таблица 5.22. Результат

+----------+
|similarity |
|----------|
|1 строка |
|----------|
|-30.0 |
+----------+


Рисунок 5.19. График

cypher-complexsimilarity-graph.svg


5.17. Потоковая модель действия Graphity

5.17.1. Потоки Действия нового месторождения в сети, не масштабируя штраф

5.17.1. Потоки Действия нового месторождения в сети, не масштабируя штраф

Это - подход для того, чтобы масштабировать извлечение потоков действия в друге
график, выдвинутый Рене Пикардом как Graphity <http://www.rene-pickhardt.de/
graphity-an-efficient-graph-model-for-retrieving-the-top-k-news-feeds-for-users-in-social-networks
/>. Короче говоря, связанный список создается для каждого друзья людей в порядке
то, что последние действия этих друзей произошли. Когда новые действия
происходите для друга, все упорядоченные списки друзей, из которых этот друг является частью
переупорядочены, передавая вычисляющий загрузку во время новых обновлений события
вместо потоковых чтений действия.

Подсказка

Этот подход, конечно, делает злоупотребление типами отношения. Это нуждается
быть учтенным, разрабатывая производственную систему с этим
подход. См. Раздел 15.5, "Емкость" для максимального числа отношения
типы.

Чтобы обнаружить поток действия для человека, только следуйте за связанным списком
список друзей, и получает необходимое количество формы действий соответствующее
список действия друзей.

Запрос.

СООТВЕТСТВУЙТЕ p = (меня {имя: 'Джейн'}) - [:jane_knows *]-> (друг), (друг) - [:has]-> (состояние)
ВОЗВРАТИТЕ me.name, friend.name, status.name, длина (p)
ПОРЯДОК длиной (p)

Возвраты поток действия для Джейн.

Таблица 5.23. Результат

+-----------------------------------------+
|me.name|friend.name|status.name|length (p) |
|-----------------------------------------|
|3 строки |
|-----------------------------------------|
| "Джейн" | "Билл" | "Bill_s1" |1 |
|-------+-----------+-----------+---------|
| "Джейн" | "Джо" | "Joe_s1" |2 |
|-------+-----------+-----------+---------|
| "Джейн" | "Отвес" | "Bob_s1" |3 |
+-----------------------------------------+


Рисунок 5.20. График

cypher-graphity-graph.svg


5.18. Пользовательские роли в графиках

5.18.1. Получите администраторов
5.18.2. Получите составы группы пользователя
5.18.3. Получите все группы
5.18.4. Получите все элементы всех групп

Это - пример, показывая иерархию ролей. То, что интересно, является этим a
дерево не достаточно для того, чтобы сохранить этот вид строения, как разработано ниже.

roles.png

Это - реализация примера, найденного в статье Модель к
Представьте Направленные Нециклические Графики (ГРАФИТОВАЯ ПЫЛЬ) на Базах данных SQL <http://
www.codeproject.com/Articles/22824/
A-Model-to-Represent-Directed-Acyclic-Graphs-DAG-o> Кемалем Эрдоганом <http://
www.codeproject.com/script/Articles/MemberArticles.aspx?amid=274518>.
статья обсуждает, как сохранить направленные нециклические графики <http://en.wikipedia.org
/wiki/Directed_acyclic_graph> (ГРАФИТОВАЯ ПЫЛЬ) в SQL базировал DB. ГРАФИТОВАЯ ПЫЛЬ - почти деревья,
но со скручиванием: может быть возможно достигнуть той же самой вершины через различный
пути. Деревья ограничены от этой возможности, которая делает их намного легче
обработать. В нашем случае это - "Али" и “Engin”, поскольку они - оба администраторы и
пользователи и таким образом достижимый через эти групповые вершины. Действительность часто смотрит это
путь и не может быть получен древовидными структурами.

В статье обеспечено решение для Хранимой процедуры SQL. Основная идея,
у этого также есть некоторая поддержка от ученых, должен предварительно вычислить всех возможных
(переходные) пути. За и против этого подхода:

  * приличная производительность на чтении
  * низкая производительность на вставке
  * тратит впустую много пространства
  * полагается на хранимые процедуры

В Neo4j, хранящем роли, тривиально. В этом случае мы используем PART_OF (зелень
края) отношения, чтобы смоделировать групповую иерархию и MEMBER_OF (синие края) к
членство в модели в группах. Мы также соединяем высокоуровневые группы с
ссылочная вершина КОРНЕВЫМИ отношениями. Это дает нам полезное разделение
график. У Neo4j нет никаких предопределенных типов отношения, Вы свободны создать
любые типы отношения и дают им семантику, которую Вы хотите.

Пускает теперь взглянули на то, как получить информацию от графика.
запросы сделаны, используя Код, код Java использует API Обхода Neo4j
(см. Раздел 33.2, “API Java Платформы Обхода”, который является частью Части VIII,
“Усовершенствованное Использование”).

5.18.1. Получите администраторов

В Коде мы могли получить администраторов как это:

СООТВЕТСТВИЕ ({имя: 'Администраторы'}) <-[:PART_OF*0..] - (группа) <-[:MEMBER_OF] - (пользователь)
ВОЗВРАТИТЕ user.name, group.name

следование:

+---------------------+
|user.name|group.name |
|---------------------|
|3 строки |
|---------------------|
| "Demet" | "Справочная служба" |
|---------+-----------|
| "Али" | "Администраторы" |
|---------+-----------|
| "Engin" | "Справочная служба" |
+---------------------+

И вот код при использовании API Обхода Java:

Администраторы вершины = getNodeByName ("Администраторы");
TraversalDescription traversalDescription = db.traversalDescription ()
        .breadthFirst ()
        .evaluator (Evaluators.excludeStartPosition)
        .relationships (RoleRels. PART_OF, Направление. ПОСТУПЛЕНИЕ)
        .relationships (RoleRels. MEMBER_OF, Направление. ПОСТУПЛЕНИЕ);
Траверса траверсы = traversalDescription.traverse (администраторы);

следование выводом

Найденный: HelpDesk в глубине: 0
Найденный: Али в глубине: 0
Найденный: Engin в глубине: 1
Найденный: Demet в глубине: 1

Результат собран у траверсы, используя этот код:

Строковый вывод ="";
для (Путь пути: траверса)
{
    Вершина вершины = path.endNode ();
    вывод + = "Найденный:" + node.getProperty (ИМЯ) + "в глубине:"
              + (path.length () - 1) + "\n";
}

5.18.2. Получите составы группы пользователя

В Коде:

СООТВЕТСТВИЕ ({имя: 'Jale'}) - [:MEMBER_OF]-> () - [:PART_OF*0..]-> (группа)
ВОЗВРАТИТЕ group.name

+----------------+
|group.name |
|----------------|
|3 строки |
|----------------|
| "ABCTechnicians" |
|----------------|
| "Технический персонал" |
|----------------|
| "Пользователи" |
+----------------+

Используя API Обхода Java Neo4j, этот запрос похож:

Вершина jale = getNodeByName ("Jale");
traversalDescription = db.traversalDescription ()
        .depthFirst ()
        .evaluator (Evaluators.excludeStartPosition)
        .relationships (RoleRels. MEMBER_OF, Направление. ВЫХОД)
        .relationships (RoleRels. PART_OF, Направление. ВЫХОД);
траверса = traversalDescription.traverse (jale);

следование:

Найденный: ABCTechnicians в глубине: 0
Найденный: Технический персонал в глубине: 1
Найденный: Пользователи в глубине: 2

5.18.3. Получите все группы

В Коде:

СООТВЕТСТВИЕ ({имя: 'Reference_Node'}) <-[:ROOT]-> () <-[:PART_OF*0..] - (группа)
ВОЗВРАТИТЕ group.name

+----------------+
|group.name |
|----------------|
|6 строк |
|----------------|
| "Пользователи" |
|----------------|
| "ABCTechnicians" |
|----------------|
| "Менеджеры" |
|----------------|
| "Справочная служба" |
|----------------|
| "Технический персонал" |
|----------------|
| "Администраторы" |
+----------------+

В Java:

Вершина referenceNode = getNodeByName ("Reference_Node");
traversalDescription = db.traversalDescription ()
        .breadthFirst ()
        .evaluator (Evaluators.excludeStartPosition)
        .relationships (RoleRels. КОРЕНЬ, Направление. ПОСТУПЛЕНИЕ)
        .relationships (RoleRels. PART_OF, Направление. ПОСТУПЛЕНИЕ);
траверса = traversalDescription.traverse (referenceNode);

следование:

Найденный: Администраторы в глубине: 0
Найденный: Пользователи в глубине: 0
Найденный: HelpDesk в глубине: 1
Найденный: менеджеры в глубине: 1
Найденный: Технический персонал в глубине: 1
Найденный: ABCTechnicians в глубине: 2

5.18.4. Получите все элементы всех групп

Теперь, пустите нам пытаться обнаружить всех пользователей в системе, являющейся частью любой группы.

В Коде это похоже:

СООТВЕТСТВИЕ ({имя: 'Reference_Node'}) <-[:ROOT]-> (корень), p = (корень) <-[PART_OF*0..] - () <-[:MEMBER_OF] - (пользователь)
ВОЗВРАТИТЕ user.name, минута (длина (p))
ПОРЯДОК К минуте (длина (p)), user.name

и результаты в следующем выводе:

+-------------------------+
|user.name|min (длина (p)) |
|-------------------------|
|10 строк |
|-------------------------|
| "Али" |1 |
|---------+---------------|
| "Burcu" |1 |
|---------+---------------|
| "Может" |1 |
|---------+---------------|
| "Engin" |1 |
|---------+---------------|
| "Demet" |2 |
|---------+---------------|
| "Fuat" |2 |
|---------+---------------|
| "Гюль" |2 |
|---------+---------------|
| "Хакан" |2 |
|---------+---------------|
| "Irmak" |2 |
|---------+---------------|
| "Jale" |3 |
+-------------------------+

в Java:

traversalDescription = db.traversalDescription ()
        .breadthFirst ()
        .evaluator (
                Evaluators.includeWhereLastRelationshipTypeIs (RoleRels. MEMBER_OF));
траверса = traversalDescription.traverse (referenceNode);

Найденный: Али в глубине: 1
Найденный: Engin в глубине: 1
Найденный: Burcu в глубине: 1
Найденный: Может в глубине: 1
Найденный: Demet в глубине: 2
Найденный: Гюль в глубине: 2
Найденный: Fuat в глубине: 2
Найденный: Хакан в глубине: 2
Найденный: Irmak в глубине: 2
Найденный: Jale в глубине: 3

Как замечено выше, запрашивая еще более комплексные сценарии может быть сделан, используя
сравнительно краткость создает в Коде или Java.

Глава 6. Языки

Пожалуйста, см. http://www.neo4j.org/drivers <http://www.neo4j.org/drivers> для
текущий набор драйверов!

Есть включенный пример Java, который показывает подход "низкого уровня" к использованию
API REST Neo4j от Java.

6.1. Как использовать остальных API от Java

6.1.1. Создание графика через остальных API от Java
6.1.2. Запустите сервер
6.1.3. Создание вершины
6.1.4. Добавление свойств
6.1.5. Добавление отношений
6.1.6. Прибавьте свойства к отношению
6.1.7. Запросы графиков
6.1.8. Уф, то, что это?
6.1.9. Что является следующим?
6.1.10. Приложение: код

6.1.1. Создание графика через остальных API от Java

ОСТАЛЬНЫЕ API использует HTTP и ДЖСОНА, так, чтобы это могло использоваться со многих языков и
платформы. Однако, когда geting запускался, полезно видеть некоторые модели, которые могут
быть повторно использованным. В этом кратком обзоре мы покажем Вам, как создать и манипулировать
простой график через остальных API и также как запросить это.

Для этих примеров мы выбрали Джерси <http://jersey.java.net/> клиент
компоненты, которые легко загружены <http://jersey.java.net/nonav/
documentation/latest/user-guide.html#chapter_deps> через Знатока.

6.1.2. Запустите сервер

Прежде, чем мы сможем выполнить любые действия на сервере, мы должны запустить его согласно
Раздел 21.2, “Установка Сервера”.

Ресурс WebResource = Client.create ()
        .resource (SERVER_ROOT_URI);
Реакция ClientResponse = resource.get (ClientResponse.class);

System.out.println (String.format ("Преуспевают [%s], код состояния [%d]",
        SERVER_ROOT_URI, response.getStatus ()));
response.close ();

Если состояние реакции - 200 OK, то мы знаем, что сервер работает
мелкие частицы и мы можем продолжать. Если код перестал работать к conenct к серверу, то
пожалуйста, взгляните на Часть V, "Операции".

Замечание

Если Вы получаете какую-либо другую реакцию чем 200 OK (особенно 4xx или 5xx реакции)
тогда, пожалуйста, проверьте свою конфигурацию и взгляд в файлах системного журнала в данных/журнале
каталог.

6.1.3. Создание вершины

ОСТАЛЬНОЕ API использует POST, чтобы создать вершины. Инкапсуляция этого в Java
прямое использование клиента Джерси:

конечная Строка nodeEntryPointUri = SERVER_ROOT_URI + "вершина";
//http://localhost:7474/db/data/node

Ресурс WebResource = Client.create ()
        .resource (nodeEntryPointUri);
//POST {} к URI точки входа вершины
Реакция ClientResponse = resource.accept (MediaType. АППЛИКЭЙШН_ДЖСОН)
        .type (MediaType. АППЛИКЭЙШН_ДЖСОН)
        .entity ("{}")
        .post (ClientResponse.class);

конечное расположение URI = response.getLocation ();
System.out.println (String.format (
        "POST к [%s], код состояния [%d], головная часть расположения [%s]",
        nodeEntryPointUri, response.getStatus (), location.toString ()));
response.close ();

возвратите расположение;

Если вызов завершается успешно, под покрытиями он отправит HTTP
запрос, содержащий полезную нагрузку ДЖСОНА к серверу. Сервер будет тогда иметь
создаваемый новая вершина в базе данных и отвеченный 201 Создаваемая реакция
и головная часть Расположения с URI недавно создаваемой вершины.

В нашем примере мы вызываем эту функциональность дважды, чтобы создать две вершины в нашем
база данных.

6.1.4. Добавление свойств

Как только у нас есть вершины в нашем datatabase, мы можем использовать их, чтобы хранить полезные данные. В
этот случай, мы собираемся хранить информацию о музыке в нашей базе данных. Пустите нам
запустите, смотря на код, который мы используем, чтобы создать вершины и прибавить свойства.
Здесь мы прибавили вершины, чтобы представить "Джо Страммера" и полосу, вызванную"
Столкновение".

URI firstNode = createNode ();
addProperty (firstNode, "имя", "Джо Страммер");
URI secondNode = createNode ();
addProperty (secondNode, "полоса", "Столкновение");

В addProperty методе мы определяем ресурс, который представляет
свойства для вершины и выбирают имя для того свойства. Мы тогда продолжаем
ПОМЕЩАТЬ значение того свойства к серверу.

Представьте propertyUri в виде строки = nodeUri.toString () + "/свойства /" + propertyName;
//http://localhost:7474/db/data/node/ {node_id} / свойства / {property_name}

Ресурс WebResource = Client.create ()
        .resource (propertyUri);
Реакция ClientResponse = resource.accept (MediaType. АППЛИКЭЙШН_ДЖСОН)
        .type (MediaType. АППЛИКЭЙШН_ДЖСОН)
        .entity ("\"" + propertyValue + "\"")
        .put (ClientResponse.class);

System.out.println (String.format ("ПОМЕЩЕННЫЙ в [%s], код состояния [%d]",
        propertyUri, response.getStatus ()));
response.close ();

Если все будет подходить, то мы не получим 204 Контента, назад указывающие что
сервер обработал запрос, но не реагировал на значение свойства.

6.1.5. Добавление отношений

Теперь, когда у нас есть вершины, чтобы представить Джо Страммера и Столкновение, мы можем иметь отношение
их. ОСТАЛЬНОЕ API поддерживает это через POST отношения
представление вершине запуска отношения. Соответственно в Java
мы POST некоторый ДЖСОН к URI нашей вершины, которая представляет Джо Страммера, к
установите отношение между той вершиной и вершиной, представляющей Столкновение.

URI relationshipUri = addRelationship (firstNode, secondNode, "певец",
        " {\"от \": \"1976 \", \"до \": \"1986 \"}");

В addRelationship методе мы определяем URI Джо Страммера
отношения вершины, и затем POST описание ДЖСОНА нашего намеченного
отношение. Это описание содержит целевую вершину, метку для
тип отношения, и любые атрибуты для соотношения как набор ДЖСОНА.

частный статический URI addRelationship (URI startNode, URI endNode,
        Представьте relationshipType в виде строки, Строка jsonAttributes),
        броски URISyntaxException
{
    URI fromUri = новый URI (startNode.toString () + "/отношения");
    Представьте relationshipJson в виде строки = generateJsonRelationship (endNode,
            relationshipType, jsonAttributes);

    Ресурс WebResource = Client.create ()
            .resource (fromUri);
    //POST ДЖСОН к URI отношений
    Реакция ClientResponse = resource.accept (MediaType. АППЛИКЭЙШН_ДЖСОН)
            .type (MediaType. АППЛИКЭЙШН_ДЖСОН)
            .entity (relationshipJson)
            .post (ClientResponse.class);

    конечное расположение URI = response.getLocation ();
    System.out.println (String.format (
            "POST к [%s], код состояния [%d], головная часть расположения [%s]",
            fromUri, response.getStatus (), location.toString ()));

    response.close ();
    возвратите расположение;
}

Если все подходит, мы получаем 201 Создаваемый код состояния и головную часть Расположения
который содержит URI недавно создаваемого соотношения.

6.1.6. Прибавьте свойства к отношению

Как вершины, у отношений могут быть свойства. Так как мы - большие поклонники обоих Джо
Страммер и Столкновение, мы прибавим оценку к отношению так, чтобы другие
может видеть, что он - 5-звездочный певец с полосой.

addMetadataToProperty (relationshipUri, "звезды", "5");

В addMetadataToProperty методе мы определяем URI свойств
из отношения и ПОМЕЩЕННЫЙ наши новые значения (так как это ПОМЕСТИЛО это, всегда будет
перезапишите существующие значения, так будьте осторожны).

частная статическая пустота addMetadataToProperty (URI relationshipUri,
        Имя строки, Строковое значение), бросает URISyntaxException
{
    URI propertyUri = новый URI (relationshipUri.toString () + "/свойства");
    Строковый объект = toJsonNameValuePairCollection (имя, значение);
    Ресурс WebResource = Client.create ()
            .resource (propertyUri);
    Реакция ClientResponse = resource.accept (MediaType. АППЛИКЭЙШН_ДЖСОН)
            .type (MediaType. АППЛИКЭЙШН_ДЖСОН)
            .entity (объект)
            .put (ClientResponse.class);

    System.out.println (String.format (
            "ПОМЕЩЕННЫЙ [%s] в [%s], код состояния [%d]", объект, propertyUri,
            response.getStatus ()));
    response.close ();
}


Принятие всего подходит, мы вернем 204 реакции OK от сервера (который
мы можем проверить вызов ClientResponse.getStatus ()), и мы теперь установили a
очень малый график, который мы можем запросить.

6.1.7. Запросы графиков

Как со встроенной версией базы данных, сервер Neo4j использует график
обходы, чтобы искать данные в графиках. В настоящий момент сервер Neo4j ожидает a
Полезная нагрузка ДЖСОНА, описывающая обход, который будет ОТПРАВЛЕН в запускающейся вершине для
обход (хотя это, вероятно, изменится вовремя на ПОЛУЧЕНИЕ на основе
подход).

Чтобы запустить этот процесс, мы используем простой класс, который может повернуть себя в
эквивалентный ДЖСОН, готовый к РЕГИСТРАЦИИ на сервер, и в этом случае, мы имеем
hardcoded траверса, чтобы искать все вершины с исходящими отношениями с
тип "певец".

//TraversalDefinition превращается в ДЖСОНА, чтобы передаться к Серверу
TraversalDefinition t = новый TraversalDefinition ();
t.setOrder (TraversalDefinition. DEPTH_FIRST);
t.setUniqueness (TraversalDefinition. ВЕРШИНА);
t.setMaxDepth (10);
t.setReturnFilter (TraversalDefinition. ВСЕ);
t.setRelationships (новое Соотношение ("певец", Соотношение.));

Как только мы определили параметры нашего обхода, мы только должны передать
это. Мы делаем это, определяя URI траверс для вершины запуска, и
тогда ОТПРАВЛЯЯ представление ДЖСОНА траверсы к этому.

URI traverserUri = новый URI (startNode.toString () + "/traverse/node");
Ресурс WebResource = Client.create ()
        .resource (traverserUri);
Представьте jsonTraverserPayload в виде строки = t.toJson ();
Реакция ClientResponse = resource.accept (MediaType. АППЛИКЭЙШН_ДЖСОН)
        .type (MediaType. АППЛИКЭЙШН_ДЖСОН)
        .entity (jsonTraverserPayload)
        .post (ClientResponse.class);

System.out.println (String.format (
        "POST [%s] к [%s], код состояния [%d], возвратил данные:"
                + System.getProperty ("line.separator") + "%s",
        jsonTraverserPayload, traverserUri, response.getStatus (),
        response.getEntity (String.class)));
response.close ();

Как только тот запрос завершился, мы возвращаем наш набор данных певцов и
полосы они принадлежат:

[{
  "outgoing_relationships": "http://localhost:7474/db/data/node/82/relationships/out",
  "данные": {
    "полоса": "Столкновение",
    "имя": "Джо Страммер"
  },
  "траверз": "http://localhost:7474/db/data/node/82/traverse/ {returnType}",
  "all_typed_relationships": "http://localhost:7474/db/data/node/82/relationships/all/ {-list|&|types}",
  "свойство": "http://localhost:7474/db/data/node/82/properties/ {ключ}",
  "all_relationships": "http://localhost:7474/db/data/node/82/relationships/all",
  "сам": "http://localhost:7474/db/data/node/82",
  "свойства": "http://localhost:7474/db/data/node/82/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/82/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/82/relationships/in",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/82/relationships/in/ {-list|&|types}",
  "create_relationship": "http://localhost:7474/db/data/node/82/relationships"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/83/relationships/out",
  "данные": {
  },
  "траверз": "http://localhost:7474/db/data/node/83/traverse/ {returnType}",
  "all_typed_relationships": "http://localhost:7474/db/data/node/83/relationships/all/ {-list|&|types}",
  "свойство": "http://localhost:7474/db/data/node/83/properties/ {ключ}",
  "all_relationships": "http://localhost:7474/db/data/node/83/relationships/all",
  "сам": "http://localhost:7474/db/data/node/83",
  "свойства": "http://localhost:7474/db/data/node/83/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/83/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/83/relationships/in",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/83/relationships/in/ {-list|&|types}",
  "create_relationship": "http://localhost:7474/db/data/node/83/relationships"
} ]

6.1.8. Уф, то, что это?

Это - разновидность того, что мы можем сделать с остальными API. Естественно любой HTTP
идиомы, которые мы обеспечиваем на сервере, могут быть легко обернуты, включая передвижение вершин
и отношения через СТИРАЮТ. Все еще, если Вы добрались настолько далеко, тогда
переключение.post () для.delete () в клиентском коде Джерси должно быть
прямой.

6.1.9. Что является следующим?

API HTTP предоставляет хорошее основание разработчикам клиентских библиотек, это
также большой для HTTP и людей REST. В будущем, хотя мы ожидаем это
идиоматические привязки к языку, будет казаться, будут обманывать остальных API в то время как
обеспечение удобных конструкций на уровне языка для разработчиков, чтобы использовать, очень как
есть подобная привязка для встроенной базы данных.

6.1.10. Приложение: код

  * CreateSimpleGraph.java <https://github.com/neo4j/neo4j/blob/2.0.0/community
    /server-examples/src/main/java/org/neo4j/examples/server/
    CreateSimpleGraph.java>
  * Relation.java <https://github.com/neo4j/neo4j/blob/2.0.0/community/
    server-examples/src/main/java/org/neo4j/examples/server/Relation.java>
  * TraversalDefinition.java <https://github.com/neo4j/neo4j/blob/2.0.0/
    community/server-examples/src/main/java/org/neo4j/examples/server/
    TraversalDefinition.java>

Часть III. Язык Запроса кода

Часть Кода - авторитетный источник для деталей относительно Запроса Кода
Язык. Для введения, см. Раздел 7.1, “Каков Код?”.

Оглавление

7. Введение

    7.1. Каков Код?
    7.2. Обновление графика
    7.3. Транзакции
    7.4. Уникальность
    7.5. Параметры
    7.6. Совместимость
    7.7. Производительность запроса

8. Синтаксис

    8.1. Операторы
    8.2. Выражения
    8.3. Идентификаторы
    8.4. Комментарии
    8.5. Модели
    8.6. Наборы
    8.7. Работа с НУЛЕМ

9. Общие оговорки

    9.1. Возвратиться
    9.2. Порядок
    9.3. Предел
    9.4. Пропустить
    9.5. С
    9.6. Объединение
    9.7. Используя

10. Чтение Пунктов

    10.1. Соответствие
    10.2. Дополнительное Соответствие
    10.3. Где
    10.4. Запустить
    10.5. Агрегация

11. Запись Пунктов

    11.1. Создать
    11.2. Создайте Уникальный
    11.3. Слияние
    11.4. Набор
    11.5. Стереть
    11.6. Перемещение
    11.7. Foreach

12. Функции

    12.1. Предикаты
    12.2. Скалярные функции
    12.3. Функции набора
    12.4. Математические функции
    12.5. Строковые функции

13. Схема

    13.1. Индексирует
    13.2. Ограничения

14. От SQL до Кода

    14.1. Запустить
    14.2. Соответствие
    14.3. Где
    14.4. Возвратиться

Глава 7. Введение

Чтобы получить краткий обзор Кода, продолжайте читать Раздел 7.1, “Каков Код?”.
Остальная часть этой главы имеет дело с контекстом операторов Cypher, как для
управление транзакцией в качестве примера и как использовать параметры. Для Кода
ссылка самого языка видит другие главы в Части III, “Запрос Кода
Язык”.

7.1. Каков Код?

7.1.1. Введение
7.1.2. Строение

7.1.1. Введение

Код - декларативный язык запроса графика, который учитывает выразительный и
эффективные запросы и обновление хранилища графика. Код относительно
простой, но все еще очень мощный язык. Очень сложные запросы базы данных могут
легко будьте выражены через Код. Это позволяет Вам сосредотачиваться на своем домене
вместо того, чтобы теряться в доступе к базе данных.

Код разработан, чтобы быть гуманным языком запроса, соответствующим для обоих разработчиков
и (значительно, мы думаем), профессионалы операций. Наша цель руководства к
сделайте простые вещи легкими, и комплексные вещи возможный. Его конструкции
основаны на английской прозе и аккуратной иконографии, которая помогает сделать запросы
более очевидный. Мы попытались оптимизировать язык для того, чтобы читать и
не для того, чтобы записать.

Будучи декларативным языком, Код сосредотачивается на ясности выражения что
получать от графика, не на том, как получить это. Это в отличие от
императивные языки как Java, языки сценариев как Гремлин <http://
gremlin.tinkerpop.com>, и JRuby Neo4j привязка <http://
neo4j.rubyforge.org/>. Этот подход делает оптимизацию запроса реализацией
деталь вместо того, чтобы нагрузить пользователя с этим и требовать, чтобы она обновила все
обходы только, потому что материальное строение базы данных изменилось (новый
индексирует и т.д.).

Код вдохновлен многими разными подходами и полагается
установленная практика для выразительных запросов. Большинство ключевых слов, как ГДЕ
и ПОРЯДОК вдохновлен SQL <http://en.wikipedia.org/wiki/SQL>. Модель
соответствие заимствует подходы выражения от SPARQL <http://en.wikipedia.org/
wiki/SPARQL>. Часть семантики набора была заимствована от
языки, такие как Хаскелл и Python.

7.1.2. Строение

Код заимствует это, строение от SQL  -  запросы создано, используя различный
пункты.

Пункты объединены в цепочку вместе, и они подают промежуточные наборы результатов
друг между другом. Например, соответствующие идентификаторы из одного пункта СООТВЕТСТВИЯ
будет контекст, в котором существует следующий пункт.

Язык запроса состоит из нескольких явных пунктов. Вы можете читать больше
детали о них позже в справочнике.

Вот несколько пунктов, используемых, чтобы читать из графика:

  * СООТВЕТСТВИЕ: модель графика, чтобы соответствовать. Это - наиболее распространенный способ получить данные
    от графика.
  *, ГДЕ: Не пункт в своем собственном праве, а скорее часть СООТВЕТСТВИЯ, ДОПОЛНИТЕЛЬНОГО
    СООТВЕТСТВУЙТЕ и С. Прибавляет ограничения к модели, или фильтрует промежуточное звено
    прохождение результата С.
  * ВОЗВРАТ: Что возвратиться.

Пустите нам видеть СООТВЕТСТВИЕ и ВОЗВРАЩАТЬСЯ в действии.

Вообразите график в качестве примера как следующий:

Рисунок 7.1. График в качестве примера

Example-Graph-cypher-intro.svg


Например, вот запрос, который обнаруживает пользователя по имени друзья Джона и Джон
(хотя не его прямые друзья) прежде, чем возвратить и Джона и любого
друзья друзей, которые найдены.

СООТВЕТСТВИЕ (Джон {имя: 'Джон'}) - [:friend]-> () - [:friend]-> (fof)
ВОЗВРАТИТЕ Джона, fof

Следование:

+------------------------------------------+
|john |fof |
|------------------------------------------|
|2 строки |
|------------------------------------------|
|Node [3] {имя: "Джон"} |Node [1] {имя: "Мария"} |
|--------------------+---------------------|
|Node [3] {имя: "Джон"} |Node [2] {имя: "Стив"} |
+------------------------------------------+

Затем мы прибавим фильтрацию, чтобы привести больше частей в движение:

Мы берем список имен пользователя и обнаруживаем все вершины с именами от этого списка,
соответствуйте их друзьям и возвратите только тех сопровождаемых пользователей, у которых есть имя
свойство, запускающееся с S.

СООТВЕТСТВИЕ (пользователь) - [:friend]-> (следящий механизм)
ГДЕ user.name В ['Джо', 'Джон', 'Сара', 'Мария', 'Стив'] И follower.name = ~ 'S. *'
ВОЗВРАТИТЕ пользователя, follower.name

Следование:

+----------------------------------+
|user |follower.name |
|----------------------------------|
|2 строки |
|----------------------------------|
|Node [3] {имя: "Джон"} | "Сара" |
|--------------------+-------------|
|Node [4] {имя: "Джо"} | "Стив" |
+----------------------------------+

И вот примеры пунктов, которые используются, чтобы обновить график:

  * СОЗДАЮТ (и СОТРИТЕ): Создайте (и сотрите), вершины и отношения.
  * НАБОР (и ПЕРЕМЕЩЕНИЕ): Набор оценивает свойствам, и прибавьте метки на использовании вершин
    НАБОР и использование ПЕРЕМЕЩАЮТ, чтобы переместить их.
  * СЛИЯНИЕ: Соответствуйте существующий или создайте новые вершины и модели. Это особенно
    полезный вместе с ограничениями уникальности.

Для большего количества примеров Кода, см. Главу 5, Примеры Моделирования данных так же как
подпорка Кода расстается с деталями относительно языка. Использовать Код от Java,
см. Раздел 32.12, “Выполните Запросы Кода от Java”.

7.2. Обновление графика

7.2.1. Строение Обновления Запросов
7.2.2. Возврат данных

Код может использоваться и для запросов и для обновления Вашего графика.

7.2.1. Строение Обновления Запросов

Быстрая информация

  * часть запроса Кода не может и соответствовать и обновить график одновременно.
  * Каждая часть может или читать и соответствовать на графике, или сделать обновления о нем.

Если Вы читаете из графика, и затем обновляете график, Ваш запрос неявно
имеет две части  - , чтение - первая часть, и запись является второй.
Если Ваш запрос будет только для чтения, то Код будет ленив, и не фактически соответствовать
модель, пока Вы не просите результаты. В запросе обновления семантика
то все чтение будет сделано прежде, чем любая запись фактически происходит. Сначала
чтение, и затем запись, является единственной моделью, где части запроса
неявный  -  любой другой порядок и Вы должны быть явными о своих частях запроса.
Части разделены, используя С оператором. С походит на событие
горизонт  -  это - барьер между схемой и обработанным начисто выполнением этого
схема.

То, когда Вы хотите фильтровать использование, агрегировало данные, Вы должны объединить в цепочку вместе два
чтение запроса разделяет  - , первый делает агрегацию, и второй запрос
фильтры на результатах, прибывающих из первого.

ЗАПУСТИТЕ n=node (...)
СООТВЕТСТВУЙТЕ n-[:friend] - друг
С n, количество (друг) как friendsCount
ГДЕ friendsCount> 3
ВОЗВРАТИТЕ n, friendsCount

Используя С, Вы определяете, как Вы хотите, чтобы агрегация произошла, и что
агрегация должна быть обработана начисто прежде, чем Код может начать фильтровать.

Вы можете объединить в цепочку вместе так много частей запроса, как у Вас есть "куча" JVM для.

7.2.2. Возврат данных

Любой запрос может возвратить данные. Если Ваш запрос только читает, он должен возвратить данные  -  это
не служит никакой цели, если это не делает, и это не допустимый запрос Кода. Запросы
то обновление график ничего не должен возвратить, но они могут.

После всех частей запроса прибывает один конечный пункт ВОЗВРАТА. ВОЗВРАТ Не
часть любого запроса разделяет  - , это - символ периода в конце запроса.
ВОЗВРАТИТЕСЬ у пункта есть три подпункта, которые идут с ним ПРОПУСК/ПРЕДЕЛ и ПОРЯДОК.

Если Вы возвращаете элементы графика из запроса, который только что стер их, -  остерегаются,
Вы содержите указатель, который больше не действителен. Операции на той вершине
мог бы перестать работать загадочно и непредсказуемо.

7.3. Транзакции

Любой запрос, который обновляет график, приработает транзакцию. Запрос обновления
будет всегда или полностью успешно выполняться, или не успешно выполняться вообще.

Код будет или создавать новую транзакцию или работать в существующем:

  *, Если никакая транзакция не существует в рабочем Коде контекста, создаст один и
    фиксируйте это, как только запрос заканчивает.
  * В случае, если там уже существует транзакция в рабочем контексте,
    запрос будет работать в этом, и ничто не будет сохранено, чтобы обработать почву дисковым культиватором до этого
    транзакция успешно фиксируется.

Это может использоваться, чтобы иметь разнообразные запросы фиксироваться как единственная транзакция:

 1. Откройте транзакцию,
 2. выполните разнообразные запросы Кода обновления,
 3. и фиксируйте всех их сразу.

Заметьте, что запрос будет содержать изменения в памяти, пока целый запрос не будет иметь
обработанное начисто выполнение. Большой запрос будет следовательно нуждаться в JVM с большим количеством из
пространство "кучи".

Для того, чтобы использовать транзакции по остальным API, см. Раздел 19.1, “Транзакционный HTTP
конечная точка”.

При использовании встроенного Neo4j, помните, что весь iterators возвратился из выполнения
результат должен быть исчерпан полностью, чтобы гарантировать, что ресурсы, связанные с ними, будут
должным образом закрытый. Ресурсы включают транзакции, запущенные запросом, таким образом,
сбой сделать так может, например, привести к тупикам или другому странному поведению.

7.4. Уникальность

В то время как сопоставление с образцом, Код удостоверяется, что не включал соответствия где то же самое
отношение графика найдено многократно в разовой модели. В большинстве использования
случаи, это - заметная вещь сделать.

Пример: поиск друзей пользователя друзей не должен возвратиться, сказал пользователь.

Пустите нам создавать несколько вершин и отношений:

СОЗДАЙТЕ (adam:User {имя: 'Адам'}), (pernilla:User {имя: 'Pernilla'}), (david:User {имя: 'Дэвид'
  }),
  (adam) - [:FRIEND]-> (pernilla), (pernilla) - [:FRIEND]-> (david)

Который дает нам следующий график:

cypherdoc - 13303421.svg

Теперь пустите нам искать друзей друзей Адама:

СООТВЕТСТВИЕ (user:User {имя: 'Адам'}) - [r1:FRIEND] - () - [r2:FRIEND] - (friend_of_a_friend)
ВОЗВРАТИТЕ friend_of_a_friend

+---------------------+
|friend_of_a_friend |
|---------------------|
|1 строка |
|---------------------|
|Node [2] {имя: "Дэвид"} |
+---------------------+

В этом запросе Код удостоверяется к не ответные матчи где модель
отношения r1 и r2 указывают на то же самое отношение графика.

Это однако не всегда требуется. Если запрос должен возвратить пользователя, это
возможный расплющивать соответствие по разнообразным пунктам СООТВЕТСТВИЯ, как так:

СООТВЕТСТВИЕ (user:User {имя: 'Адам'}) - [r1:FRIEND] - (друг)
С другом
СООТВЕТСТВИЕ (друг) - [r2:FRIEND] - (friend_of_a_friend)
ВОЗВРАТИТЕ friend_of_a_friend

+---------------------+
|friend_of_a_friend |
|---------------------|
|2 строки |
|---------------------|
|Node [2] {имя: "Дэвид"} |
|---------------------|
|Node [0] {имя: "Адам"} |
+---------------------+

7.5. Параметры

7.5.1. Строковый литерал
7.5.2. Регулярное выражение
7.5.3. Создайте вершину со свойствами
7.5.4. Создайте разнообразные вершины со свойствами
7.5.5. Установка всех свойств на вершине
7.5.6. ПРОПУСТИТЕ и ОГРАНИЧЬТЕ
7.5.7. Идентификатор вершины
7.5.8. Разнообразные идентификаторы вершины
7.5.9. Индексируйте значение (наследство индексирует),
7.5.10. Индексируйте запрос (наследство индексирует),

Код поддерживает запросы с параметрами. Это означает, что разработчики не имеют к
обратитесь, чтобы представить здание в виде строки, чтобы создать запрос. В дополнение к этому это также делает
кэширование схем выполнения, намного легче для Кода.

Параметры могут использоваться для литералов и выражений в ГДЕ пункт, для
индексировать значение в пункте ЗАПУСКА, индексируйте запросы, и наконец для вершины /
идентификаторы отношения. Параметры не могут использоваться что касается имен свойства,
типы отношения и метки, так как эти модели - часть запроса
строение, которое скомпилировано в схему запроса.

Очищенные имена для параметров - буквы и номера, и любая комбинация
они.

Для получения дополнительной информации на параметрах при использовании встроенного API Java Neo4j, см.
Раздел 32.13, “Параметры Запроса”. Для получения дополнительной информации при использовании параметров через
API REST Neo4j, см. Раздел 19.5, “Код запрашивает через REST”.

Ниже следует за исчерпывающим набором примеров использования параметра.
параметры даны как ДЖСОН здесь. Точно то, как представить их, зависит от
драйвер в использовании.

7.5.1. Строковый литерал

Параметры.

{
  "имя": "Йохан"
}

Запрос.

СООТВЕТСТВИЕ (n)
ГДЕ n.name = {имя}
ВОЗВРАТИТЕ n

7.5.2. Регулярное выражение

Параметры.

{
  "regex": ".*h. *"
}

Запрос.

СООТВЕТСТВИЕ (n)
ГДЕ n.name = ~ {regex}
ВОЗВРАТИТЕ n.name

7.5.3. Создайте вершину со свойствами

Параметры.

{
  "опоры": {
    "позиция": "Разработчик",
    "имя": "Андрес"
  }
}

Запрос.

СОЗДАЙТЕ ({поддерживает})

7.5.4. Создайте разнообразные вершины со свойствами

Параметры.

{
  "опоры": [{
    "позиция": "Разработчик",
    "удивительный": истина,
    "имя": "Андрес"
  }, {
    "позиция": "Разработчик",
    "имя": "Майкл",
    "дочерние элементы": 3
  } ]
}

Запрос.

СОЗДАЙТЕ (n:Person {опоры})
ВОЗВРАТИТЕ n

7.5.5. Установка всех свойств на вершине

Заметьте, что это заменит все текущие свойства.

Параметры.

{
  "опоры": {
    "позиция": "Разработчик",
    "имя": "Андрес"
  }
}

Запрос.

СООТВЕТСТВИЕ (n)
ГДЕ n.name =' Микаэла'
НАБОР n = {опоры}

7.5.6. ПРОПУСТИТЕ и ОГРАНИЧЬТЕ

Параметры.

{
  "s": 1,
  "l": 1
}

Запрос.

СООТВЕТСТВИЕ (n)
ВОЗВРАТИТЕ n.name
ПРОПУСТИТЕ {s}
ПРЕДЕЛ {l}

7.5.7. Идентификатор вершины

Параметры.

{
  "идентификатор": 0
}

Запрос.

ЗАПУСТИТЕ n=node ({идентификатор})
ВОЗВРАТИТЕ n.name

7.5.8. Разнообразные идентификаторы вершины

Параметры.

{
  "идентификатор": [0, 1, 2]
}

Запрос.

ЗАПУСТИТЕ n=node ({идентификатор})
ВОЗВРАТИТЕ n.name

7.5.9. Индексируйте значение (наследство индексирует),

Параметры.

{
  "значение": "Микаэла"
}

Запрос.

ЗАПУСТИТЕ n=node:people (имя = {значение})
ВОЗВРАТИТЕ n

7.5.10. Индексируйте запрос (наследство индексирует),

Параметры.

{
  "запрос": "name:Andreas"
}

Запрос.

ЗАПУСТИТЕ n=node:people ({запрос})
ВОЗВРАТИТЕ n

7.6. Совместимость

Код все еще изменяется скорее быстро. Части изменений - внутренний  -  мы
прибавьте новых сопоставителей, агрегаторы и другую оптимизацию, который, мы надеемся,
делает Ваши запросы выполненными быстрее.

Другие изменения прямо видимы нашим пользователям  - , синтаксис все еще изменяется.
Новые понятия прибавляются, и старые изменены, чтобы вписаться новый
возможности. Охранять Вас от необходимости не отставать от наших изменений синтаксиса,
Код позволяет Вам использовать более старый синтаксический анализатор, но все еще получать скорость от нового
оптимизация.

Есть два способа, которыми Вы можете выбрать который синтаксический анализатор использовать. Вы можете сконфигурировать Ваш
база данных с параметром конфигурации cypher_parser_version, и входит
какой синтаксический анализатор Вы хотели бы использовать (1.9, 2.0 поддерживаются теперь). Любой запрос Кода
это явно не говорит ничто больше, получит синтаксический анализатор, который Вы имеете
сконфигурированный.

Другой путь находится на запросе основанием запроса. Просто помещая "КОД 1.9" в
начало, что определенный запрос будет проанализирован с 1.9 версиями
синтаксический анализатор. Пример:

КОДИРУЙТЕ 1.9, ЗАПУСКАЮТ n=node (0)
ГДЕ n.foo = "бар"
ВОЗВРАТИТЕ n

7.7. Производительность запроса

Код очень работает усиленно, чтобы выполнить запросы с такой скоростью, как возможный.

Однако, оптимизируя для максимальной производительности выполнения запроса, это может быть
полезный, чтобы перефразировать запросы, используя знание о домене и
приложение.

Полная цель физической оптимизации производительности запроса состоит в том, чтобы гарантировать это
только необходимые данные получены от графика. По крайней мере, данные должны добраться
отфильтрованный как можно раньше, чтобы понизить объем работы это
должен быть сделан на более поздних этапах выполнения запроса. Это также идет для того, что добирается
возвращенный: избегите возвращать целые вершины и отношения  -  вместо этого, выберите
данные Вы нуждаетесь и возвращаете только это. Вы должны также удостовериться, что установили верхнее
предел на моделях переменной длины, таким образом, они не покрывают большие части
набор данных чем необходимый.

Каждый запрос Кода получает оптимизированным и преобразованным в схему выполнения
Механизм выполнения кода. Чтобы минимизировать ресурсы, используемые для этого, удостоверьтесь к
используйте параметры вместо литералов когда возможный. Это позволяет Коду повторно использовать
Ваши запросы вместо того, чтобы иметь необходимость проанализировать и создать новые схемы выполнения.

Замечание

Когда Код создает схемы выполнения, он смотрит на схему, чтобы видеть если это
может обнаружить полезным, индексирует. Они индексируют решения, только допустимы до схемы
изменения, таким образом добавляясь или перемещая индексируют, приводит к кэшу схемы выполнения быть
сброшенный.

Глава 8. Синтаксис

Детали основных элементов синтаксиса Кода.

8.1. Операторы

8.1.1. Математические операторы
8.1.2. Операторы сравнения
8.1.3. Булевы операторы
8.1.4. Строковые операторы
8.1.5. Операторы набора
8.1.6. Операторы свойства

8.1.1. Математические операторы

Математические операторы +, - *, / и %, ^.

8.1.2. Операторы сравнения

Операторы сравнения =, <>, <>, <=>, =.

8.1.3. Булевы операторы

Булевы операторы И, ИЛИ, XOR, НЕТ.

8.1.4. Строковые операторы

Строки могут быть связаны, используя + оператор.

8.1.5. Операторы набора

Наборы могут быть связаны, используя + оператор. Проверять если элемент
существует в наборе, Вы можете использовать В операторе.

8.1.6. Операторы свойства

Замечание

Начиная с версии 2.0, ранее существующих операторов свойства? и! были
удаленный. Этот синтаксис больше не поддерживается. Пропускающие свойства теперь
возвращенный как нуль. Пожалуйста, используйте (НЕ (имеет (<ident>.prop)) ИЛИ <ident>.prop = <значение>),
если Вы действительно нуждаетесь в старом поведении? оператор.  -  кроме того, использование? для
дополнительные отношения были удалены в пользу недавно представленный
ДОПОЛНИТЕЛЬНЫЙ пункт СООТВЕТСТВИЯ.

8.2. Выражения

8.2.1. Выражения вообще
8.2.2. Замечание на строковых литералах
8.2.3. Case-выражения
8.2.4. Простой CASE
8.2.5. Универсальный CASE

8.2.1. Выражения вообще

Выражение в Коде может быть:

  * числовой литерал (целое число или двойное количество): 13, 40000, 3.14.
  * строковый литерал: "Привет", 'Мир'.
  * булев литерал: истина, ложь, ПРАВДА, ЛОЖЬ.
  * идентификатор: n, x, рэл, myFancyIdentifier, `Имя со странным материалом в этом
    []!`.
  Свойство * A: n.prop, x.prop, rel.thisProperty, myFancyIdentifier. `(странный
    имя свойства)`.
  * параметр: {param}, {0}
  * набор выражений: ["a", "b"], [1,2,3], ["a", 2, n.property,
    {param}], [].
  * вызов функции: длина (p), вершины (p).
  * совокупная функция: в среднем (x.prop), количество (*).
  * модель пути: (a)-> () <-(b).
  * выражение предиката - выражение, которое возвращает истину или ложь: a.prop
    = "Привет", длина (p)> 10, имеет (a.name)
  * Case-выражение

8.2.2. Замечание на строковых литералах

Строковые литералы могут содержать эти escape-последовательности.

    Символ escape-последовательности
                 Вкладка \t

                 Клавиша Backspace \b

                 Новая строка \n

                 Возврат каретки \r

                 Перевод формата \f

                 \' Одинарная кавычка

                 \" Двойная кавычка

                 \\Наклонная черта влево

8.2.3. Case-выражения

Код поддерживает Case-выражения, который является универсальным условным выражением,
подобный, к если/еще операторы на других языках. Две разновидности CASE
существуйте  -  простая форма и универсальная форма.

8.2.4. Простой CASE

Выражение вычислено, и не сравнено в порядке с КОГДА пункты до
соответствие найдено. Если никакое соответствие не найдено, выражение в Выражении else
используемый, или нулевой, если не ЕЩЕ случай существует.

Синтаксис:

Тест CASE
КОГДА значение ЗАТЕМ следует
[КОГДА...]
[ЕЩЕ значение по умолчанию]
КОНЕЦ

Параметры:

  * expr: допустимое выражение.
  * значение: выражение, результат которого будет по сравнению с тестовым выражением.
  * результат: Это - выражение результата, используемое, если выражение значения соответствует
    тестовое выражение.
  * значение по умолчанию: выражение, чтобы использовать, если никакое соответствие не найдено.

Запрос.

СООТВЕТСТВИЕ n
ВОЗВРАТИТЕ CASE n.eyes
КОГДА 'синий цвет'
ЗАТЕМ 1
КОГДА 'коричневый цвет'
ЗАТЕМ 2
ЕЩЕ 3 результата AS КОНЦА

Таблица 8.1. Результат

+------+
|result |
|------|
|5 строк |
|------|
|2 |
|------|
|1 |
|------|
|2 |
|------|
|1 |
|------|
|3 |
+------+


8.2.5. Универсальный CASE

Предикаты оценены в порядке, пока истинное значение не найдено, и
значение результата используется. Если никакое соответствие не найдено, выражение в Выражении else
используемый, или нулевой, если не ЕЩЕ случай существует.

Синтаксис:

CASE
КОГДА предикат ЗАТЕМ следует
[КОГДА...]
[ЕЩЕ значение по умолчанию]
КОНЕЦ

Параметры:

  * предикат: предикат, который протестирован, чтобы обнаружить допустимый вариант.
  * результат: Это - выражение результата, используемое, если предикат соответствует.
  * значение по умолчанию: выражение, чтобы использовать, если никакое соответствие не найдено.

Запрос.

СООТВЕТСТВИЕ n
ВОЗВРАТИТЕ CASE
    КОГДА n.eyes = 'синий'
ЗАТЕМ 1
КОГДА n.age <40
ЗАТЕМ 2
ЕЩЕ 3 результата AS КОНЦА

Таблица 8.2. Результат

+------+
|result |
|------|
|5 строк |
|------|
|3 |
|------|
|1 |
|------|
|2 |
|------|
|1 |
|------|
|3 |
+------+


8.3. Идентификаторы

Когда Вы ссылаетесь на части модели, Вы делаете так, называя их. Имена
Вы подаетесь, различные части вызывают идентификаторами.

В этом примере:

СООТВЕТСТВИЕ (n)-> (b) ВОЗВРАЩАЮТ b

Идентификаторы - n и b.

Имена идентификатора являются чувствительными к регистру, и могут содержать подчеркивания и
алфавитно-цифровые символы (a-z, 0-9), но должны запуститься с буквы. Если другой
символы необходимы, Вы можете заключить идентификатор в кавычки, используя одинарную левую кавычку (`) знаки.

Те же самые правила применяются к именам свойства.

8.4. Комментарии

Чтобы прибавить комментарии к Вашим запросам, используйте двойную наклонную черту. Примеры:

СООТВЕТСТВИЕ (n) ВОЗВРАЩАЕТ n//, Это - конец комментария строки

СООТВЕТСТВИЕ (n)
//Это - целый комментарий строки
ВОЗВРАТИТЕ n

СООТВЕТСТВИЕ (n), ГДЕ n.property = "//Это не комментарий", ВОЗВРАЩАЕТ n

8.5. Модели

8.5.1. Модели для вершин
8.5.2. Модели для связанных вершин
8.5.3. Метки
8.5.4. Определение свойств
8.5.5. Описание отношений
8.5.6. Присвоение идентификаторам пути

Модели и сопоставление с образцом в самой основе Кода, таким образом будучи
эффективный с Кодом требует хорошего понимания моделей.

Используя модели, Вы описываете форму данных, которые Вы ищете. Для
пример, в пункте СООТВЕТСТВИЯ Вы описываете форму с моделью, и Код
выяснит, как получить те данные для Вас.

Модель описывает данные, используя форму, которая очень подобна как один
обычно тянет форму данных графика свойства на электронной доске: обычно как
круги (представляющий вершины) и стрелки между ними, чтобы представить
отношения.

Модели появляются в разнообразных местах в Коде: в СООТВЕТСТВИИ, СОЗДАЙТЕ и ОБЪЕДИНИТЕСЬ
пункты, и в выражениях модели. Каждый из них описан более детально
в:

  * Раздел 10.1, "Соответствие"
  * Раздел 10.2, “Дополнительное Соответствие”
  * Раздел 11.1, "Создать"
  * Раздел 11.3, "Слияние"
  * Раздел 10.3.3, “Используя модели, в ГДЕ”

8.5.1. Модели для вершин

Очень самая простая "форма", которая может быть описана в модели, является вершиной. Вершина
описан, используя пару круглых скобок, и обычно дается имя. Для
пример:

(a)

Эта простая модель описывает единственную вершину, и называет ту вершину, используя
идентификатор a.

Заметьте, что круглые скобки могут быть опущены, но только когда нет никаких меток или
свойства определены для модели вершины.

8.5.2. Модели для связанных вершин

Более интересный модели, которые описывают разнообразные вершины и отношения
между ними. Модели кода описывают отношения, используя стрелку
между двумя вершинами. Например:

(a)-> (b)

Эта модель описывает очень простую форму данных: две вершины, и единственное
отношение от одного до другого. В этом примере эти две вершины - оба
названный как a и b соответственно, и отношение "направлен": это идет от
к b.

Этот способ описать вершины и отношения может быть расширен на покрытие
произвольное число вершин и отношений между ними, например:

(a)-> (b) <-(c)

Такую серию соединенных вершин и отношений вызывают "путем".

Заметьте, что именование вершин в этих моделях только необходимо, должен
одна потребность обратиться к той же самой вершине снова, или позже в модели или
в другом месте в запросе Кода. Если это не необходимо тогда, имя может быть
опущенный, как так:

(a)-> () <-(c)

8.5.3. Метки

В дополнение к простому описанию формы вершины в модели каждый может
также опишите атрибуты. Самый простой атрибут, который может быть описан в
модель - метка, которую должна иметь вершина. Например:

(a:User)-> (b)

Можно также описать вершину, у которой есть разнообразные метки:

(a:User:Admin)-> (b)

8.5.4. Определение свойств

Вершины и отношения - фундаментальные строения в графике. Использование Neo4j
свойства на обоих из них, чтобы учесть далеко более богатые модели.

Свойства могут быть выражены в моделях, используя конструкцию карты: фигурные скобки
окружение многих пар ключевого выражения, разделенных запятыми. Например, вершина
с двумя свойствами на этом был бы похож: ({имя: "Андрес", спорт:
"Бразильское Джиу-джитсу"}).

Отношение с ожиданиями на этом было бы, мог быть похожим: (a) - [{блокированный:
ложь}]-> (b).

Когда свойства появляются в моделях, они прибавляют дополнительное ограничение к
форма данных. В случае СОЗДАТЬ пункта будут установлены свойства
в недавно создаваемых вершинах и отношениях. В случае пункта СЛИЯНИЯ,
свойства будут использоваться в качестве дополнительных ограничений на форму любой существующий
данные должны иметь (указанные свойства должны точно соответствовать любые существующие данные
в графике). Если никакие данные соответствия не найдены, то ОБЪЕДИНИТЕСЬ, ведет себя как, СОЗДАЮТ и
свойства будут установлены в недавно создаваемых вершинах и отношениях.

Заметьте, что модели, предоставленные, чтобы СОЗДАТЬ, могут использовать единственный параметр, чтобы определить
свойства, например: СОЗДАЙТЕ (вершина {paramName}). Это не возможно с моделями
используемый в других пунктах, поскольку Код должен знать имена свойства в это время
запрос скомпилирован, так, чтобы соответствие могло быть сделано эффективно.

8.5.5. Описание отношений

Самый простой способ описать отношение при использовании стрелки между два
вершины, как в предыдущих примерах. Используя этот метод, Вы можете описать это
отношение должно существовать и направленность этого. Если Вы не заботитесь
о направлении отношения наконечник стрелки может быть опущен, как
так:

(a) - (b)

Как с вершинами, отношения могут также быть именами. В этом случае, пара
квадратные скобки используются, чтобы разбить стрелку, и идентификатор размещен
между. Например:

(a) - [r]-> (b)

Очень как метки на вершинах, у отношений могут быть типы. Описать a
отношение с определенным типом, Вы можете определить это как так:

(a) - [r:REL_TYPE]-> (b)

В отличие от меток, у отношений может только быть один тип. Но если мы хотели бы к
опишите некоторые данные так, что, у отношения мог быть любой из ряда
типы, тогда они могут все быть перечислены в модели, разделяя их с
символ канала | как это:

(a) - [r:TYPE1|TYPE2]-> (b)

Заметьте, что эта форма модели может только использоваться, чтобы описать существующие данные (то есть.
при использовании модели с СООТВЕТСТВИЕМ или как выражение). Это не будет работать с
СОЗДАЙТЕ или ОБЪЕДИНИТЕСЬ, так как не возможно создать отношение с разнообразным
типы.

Как с вершинами, имя отношения может всегда опускаться, в этом случае
как так:

(a) - [:REL_TYPE]-> (b)

8.5.5.1. Переменная длина

Вместо того, чтобы описывать длинный путь, используя последовательность многих вершина и
описания отношения в модели, много отношений (и
промежуточные вершины), может быть описан, определяя длину в отношении
описание модели. Например:

(a) - [*2]-> (b)

Это описывает график трех вершин и двух отношений, всех в одном пути (a
путь длины 2). Это эквивалентно:

(a)-> ()-> (b)

Диапазон длин может также быть определен: такие модели отношения вызывают
“отношения переменной длины”. Например:

(a) - [*3.. 5]-> (b)

Это - минимальная длина 3, и максимум 5. Это описывает график
или 4 вершины и 3 отношения, 5 вершин и 4 отношения или 6 вершин и
5 отношений, все соединялись вместе в единственном пути.

Любой связанный может быть опущен. Например, чтобы описать пути длины 3 или
больше, используйте:

(a) - [*3..]-> (b)

И описать пути длины 5 или меньше, используйте:

(a) - [*.. 5]-> (b)

Обе границы могут быть опущены, позволяя пути любой длины быть описанными:

(a) - [*]-> (b)

Как простой пример, пустите нам брать запрос ниже:

Запрос.

СООТВЕТСТВУЙТЕ (меня) - [:KNOWS*1.. 2] - (remote_friend)
ГДЕ me.name = "Филипа"
ВОЗВРАТИТЕ remote_friend.name

Таблица 8.3. Результат

+------------------+
|remote_friend.name |
|------------------|
|2 строки |
|------------------|
| "Dilshad" |
|------------------|
| "Андерс" |
+------------------+


Этот запрос обнаруживает данные в графике, который форма, которая приспосабливает модель:
определенно вершина (со свойством имени Филипа) и затем ЗНАНИЕ связанного
вершины, один или два выходит. Это - типичный пример обнаружения сначала и
вторые друзья градуса.

Заметьте, что отношения переменной длины не могут использоваться с, СОЗДАЮТ и ОБЪЕДИНЯЮТСЯ.

8.5.6. Присвоение идентификаторам пути

Как описано выше, серию соединенных вершин и отношений вызывают a
"путь". Код позволяет путям быть названными, используя identifer, как так:

p = (a) - [*3.. 5]-> (b)

Вы можете сделать это в СООТВЕТСТВИИ, СОЗДАТЬ и ОБЪЕДИНИТЬСЯ, но не при использовании моделей как
выражения.

8.6. Наборы

8.6.1. Наборы вообще
8.6.2. Понимание списка
8.6.3. Литеральные карты

У кода есть хорошая поддержка наборов.

8.6.1. Наборы вообще

Литеральный набор создается при использовании скобок и разделения элементов
в наборе с запятыми.

Запрос.

ВОЗВРАТИТЕСЬ [0,1,2,3,4,5,6,7,8,9] набор AS

Таблица 8.4. Результат

+---------------------+
|collection |
|---------------------|
|1 строка |
|---------------------|
| [0,1,2,3,4,5,6,7,8,9] |
+---------------------+


В наших примерах мы будем использовать функцию диапазона. Это дает Вам набор
содержание всех номеров между данным запуском и номеров конца.

К элементам единичного доступа в наборе мы используем квадратные скобки
снова.

Запрос.

ВОЗВРАТИТЕ диапазон (0,10) [3]

Таблица 8.5. Результат

+--------------+
|range (0,10) [3] |
|--------------|
|1 строка |
|--------------|
|3 |
+--------------+


Вы можете также использовать отрицательные числа, чтобы запустить с конца набора
вместо этого.

Запрос.

ВОЗВРАТИТЕ диапазон (0,10) [-3]

Таблица 8.6. Результат

+---------------+
|range (0,10) [-3] |
|---------------|
|1 строка |
|---------------|
|8 |
+---------------+


Наконец, Вы можете использовать диапазоны в скобках, чтобы возвратить диапазоны
набор.

Запрос.

ВОЗВРАТИТЕ диапазон (0,10) [0.. 3]

Таблица 8.7. Результат

+-----------------+
|range (0,10) [0.. 3] |
|-----------------|
|1 строка |
|-----------------|
| [0,1,2] |
+-----------------+


Запрос.

ВОЗВРАТИТЕ диапазон (0,10) [0..-5]

Таблица 8.8. Результат

+------------------+
|range (0,10) [0..-5] |
|------------------|
|1 строка |
|------------------|
| [0,1,2,3,4,5] |
+------------------+


Запрос.

ВОЗВРАТИТЕ диапазон (0,10) [-5..]

Таблица 8.9. Результат

+-----------------+
|range (0,10) [-5..] |
|-----------------|
|1 строка |
|-----------------|
| [6,7,8,9,10] |
+-----------------+


Запрос.

ВОЗВРАТИТЕ диапазон (0,10) [.. 4]

Таблица 8.10. Результат

+----------------+
|range (0,10) [.. 4] |
|----------------|
|1 строка |
|----------------|
| [0,1,2,3] |
+----------------+


Замечание: - ограниченных пластин просто усечены, но - единственных ограниченных
элементы возвращают нуль.

Запрос.

ВОЗВРАТИТЕ диапазон (0,10) [15]

Таблица 8.11. Результат

+---------------+
|range (0,10) [15] |
|---------------|
|1 строка |
|---------------|
| <нуль> |
+---------------+


Запрос.

ВОЗВРАТИТЕ диапазон (0,10) [5.. 15]

Таблица 8.12. Результат

+------------------+
|range (0,10) [5.. 15] |
|------------------|
|1 строка |
|------------------|
| [5,6,7,8,9,10] |
+------------------+


8.6.2. Понимание списка

Понимание списка - синтаксическая конструкция, доступная в Коде для того, чтобы создать a
набор, основанный на существующих наборах. Это следует за формой
математическая нотация разработчика набора (понимание набора) вместо использования карты
и функции фильтра.

Запрос.

ВОЗВРАТИТЕ [x В диапазоне (0,10) ГДЕ x % 2 = 0 | x^3] результат AS

Таблица 8.13. Результат

+---------------------------------+
|result |
|---------------------------------|
|1 строка |
|---------------------------------|
| [0.0,8.0,64.0,216.0,512.0,1000.0] |
+---------------------------------+


Или, ГДЕ часть, или выражение, может быть опущена, если Вы только хотите к
фильтр или карта соответственно.

Запрос.

ВОЗВРАТИТЕ [x В диапазоне (0,10) ГДЕ x % 2 = 0] результат AS

Таблица 8.14. Результат

+--------------+
|result |
|--------------|
|1 строка |
|--------------|
| [0,2,4,6,8,10] |
+--------------+


Запрос.

ВОЗВРАТИТЕ [x В диапазоне (0,10) | x^3] результат AS

Таблица 8.15. Результат

+------------------------------------------------------------+
|result |
|------------------------------------------------------------|
|1 строка |
|------------------------------------------------------------|
| [0.0,1.0,8.0,27.0,64.0,125.0,216.0,343.0,512.0,729.0,1000.0] |
+------------------------------------------------------------+


8.6.3. Литеральные карты

От Кода Вы можете также создать карты. В Java они будут java.util. Карта
<Строка, Объект>, через REST Вы получите объекты ДЖСОНА.

Запрос.

ВОЗВРАТИТЕ {ключ: "Значение", collectionKey: [{внутренний: "Map1"}, {внутренний: "Map2"}]}

Таблица 8.16. Результат

+--------------------------------------------------------------------------+
| {ключ: "Значение", collectionKey: [{внутренний: "Map1"}, {внутренний: "Map2"}]} |
|--------------------------------------------------------------------------|
|1 строка |
|--------------------------------------------------------------------------|
| {ключ-> "Значение", collectionKey-> [{внутренний-> "Map1"}, {внутренний-> "Map2"}]} |
+--------------------------------------------------------------------------+


8.7. Работа с НУЛЕМ

8.7.1. Выражения тот НУЛЬ возврата

В Коде НУЛЬ используется, чтобы представить отсутствие или неопределенные значения. Концептуально,
НУЛЬ означает “значение неизвестного отсутствия”, и он обработан несколько по-другому
от других значений. Например, получение свойства от вершины, которая не имеет, сказало
свойство производит НУЛЬ. Большинство выражений, которые берут НУЛЬ в качестве ввода, произведет
НУЛЬ. Это включает булевы выражения, которые используются в качестве предикатов в
ГДЕ пункт. В этом случае, что-либо, что не является ИСТИНОЙ, интерпретируется как являющийся
ложь.

НУЛЬ не равен НУЛЮ. Не знание двух значений не подразумевает, что они
то же самое значение. Так НУЛЬ выражения = НУЛЬ приводит к НУЛЮ и не ИСТИНЕ.

Логические операторы (то есть. И, ИЛИ, XOR, В), обрабатывают НУЛЬ как "неизвестное" значение
из трех оцененных логики. Вот таблица истинности для И, ИЛИ и XOR.

    b a И b a ИЛИ b XOR b
  ЛОЖНАЯ ЛОЖНАЯ ЛОЖНАЯ ЛОЖНАЯ ЛОЖЬ

  ЛОЖНЫЙ НУЛЕВОЙ ЛОЖНЫЙ НУЛЕВОЙ НУЛЬ

  ЛОЖНАЯ ИСТИННАЯ ЛОЖНАЯ ИСТИННАЯ ИСТИНА

   ИСТИННАЯ ЛОЖНАЯ ЛОЖНАЯ ИСТИННАЯ ИСТИНА

   ИСТИННЫЙ НУЛЕВОЙ НУЛЕВОЙ ИСТИННЫЙ НУЛЬ

   ИСТИННАЯ ИСТИННАЯ ИСТИННАЯ ИСТИННАЯ ЛОЖЬ

   НУЛЕВОЙ ЛОЖНЫЙ ЛОЖНЫЙ НУЛЕВОЙ НУЛЬ

   НУЛЕВОЙ НУЛЕВОЙ НУЛЕВОЙ НУЛЕВОЙ НУЛЬ

   НУЛЕВОЙ ИСТИННЫЙ НУЛЕВОЙ ИСТИННЫЙ НУЛЬ

В операторе следует за подобной логикой. Если Код знает, что что-то существует в
набор, результат будет ИСТИНОЙ. Любой набор, который содержит НУЛЬ и
не имеет соответствующего элемента, возвратит НУЛЬ. Иначе, результат будет
ложь. Вот таблица с примерами:

            Результат выражения
          2 В [1, 2, 3] ИСТИНА

         2 В [1, НУЛЬ, 3] НУЛЬ

         2 В [1, 2, НУЛЬ] ИСТИНА

             2 В [1] ЛОЖЬ

              2 В [] ЛОЖЬ

          НУЛЬ В [1,2,3] НУЛЬ

        НУЛЬ В [1, НУЛЬ, 3] НУЛЬ

            НУЛЬ В [] ЛОЖЬ

Используя ВСЕ, ЛЮБОГО, НИ ОДИН, и ЕДИНСТВЕННЫЙ не следует за подобным правилом. Если результат может быть
вычисленный определенно, ИСТИНА ИЛИ ЛОЖЬ возвращена. Иначе НУЛЬ произведен.

8.7.1. Выражения тот НУЛЬ возврата

  * Получение элемента отсутствия от набора: [] [0], голова ([])
  * Пытающийся получить доступ к свойству, которое не существует на вершине или отношении:
    n.missingProperty
  * Сравнения, когда любая сторона - НУЛЬ: 1 <НУЛЬ
  * Арифметические выражения, содержащие НУЛЬ: 1 + НУЛЬ
  * Вызовы функции, где любые параметры - НУЛЬ: грех (НУЛЬ)

Глава 9. Общие оговорки

9.1. Возвратиться

9.1.1. Возвратите вершины
9.1.2. Возвратите отношения
9.1.3. Возвратите свойство
9.1.4. Возвратите все элементы
9.1.5. Идентификатор с редкими символами
9.1.6. Псевдоним столбца
9.1.7. Дополнительные свойства
9.1.8. Другие выражения
9.1.9. Уникальные результаты

В части ВОЗВРАТА Вашего запроса Вы определяете, какие части модели Вы
интересовавший. Это могут быть вершины, отношения, или свойства на них.

Рисунок 9.1. График

cypher-return-graph.svg


9.1.1. Возвратите вершины

Чтобы возвратить вершину, перечислите это в Операторе возврата.

Запрос.

СООТВЕТСТВИЕ (n {имя: "B"})
ВОЗВРАТИТЕ n

Пример возвратит вершину.

Таблица 9.1. Результат

+-----------------+
|n |
|-----------------|
|1 строка |
|-----------------|
|Node [1] {имя: "B"} |
+-----------------+


9.1.2. Возвратите отношения

Чтобы возвратить отношение, только включайте это в список ВОЗВРАТА.

Запрос.

СООТВЕТСТВИЕ (n {имя:}) - [r:KNOWS]-> (c)
ВОЗВРАТИТЕ r

Отношение возвращено примером.

Таблица 9.2. Результат

+-----------+
|r |
|-----------|
|1 строка |
|-----------|
|:KNOWS [0] {} |
+-----------+


9.1.3. Возвратите свойство

Чтобы возвратить свойство, используйте точечный разделитель, как это:

Запрос.

СООТВЕТСТВИЕ (n {имя:})
ВОЗВРАТИТЕ n.name

Значение имени свойства получает возвращенным.

Таблица 9.3. Результат

+------+
|n.name |
|------|
|1 строка |
|------|
| "A" |
+------+


9.1.4. Возвратите все элементы

Когда Вы хотите возвратить все вершины, отношения и пути нашли в запросе,
Вы можете использовать * символ.

Запрос.

СООТВЕТСТВУЙТЕ p = ({имя:}) - [r]-> (b)
ВОЗВРАТИТЕСЬ *

Это возвращает эти две вершины, отношение и путь, используемый в запросе.

Таблица 9.4. Результат

+-----------------------------------------------------------------------------+
|b |a |r |p |
|-----------------------------------------------------------------------------|
|2 строки |
|-----------------------------------------------------------------------------|
|Node [1] |Node [0] |:KNOWS | [Вершина [0] {имя: счастливый: "Да! |
| {имя: "B"} | {имя: счастливый: "Да! | [0] {} |", age:55}:KNOWS [0] {}, Вершина [1] |
| | ", age:55} | | {имя: "B"}] |
|----------+---------------------+-------+------------------------------------|
|Node [1] |Node [0] |:BLOCKS | [Вершина [0] {имя: счастливый: "Да! |
| {имя: "B"} | {имя: счастливый: "Да! | [1] {} |", age:55}:BLOCKS [1] {}, Вершина [1] |
| | ", age:55} | | {имя: "B"}] |
+-----------------------------------------------------------------------------+


9.1.5. Идентификатор с редкими символами

Представлять заполнителя, который составлен из символов, которые являются за пределами
английский алфавит, Вы можете использовать, `чтобы включить идентификатор, как это:

Запрос.

СООТВЕТСТВИЕ (`Это не общий идентификатор`),
ГДЕ `Это не общий идентификатор`.name ='A'
ВОЗВРАТИТЕСЬ `Это не общий идентификатор`.happy

Вершина, индексированная с именем "A", возвращена

Таблица 9.5. Результат

+--------------------------------------+
| `Это не общий идентификатор`.happy |
|--------------------------------------|
|1 строка |
|--------------------------------------|
| "Да!" |
+--------------------------------------+


9.1.6. Псевдоним столбца

Если имя столбца должно отличаться от используемого выражения, Вы можете
переименуйте это при использовании AS <новое имя>.

Запрос.

СООТВЕТСТВИЕ ({имя:})
ВОЗВРАТИТЕ a.age AS SomethingTotallyDifferent

Возвращает свойство возраста вершины, но переименовывает столбец.

Таблица 9.6. Результат

+-------------------------+
|SomethingTotallyDifferent |
|-------------------------|
|1 строка |
|-------------------------|
|55 |
+-------------------------+


9.1.7. Дополнительные свойства

Если свойство могло бы или не могло бы быть там, Вы можете все еще выбрать его как обычно. Это
будет обработан как НУЛЬ, если он пропустит

Запрос.

СООТВЕТСТВИЕ (n)
ВОЗВРАТИТЕ n.age

Этот пример возвращает возраст, когда у вершины есть то свойство, или нуль если
свойство не там.

Таблица 9.7. Результат

+------+
|n.age |
|------|
|2 строки |
|------|
|55 |
|------|
| <нуль> |
+------+


9.1.8. Другие выражения

Любое выражение может использоваться в качестве элемента возврата  -  литералы, предикаты, свойства,
функции, и все остальное.

Запрос.

СООТВЕТСТВИЕ ({имя:})
ВОЗВРАТИТЕ a.age> 30, "я - литерал", (a)-> ()

Возвращает предикат, литерал и вызов функции с выражением модели
параметр.

Таблица 9.8. Результат

+-----------------------------------------------------------------------------+
|a.age | "Я | (a)-> () |
|> 30 |literal" | |
|-----------------------------------------------------------------------------|
|1 строка |
|-----------------------------------------------------------------------------|
|true | "Я | [[Вершина [0] {имя: счастливый: "Да!", age:55}:KNOWS [0] {}, Вершина [1] |
| |literal" | {имя: "B"}], [Вершина [0] {имя: счастливый: "Да!", age:55}:BLOCKS [1] |
| | | {}, Вершина [1] {имя: "B"}]] |
+-----------------------------------------------------------------------------+


9.1.9. Уникальные результаты

ЯВНЫЙ получает только уникальные строки в зависимости от столбцов, которые были
выбранный, чтобы вывести.

Запрос.

СООТВЕТСТВИЕ ({имя:})-> (b)
ВОЗВРАТИТЕ ЯВНЫЙ b

Вершина по имени B возвращена запросом, но только однажды.

Таблица 9.9. Результат

+-----------------+
|b |
|-----------------|
|1 строка |
|-----------------|
|Node [1] {имя: "B"} |
+-----------------+


9.2. Порядок

9.2.1. Вершины порядка свойством
9.2.2. Вершины порядка разнообразными свойствами
9.2.3. Вершины порядка в порядке убывания
9.2.4. Упорядочивание НУЛЯ

Чтобы сортировать вывод, используйте ПОРЯДОК пунктом. Заметьте, что Вы не можете сортировать на
вершины или отношения, только на свойствах на них.

Рисунок 9.2. График

cypher-orderby-graph.svg


9.2.1. Вершины порядка свойством

ПОРЯДОК используется, чтобы сортировать вывод.

Запрос.

СООТВЕТСТВИЕ (n)
ВОЗВРАТИТЕ n
ПОРЯДОК n.name

Вершины возвращены, сортированы их именем.

Таблица 9.10. Результат

+-----------------------------------+
|n |
|-----------------------------------|
|3 строки |
|-----------------------------------|
|Node [0] {имя: age:34, length:170} |
|-----------------------------------|
|Node [1] {имя: "B", age:34} |
|-----------------------------------|
|Node [2] {имя: "C", age:32, length:185} |
+-----------------------------------+


9.2.2. Вершины порядка разнообразными свойствами

Вы можете упорядочить разнообразными свойствами, утверждая каждый идентификатор в ПОРЯДКЕ
пункт. Код сортирует результат первым идентификатором, перечисленным, и для
приравнивает значения, пойдите в следующее свойство в ПОРЯДКЕ пунктом, и так далее.

Запрос.

СООТВЕТСТВИЕ (n)
ВОЗВРАТИТЕ n
ПОРЯДОК n.age, n.name

Это возвращает вершины, сортированные сначала их возрастом, и затем их именем.

Таблица 9.11. Результат

+-----------------------------------+
|n |
|-----------------------------------|
|3 строки |
|-----------------------------------|
|Node [2] {имя: "C", age:32, length:185} |
|-----------------------------------|
|Node [0] {имя: age:34, length:170} |
|-----------------------------------|
|Node [1] {имя: "B", age:34} |
+-----------------------------------+


9.2.3. Вершины порядка в порядке убывания

Прибавляя DESC [ЗАКАНЧИВАЮЩИЙСЯ] после идентификатора к виду на, вид будет сделан
в обратном порядке.

Запрос.

СООТВЕТСТВИЕ (n)
ВОЗВРАТИТЕ n
ПОРЯДОК n.name DESC

Пример возвращает вершины, сортированные их именем reversely.

Таблица 9.12. Результат

+-----------------------------------+
|n |
|-----------------------------------|
|3 строки |
|-----------------------------------|
|Node [2] {имя: "C", age:32, length:185} |
|-----------------------------------|
|Node [1] {имя: "B", age:34} |
|-----------------------------------|
|Node [0] {имя: age:34, length:170} |
+-----------------------------------+


9.2.4. Упорядочивание НУЛЯ

Сортируя набор результатов, НУЛЬ будет всегда прибывать в конце набора результатов
для сортировки по возрастанию, и сначала делая убывающий вид.

Запрос.

СООТВЕТСТВИЕ (n)
ВОЗВРАТИТЕ n.length, n
ПОРЯДОК n.length

Вершины возвращены сортированные свойством длины, с вершиной без этого
последнее свойство.

Таблица 9.13. Результат

+--------------------------------------------+
|n.length|n |
|--------------------------------------------|
|3 строки |
|--------------------------------------------|
|170 |Node [0] {имя: age:34, length:170} |
|--------+-----------------------------------|
|185 |Node [2] {имя: "C", age:32, length:185} |
|--------+-----------------------------------|
| <нуль> |Node [1] {имя: "B", age:34} |
+--------------------------------------------+


9.3. Предел

9.3.1. Возврат сначала разделяется

ПРЕДЕЛ включает возврату только подмножеств полного результата.

Рисунок 9.3. График

cypher-limit-graph.svg


9.3.1. Возврат сначала разделяется

Чтобы возвратить подмножество результата, запускающегося с вершины, используют этот синтаксис:

Запрос.

СООТВЕТСТВИЕ (n)
ВОЗВРАТИТЕ n
ПРЕДЕЛ 3

Лучшие три элемента возвращены запросом в качестве примера.

Таблица 9.14. Результат

+-----------------+
|n |
|-----------------|
|3 строки |
|-----------------|
|Node [0] {имя: "D"} |
|-----------------|
|Node [1] {имя: "E"} |
|-----------------|
|Node [2] {имя:} |
+-----------------+


9.4. Пропустить

9.4.1. Пропустите сначала три
9.4.2. Возвратите средние два

ПРОПУСК включает возврату только подмножеств полного результата. При использовании ПРОПУСКА,
набор результатов получит обрезанным от вершины. Пожалуйста, заметьте, что никакие гарантии не
сделанный на порядке результата, если запрос не определяет ПОРЯДОК пунктом.

Рисунок 9.4. График

cypher-skip-graph.svg


9.4.1. Пропустите сначала три

Возвратить подмножество результата, запускающегося с четвертого результата, использование
следующий синтаксис:

Запрос.

СООТВЕТСТВИЕ (n)
ВОЗВРАТИТЕ n
ПОРЯДОК n.name
ПРОПУСТИТЕ 3

Первые три вершины пропущены, и только последние два возвращены в
результат.

Таблица 9.15. Результат

+-----------------+
|n |
|-----------------|
|2 строки |
|-----------------|
|Node [0] {имя: "D"} |
|-----------------|
|Node [1] {имя: "E"} |
+-----------------+


9.4.2. Возвратите средние два

Возвратить подмножество результата, запускающегося с куда-нибудь в середине, использовании
этот синтаксис:

Запрос.

СООТВЕТСТВИЕ (n)
ВОЗВРАТИТЕ n
ПОРЯДОК n.name
ПРОПУСТИТЕ 1
ПРЕДЕЛ 2

Возвращены две вершины с середины.

Таблица 9.16. Результат

+-----------------+
|n |
|-----------------|
|2 строки |
|-----------------|
|Node [3] {имя: "B"} |
|-----------------|
|Node [4] {имя: "C"} |
+-----------------+


9.5. С

9.5.1. Фильтр на совокупных функциональных результатах
9.5.2. Результаты вида перед использованием собираются на них
9.5.3. Предельное ветвление Вашего поиска пути

С С, Вы можете манипулировать последовательность результата прежде, чем она будет передана
следующие части запроса. Манипуляции могут иметь форму и/или номер
записи в наборе результатов.

Одно общее пользование С должно ограничить номер записей, которые тогда передают
на других пунктах СООТВЕТСТВИЯ. Комбинируя ПОРЯДОК и ПРЕДЕЛ, это возможно к
получите вершину X записей по некоторым критериям, и затем введите дополнительные данные от
график.

Другое использование должно фильтровать на агрегированных значениях. С используется, чтобы представить
агрегируется, который может тогда используемым в предикатах в ГДЕ. Они агрегируются
выражения создают новую привязку в результатах. С может также, точно так же как
ВОЗВРАТИТЕ, исказите выражения, которые введены в результаты, используя
псевдонимы как связывающий имя.

С также используется, чтобы разделить чтение из обновления графика. Каждая часть
запрос должен быть или только для чтения или только для записи. Идя от части записи
к части чтения переключатель должен быть сделан с С пунктом.

Рисунок 9.5. График

cypher-with-graph.svg


9.5.1. Фильтр на совокупных функциональных результатах

Агрегированные результаты должны пройти С пунктом, чтобы быть в состоянии фильтровать на.

Запрос.

СООТВЕТСТВИЕ (david {имя: "Дэвид"}) - (otherPerson)-> ()
С otherPerson, количество (*) AS foaf
ГДЕ foaf> 1
ВОЗВРАТИТЕ otherPerson

Человек соединялся с Дэвидом по крайней мере с больше чем одним выходом
отношение будет возвращено запросом.

Таблица 9.17. Результат

+----------------------+
|otherPerson |
|----------------------|
|1 строка |
|----------------------|
|Node [2] {имя: "Андерс"} |
+----------------------+


9.5.2. Результаты вида перед использованием собираются на них

Вы можете сортировать свои результаты прежде, чем передать их, чтобы собраться, таким образом сортируя
следующий набор.

Запрос.

СООТВЕТСТВИЕ (n)
С n
ПОРЯДОК n.name DESC ОГРАНИЧИВАЕТ 3
ВОЗВРАТ собирается (n.name)

Список имен людей в обратном порядке, ограниченный 3, в наборе.

Таблица 9.18. Результат

+-------------------------+
|collect (n.name) |
|-------------------------|
|1 строка |
|-------------------------|
| ["Эмиль", "Дэвид", "Ceasar"] |
+-------------------------+


9.5.3. Предельное ветвление Вашего поиска пути

Вы можете соответствовать пути, ограничить определенным числом, и затем соответствовать снова использование
те пути как основа Так же как любой номер подобных ограниченных поисков.

Запрос.

СООТВЕТСТВИЕ (n {имя: "Андерс"}) - (m)
С м.
ПОРЯДОК m.name DESC ОГРАНИЧИВАЕТ 1
СООТВЕТСТВИЕ (m) - (o)
ВОЗВРАТИТЕ o.name

Запускаясь в Андерсе, обнаружьте все вершины соответствия, упорядочьте по имени убывание и доберитесь
максимальный результат, затем обнаружьте все вершины соединенными с тем максимальным результатом, и
возвратите их имена.

Таблица 9.19. Результат

+---------+
|o.name |
|---------|
|2 строки |
|---------|
| "Андерс" |
|---------|
| "Босс" |
+---------+


9.6. Объединение

9.6.1. Объедините два запроса
9.6.2. Объедините два запроса и переместите копии

Объединение следствий разнообразных запросов сделано через оператора ОБЪЕДИНЕНИЯ.

Комбинирует результаты двух или больше запросов в единственный набор результатов это
включает все строки, которые принадлежат всем запросам в объединении.

Номер и имена столбцов должны быть идентичными во всех запросах
объединенный при использовании ОБЪЕДИНЕНИЯ.

Чтобы сохранить все строки результата, используйте ОБЪЕДИНЕНИЕ ВСЕ. Используя только ОБЪЕДИНЕНИЕ объединится и
переместите копии от набора результатов.

Рисунок 9.6. График

cypher-union-graph.svg


9.6.1. Объедините два запроса

Объединение следствий двух запросов сделано, используя ОБЪЕДИНЕНИЕ ВСЕ.

Запрос.

СООТВЕТСТВИЕ (n:Actor)
ВОЗВРАТИТЕ n.name имя AS
ОБЪЕДИНЕНИЕ ВСЕ СООТВЕТСТВИЕ (n:Movie)
ВОЗВРАТИТЕ n.title имя AS

Объединенный результат возвращен, включая копии.

Таблица 9.20. Результат

+-----------------+
|name |
|-----------------|
|4 строки |
|-----------------|
| "Энтони Хопкинс" |
|-----------------|
| "Хелен Миррен" |
|-----------------|
| "Хичкок" |
|-----------------|
| "Хичкок" |
+-----------------+


9.6.2. Объедините два запроса и переместите копии

Не включая ВСЕ в ОБЪЕДИНЕНИИ, копии удалены от объединенного
набор результатов

Запрос.

СООТВЕТСТВИЕ (n:Actor)
ВОЗВРАТИТЕ n.name имя AS
ОБЪЕДИНЕНИЕ
СООТВЕТСТВИЕ (n:Movie)
ВОЗВРАТИТЕ n.title имя AS

Объединенный результат возвращен, без копий.

Таблица 9.21. Результат

+-----------------+
|name |
|-----------------|
|3 строки |
|-----------------|
| "Энтони Хопкинс" |
|-----------------|
| "Хелен Миррен" |
|-----------------|
| "Хичкок" |
+-----------------+


9.7. Используя

9.7.1. Запрос используя индексировать подсказку
9.7.2. Запрос, использующий разнообразный, индексирует подсказки
9.7.3. Подсказывая сканирование метки

Если Вы не определяете явный пункт ЗАПУСКА, Код должен вывести где в
график, чтобы запустить Ваш запрос. Это сделано, смотря на ГДЕ пункт и
пункт СООТВЕТСТВИЯ и использование, которое индексирует информация, чтобы обнаружить полезное.

Это индексирует, не мог бы быть лучший выбор, хотя  -  иногда разнообразный индексирует
мог использоваться, и Код выбрал неправильный (от точки производительности
представление).

Вы можете вынудить Код, чтобы использовать определенную начальную точку при использовании ИСПОЛЬЗОВАНИЯ
пункт. Это вызывают, давая Код индексировать подсказка.

Если Ваш запрос соответствует значительные части индексирования, это могло бы быть более быстро, чтобы отсканировать
маркируйте и отфильтруйте вершины, которые не соответствуют. Чтобы сделать это, Вы можете использовать ИСПОЛЬЗУЯ
СКАНИРОВАНИЕ. Это вынудит Код, чтобы не использовать индексирование, которое, возможно, использовалось, и
вместо этого сделайте сканирование метки.

Замечание

Вы не можете использовать, индексируют подсказки, если у Вашего запроса есть пункт ЗАПУСКА.

9.7.1. Запрос используя индексировать подсказку

Чтобы запросить использование индексировать подсказки, используйте ИСПОЛЬЗУЯ, ИНДЕКСИРУЮТ.

Запрос.

СООТВЕТСТВИЕ (n:Swedish)
ИСПОЛЬЗУЯ ИНДЕКСИРУЮТ n:Swedish (фамилия)
ГДЕ n.surname = 'Тэйлор'
ВОЗВРАТИТЕ n

Результат запроса возвращен как обычно.

Таблица 9.22. Результат

+-----------------------------------------------------------+
|n |
|-----------------------------------------------------------|
|1 строка |
|-----------------------------------------------------------|
|Node [3] {имя: "Андрес", age:36, awesome:true, фамилия: "Тейлор"} |
+-----------------------------------------------------------+


9.7.2. Запрос, использующий разнообразный, индексирует подсказки

Чтобы запросить разнообразное использование индексируют подсказки, используют ИСПОЛЬЗУЯ, ИНДЕКСИРУЮТ.

Запрос.

СООТВЕТСТВИЕ (m:German)-> (n:Swedish)
ИСПОЛЬЗУЯ ИНДЕКСИРУЮТ m:German (фамилия)
ИСПОЛЬЗУЯ ИНДЕКСИРУЮТ n:Swedish (фамилия)
ГДЕ m.surname = 'Plantikow' И n.surname = 'Тэйлор'
ВОЗВРАТИТЕ м.

Результат запроса возвращен как обычно.

Таблица 9.23. Результат

+------------------------------------------+
|m |
|------------------------------------------|
|1 строка |
|------------------------------------------|
|Node [1] {имя: "Штефан", фамилия: "Plantikow"} |
+------------------------------------------+


9.7.3. Подсказывая сканирование метки

Если лучшая производительность должна иметься, сканируя все вершины в метке и затем
фильтруя на том наборе, используйте ИСПОЛЬЗУЯ СКАНИРОВАНИЕ.

Запрос.

СООТВЕТСТВИЕ (m:German)
ИСПОЛЬЗУЯ СКАНИРОВАНИЕ m:German
ГДЕ m.surname = 'Plantikow'
ВОЗВРАТИТЕ м.

Этот запрос делает свою работу, обнаруживая весь:German маркированные вершины и фильтрация
их свойством фамилии.

Таблица 9.24. Результат

+------------------------------------------+
|m |
|------------------------------------------|
|1 строка |
|------------------------------------------|
|Node [1] {имя: "Штефан", фамилия: "Plantikow"} |
+------------------------------------------+


Глава 10. Чтение Пунктов

Поток данных в пределах запроса Кода - неупорядоченная последовательность карт с
пары значения ключа  -  ряд возможной привязки между идентификаторами в
запрос и значения брали производную из базы данных. Этот набор усовершенствован и увеличен
последовательными частями запроса.

10.1. Соответствие

10.1.1. Введение
10.1.2. Основное обнаружение вершины
10.1.3. Основы отношения
10.1.4. Отношения подробно
10.1.5. Кратчайший путь

10.1.1. Введение

СООТВЕТСТВИЕ - основной способ получить данные от базы данных в текущий набор
из привязки.

Пункт СООТВЕТСТВИЯ позволяет Вам определять, что Код моделей будет искать в
база данных.

Вершины и отношения, которые уже известны на данном этапе, вызывают связанные
элементы рисунка. Код теперь попытается обнаружить неизвестные части модели.

Если СООТВЕТСТВИЕ - первый пункт в Вашем запросе, ничто не связано на данном этапе.
Код нуждается в начальных точках, чтобы сделать, это - сопоставление с образцом.

Если никакие связанные вершины не существуют, Код может отсканировать все вершины в базе данных, все вершины
с определенной меткой, или это может использовать, индексирует, чтобы быстро обнаружить соответствующее
начальные точки. Для получения дополнительной информации по индексирует, см. Раздел 13.1, "Индексирует".
Если Вы хотите использовать, индексируют подсказки, чтобы вынудить Код, чтобы использовать определенное, индексируют, читают
больше в Разделе 9.7, "Используя".

ГДЕ определяет модели СООТВЕТСТВИЯ более подробно. Предикаты - часть
описание модели, не фильтр, примененный после соответствия, сделано. Это
средства, что, ГДЕ должен всегда соединяться с пунктом СООТВЕТСТВИЯ, они принадлежат
к.

После обнаружения начальных точек  -  или при использовании сканирований, индексирует или уже связанный
точки  -  механизм выполнения будут использовать сопоставление с образцом, чтобы обнаружить соответствие
подграфы. Поскольку Код декларативен, он может изменить порядок их
операции. Предикаты в том, ГДЕ пункты могут быть оценены перед моделью
соответствие, во время сопоставления с образцом, или после обнаружения соответствий.

Подсказка

Чтобы понять модели, используемые в пункте СООТВЕТСТВИЯ, считайте Раздел 8.5,
"Модели".

Следующий график используется для примеров ниже:

Рисунок 10.1. График

cypher-match-graph.svg


10.1.2. Основное обнаружение вершины

10.1.2.1. Получите все вершины

Только определяя модель с единственной вершиной и никакими метками, всеми вершинами в
график будет возвращен.

Запрос.

СООТВЕТСТВИЕ (n)
ВОЗВРАТИТЕ n

Возвраты все вершины в базе данных.

Таблица 10.1. Результат

+-------------------------------------------------------------------+
|n |
|-------------------------------------------------------------------|
|7 строк |
|-------------------------------------------------------------------|
|Node [0] {имя: "Оливер Стоун"} |
|-------------------------------------------------------------------|
|Node [1] {имя: "Чарли Шин"} |
|-------------------------------------------------------------------|
|Node [2] {имя: "Мартеновский Блеск"} |
|-------------------------------------------------------------------|
|Node [3] {имя: "TheAmericanPresident", заголовок: "Американский президент"} |
|-------------------------------------------------------------------|
|Node [4] {имя: "WallStreet", заголовок: "Уолл-стрит"} |
|-------------------------------------------------------------------|
|Node [5] {имя: "Роб Райнер"} |
|-------------------------------------------------------------------|
|Node [6] {имя: "Майкл Дуглас"} |
+-------------------------------------------------------------------+


10.1.2.2. Получите все вершины с меткой

Получение всех вершин с меткой на них сделано с единственной моделью вершины где
у вершины есть метка на этом.

Запрос.

СООТВЕТСТВИЕ (movie:Movie)
ВОЗВРАТИТЕ фильм

Возвраты все фильмы в базе данных.

Таблица 10.2. Результат

+-------------------------------------------------------------------+
|movie |
|-------------------------------------------------------------------|
|2 строки |
|-------------------------------------------------------------------|
|Node [3] {имя: "TheAmericanPresident", заголовок: "Американский президент"} |
|-------------------------------------------------------------------|
|Node [4] {имя: "WallStreet", заголовок: "Уолл-стрит"} |
+-------------------------------------------------------------------+


10.1.2.3. Связанные вершины

Символ - средства имели отношение к, без отношения, чтобы ввести или направление
отношение.

Запрос.

СООТВЕТСТВИЕ (направляющее устройство {называют:' Оливера Стоуна'}) - (фильм)
ВОЗВРАТИТЕ movie.title

Возвраты все фильмы направлены Оливером Стоуном.

Таблица 10.3. Результат

+-------------+
|movie.title |
|-------------|
|1 строка |
|-------------|
| "Уолл-стрит" |
+-------------+


10.1.2.4. Соответствие с метками

Чтобы ограничить Вашу модель с метками на вершинах, Вы прибавляете это к своей модели
вершины, используя синтаксис метки.

Запрос.

СООТВЕТСТВИЕ (charlie:Person {называют:' Чарли Шина'}) - (movie:Movie)
ВОЗВРАТИТЕ фильм

Возвратите любые вершины, соединенные с Человеком Чарли, которые маркированы Фильм.

Таблица 10.4. Результат

+----------------------------------------------+
|movie |
|----------------------------------------------|
|1 строка |
|----------------------------------------------|
|Node [4] {имя: "WallStreet", заголовок: "Уолл-стрит"} |
+----------------------------------------------+


10.1.3. Основы отношения

10.1.3.1. Исходящие отношения

Когда направление отношения интересно, его показывают при использовании->
или <-, как это:

Запрос.

СООТВЕТСТВИЕ (мартеновский {называют:' Мартина Шина'})-> (фильм)
ВОЗВРАТИТЕ movie.title

Вершины возвратов соединялись с Мартином исходящими отношениями.

Таблица 10.5. Результат

+------------------------+
|movie.title |
|------------------------|
|2 строки |
|------------------------|
| "Уолл-стрит" |
|------------------------|
| "Американский президент" |
+------------------------+


10.1.3.2. Направленные отношения и идентификатор

Если идентификатор необходим, любой для того, чтобы фильтровать на свойствах
отношение, или возвратить отношение, это - то, как Вы представляете
идентификатор.

Запрос.

СООТВЕТСТВИЕ (мартеновский {называют:' Мартина Шина'}) - [r]-> (фильм)
ВОЗВРАТИТЕ r

Возвраты все исходящие отношения от Мартина.

Таблица 10.6. Результат

+--------------+
|r |
|--------------|
|2 строки |
|--------------|
|:ACTED_IN [1] {} |
|--------------|
|:ACTED_IN [3] {} |
+--------------+


10.1.3.3. Соответствие типом отношения

Когда Вы знаете тип отношения, Вы хотите соответствовать на, Вы можете определить это
использование двоеточия вместе с типом отношения.

Запрос.

СООТВЕТСТВИЕ (wallstreet {заголовок:'Wall улица'}) <-[:ACTED_IN] - (агент)
ВОЗВРАТИТЕ агента

Вершины возвратов это Уолл-стрит ACTED_IN.

Таблица 10.7. Результат

+-------------------------------+
|actor |
|-------------------------------|
|3 строки |
|-------------------------------|
|Node [1] {имя: "Чарли Шин"} |
|-------------------------------|
|Node [2] {имя: "Мартеновский Блеск"} |
|-------------------------------|
|Node [6] {имя: "Майкл Дуглас"} |
+-------------------------------+


10.1.3.4. Соответствие разнообразными типами отношения

Чтобы соответствовать на одном из разнообразных типов, Вы можете определить это, объединяя их в цепочку
вместе с символом канала |.

Запрос.

СООТВЕТСТВИЕ (wallstreet {заголовок:'Wall улица'}) <-[:ACTED_IN |:DIRECTED] - (человек)
ВОЗВРАТИТЕ человека

Вершины возвратов с ACTED_IN или НАПРАВЛЕННЫМ отношением в Уолл-стрит.

Таблица 10.8. Результат

+-------------------------------+
|person |
|-------------------------------|
|4 строки |
|-------------------------------|
|Node [0] {имя: "Оливер Стоун"} |
|-------------------------------|
|Node [1] {имя: "Чарли Шин"} |
|-------------------------------|
|Node [2] {имя: "Мартеновский Блеск"} |
|-------------------------------|
|Node [6] {имя: "Майкл Дуглас"} |
+-------------------------------+


10.1.3.5. Соответствие отношением вводит и использует идентификатор

Если Вы оба хотите представить идентификатор, чтобы содержать отношение, и
определите тип отношения, Вы хотите, только прибавляете их обоих, как это.

Запрос.

СООТВЕТСТВИЕ (wallstreet {заголовок:'Wall улица'}) <-[r:ACTED_IN] - (агент)
ВОЗВРАТИТЕ r

Вершины возвратов это Уолл-стрит ACTED_IN.

Таблица 10.9. Результат

+--------------+
|r |
|--------------|
|3 строки |
|--------------|
|:ACTED_IN [0] {} |
|--------------|
|:ACTED_IN [1] {} |
|--------------|
|:ACTED_IN [2] {} |
+--------------+


10.1.4. Отношения подробно

10.1.4.1. Отношение вводит с редкими символами

Когда-то у Вашей базы данных будут типы с символами небуквы, или с
пробелы в них. Используйте `(обратная галочка), чтобы заключить их в кавычки.

Запрос.

СООТВЕТСТВИЕ (n {называют:' Роба Райнера'}) - [r: `ВВЕДИТЕ, У КОТОРОГО ЕСТЬ ПРОСТРАНСТВО В IT`]-> ()
ВОЗВРАТИТЕ r

Возвращает отношение типа с пробелами в этом.

Таблица 10.10. Результат

+-------------------------------+
|r |
|-------------------------------|
|1 строка |
|-------------------------------|
|:TYPE, У КОТОРОГО ЕСТЬ ПРОСТРАНСТВО В IT [8] {} |
+-------------------------------+


10.1.4.2. Разнообразные отношения

Отношения могут быть выражены при использовании разнообразных операторов в форме ()-
(), или они могут быть представлены в виде строки вместе, как это:

Запрос.

СООТВЕТСТВИЕ (charlie {называют:' Чарли Шина'}) - [:ACTED_IN]-> (фильм) <-[:DIRECTED]-> (направляющее устройство)
ВОЗВРАТИТЕ charlie, фильм, направляющее устройство

Возвращает эти три вершины в пути.

Таблица 10.11. Результат

+-----------------------------------------------------------------------------+
|charlie |movie |director |
|-----------------------------------------------------------------------------|
|1 строка |
|-----------------------------------------------------------------------------|
|Node [1] {имя: "Charlie|Node [4] |Node [0] {имя: "Оливер |
|Sheen"} | {имя: "WallStreet", заголовок: "Обнесите стеной |Stone"} |
| |Street"} | |
+-----------------------------------------------------------------------------+


10.1.4.3. Отношения переменной длины

Вершины, которые являются переменным номером транзитных участков relationship→node далеко, могут быть найдены
использование следующего синтаксиса: - [:TYPE*minHops.. maxHops]->. minHops и maxHops
являются дополнительными и значение по умолчанию к 1 и бесконечность соответственно. Когда никакие границы не
учитывая точки может быть опущен.

Запрос.

СООТВЕТСТВИЕ (мартеновский {имя: "Мартеновский Блеск"}) - [:ACTED_IN*1.. 2] - (x)
ВОЗВРАТИТЕ x

Вершины возвратов, которые являются 1 или 2 отношениями далеко от Мартина.

Таблица 10.12. Результат

+-------------------------------------------------------------------+
|x |
|-------------------------------------------------------------------|
|5 строк |
|-------------------------------------------------------------------|
|Node [4] {имя: "WallStreet", заголовок: "Уолл-стрит"} |
|-------------------------------------------------------------------|
|Node [1] {имя: "Чарли Шин"} |
|-------------------------------------------------------------------|
|Node [6] {имя: "Майкл Дуглас"} |
|-------------------------------------------------------------------|
|Node [3] {имя: "TheAmericanPresident", заголовок: "Американский президент"} |
|-------------------------------------------------------------------|
|Node [6] {имя: "Майкл Дуглас"} |
+-------------------------------------------------------------------+


10.1.4.4. Идентификатор отношения в отношениях переменной длины

Когда соединение между двумя вершинами имеет переменную длину, отношение
идентификатор становится набором отношений.

Запрос.

СООТВЕТСТВИЕ (агент {называют:' Чарли Шина'}) - [r:ACTED_IN*2] - (co_actor)
ВОЗВРАТИТЕ r

Запрос возвращает набор отношений.

Таблица 10.13. Результат

+-------------------------------+
|r |
|-------------------------------|
|2 строки |
|-------------------------------|
| [:ACTED_IN [0] {}:ACTED_IN [1] {}] |
|-------------------------------|
| [:ACTED_IN [0] {}:ACTED_IN [2] {}] |
+-------------------------------+


10.1.4.5. Соответствие со свойствами на пути переменной длины

Отношение переменной длины со свойствами, определенными на в этом, означает что все
у отношений в пути должен быть набор свойств к данному значению. В
этот запрос, есть два пути между Блеском Charile и его Блеском папы Мартин.
Одно из включения "блокированного" отношения и другого не делает. В этом
случай мы сначала изменяем исходный график при использовании следующего запроса, чтобы добавиться
"блокированные" и "разблокированные" отношения:

СООТВЕТСТВИЕ (charlie:Person {называют:' Чарли Шина'}), (martin:Person {называют:' Мартина Шина'}),
СОЗДАЙТЕ (charlie) - [:X {blocked:false}]-> (:Unblocked) <-[:X {blocked:false}] - (мартеновский)
СОЗДАЙТЕ (charlie) - [:X {blocked:true}]-> (:Blocked) <-[:X {blocked:false}] - (мартеновский);

Это означает, что мы начинаем со следующим графиком:

match-match-with-properties-on-a-variable-length-path.preparation-graph.svg

Запрос.

СООТВЕТСТВУЙТЕ p = (charlie:Person) - [* {blocked:false}] - (martin:Person)
ГДЕ charlie.name = 'Чарли Шин' И martin.name = 'Мартеновский Блеск'
ВОЗВРАТИТЕ p

Возвращает пути между Чарли и Мартеновским Блеском, где все отношения имеют
блокированный набор свойств ко ЛЖИ.

Таблица 10.14. Результат

+-----------------------------------------------------------------------------+
|p |
|-----------------------------------------------------------------------------|
|1 строка |
|-----------------------------------------------------------------------------|
| [Вершина [1] {имя: "Чарли Шин"}:X [12] {blocked:false}, Вершина [9] {}:X [13] |
| {blocked:false}, Вершина [2] {имя: "Мартеновский Блеск"}] |
+-----------------------------------------------------------------------------+


10.1.4.6. Нулевые пути длины

Используя пути переменной длины, у которых есть нуль нижней границы, означает это два
идентификаторы могут указать на ту же самую вершину. Если расстояние между двумя вершинами
нуль, они - по определению та же самая вершина. Заметьте это, соответствуя нулевую длину
пути результат могут содержать соответствие, соответствуя на типе отношения
не в использовании.

Запрос.

СООТВЕТСТВИЕ (wallstreet:Movie {заголовок:'Wall улица'}) - [*0.. 1] - (x)
ВОЗВРАТИТЕ x

Возвраты все вершины, которые являются нулем или отношениями далеко от Уолл-стрит.

Таблица 10.15. Результат

+----------------------------------------------+
|x |
|----------------------------------------------|
|5 строк |
|----------------------------------------------|
|Node [4] {имя: "WallStreet", заголовок: "Уолл-стрит"} |
|----------------------------------------------|
|Node [1] {имя: "Чарли Шин"} |
|----------------------------------------------|
|Node [2] {имя: "Мартеновский Блеск"} |
|----------------------------------------------|
|Node [6] {имя: "Майкл Дуглас"} |
|----------------------------------------------|
|Node [0] {имя: "Оливер Стоун"} |
+----------------------------------------------+


10.1.4.7. Названный путем

Если Вы хотите возвратить или фильтровать на пути в Вашем графике модели, Вы можете a
представьте именованный путь.

Запрос.

СООТВЕТСТВУЙТЕ p = (michael {называют:' Майкла Дугласа'})-> ()
ВОЗВРАТИТЕ p

Возвращает эти два пути, запускающиеся от Майкла.

Таблица 10.16. Результат

+-----------------------------------------------------------------------------+
|p |
|-----------------------------------------------------------------------------|
|2 строки |
|-----------------------------------------------------------------------------|
| [Вершина [6] {имя: "Майкл Дуглас"}:ACTED_IN [2] {}, Вершина [4] |
| {имя: "WallStreet", заголовок: "Уолл-стрит"}] |
|-----------------------------------------------------------------------------|
| [Вершина [6] {имя: "Майкл Дуглас"}:ACTED_IN [4] {}, Вершина [3] |
| {имя: "TheAmericanPresident", заголовок: "Американский президент"}] |
+-----------------------------------------------------------------------------+


10.1.4.8. Соответствие на связанном отношении

Когда Ваша модель содержит связанное отношение, и ту модель отношения
не определяет направление, Код попытается соответствовать отношение в обоих
направления.

Запрос.

СООТВЕТСТВИЕ (a) - [r] - (b)
ГДЕ идентификатор (r) = 0
ВОЗВРАТИТЕ a, b

Это возвращает две соединенных вершины, однажды как вершина запуска, и однажды как
конечный узел.

Таблица 10.17. Результат

+-----------------------------------------------------------------------------+
|a |b |
|-----------------------------------------------------------------------------|
|2 строки |
|-----------------------------------------------------------------------------|
|Node [1] {имя: "Чарли Шин"} |Node [4] {имя: "WallStreet", заголовок: "Стена |
| |Street"} |
|--------------------------------------+--------------------------------------|
|Node [4] {имя: "WallStreet", заголовок: "Обнесите стеной |Node [1] {имя: "Чарли Шин"} |
|Street"} | |
+-----------------------------------------------------------------------------+


10.1.5. Кратчайший путь

10.1.5.1. Единственный кратчайший путь

Обнаружение единственного кратчайшего пути между двумя вершинами столь же легко как использование
функция shortestPath. Это сделано как это:

Запрос.

СООТВЕТСТВИЕ (martin:Person {имя: "Мартеновский Блеск"}), (oliver:Person {имя: "Оливер Стоун"}),
  p = shortestPath ((мартеновский) - [*.. 15] - (oliver))
ВОЗВРАТИТЕ p

Это означает: обнаружьте единственный кратчайший путь между двумя вершинами, пока путь
максимально 15 отношений долго. В круглых скобках Вы определяете единственное
ссылка пути  -  запускающаяся вершина, соединяющееся отношение и конец
вершина. Характеристики, описывающие отношение как тип отношения, максимальный
транзитные участки и направление все используются, обнаруживая кратчайший путь. Вы можете также
отметьте путь как дополнительный.

Таблица 10.18. Результат

+-----------------------------------------------------------------------------+
|p |
|-----------------------------------------------------------------------------|
|1 строка |
|-----------------------------------------------------------------------------|
| [Вершина [2] {имя: "Мартеновский Блеск"}:ACTED_IN [1] {}, Вершина [4] |
| {имя: "WallStreet", заголовок: "Уолл-стрит"}:DIRECTED [5] {}, Вершина [0] {имя: "Оливер |
|Stone"}] |
+-----------------------------------------------------------------------------+


10.1.5.2. Все кратчайшие пути

Новые месторождения все кратчайшие пути между двумя вершинами.

Запрос.

СООТВЕТСТВИЕ (martin:Person {имя: "Мартеновский Блеск"}), (michael:Person {имя: "Майкл Дуглас"}),
  p = allShortestPaths ((мартеновский) - [*] - (michael))
ВОЗВРАТИТЕ p

Обнаруживает эти два кратчайших пути между Мартином и Майклом.

Таблица 10.19. Результат

+-----------------------------------------------------------------------------+
|p |
|-----------------------------------------------------------------------------|
|2 строки |
|-----------------------------------------------------------------------------|
| [Вершина [2] {имя: "Мартеновский Блеск"}:ACTED_IN [3] {}, Вершина [3] |
| {имя: "TheAmericanPresident", заголовок: "Американский президент"}:ACTED_IN [4] |
| {}, Вершина [6] {имя: "Майкл Дуглас"}] |
|-----------------------------------------------------------------------------|
| [Вершина [2] {имя: "Мартеновский Блеск"}:ACTED_IN [1] {}, Вершина [4] |
| {имя: "WallStreet", заголовок: "Уолл-стрит"}:ACTED_IN [2] {}, Вершина [6] {имя: "Майкл |
|Douglas"}] |
+-----------------------------------------------------------------------------+


10.2. Дополнительное Соответствие

10.2.1. Введение
10.2.2. Отношение
10.2.3. Свойства на дополнительных элементах
10.2.4. Дополнительное введенное и именованное отношение

10.2.1. Введение

ДОПОЛНИТЕЛЬНОЕ СООТВЕТСТВИЕ соответствует модели против Вашей базы данных графика, точно так же как СООТВЕТСТВИЕ
делает. Разность - то, что, если никакие соответствия не найдены, ДОПОЛНИТЕЛЬНОЕ СООТВЕТСТВИЕ будет использовать
ОБНУЛЯЕТ для того, чтобы пропустить части модели. ДОПОЛНИТЕЛЬНОЕ СООТВЕТСТВИЕ можно было рассмотреть
Код, эквивалентный из внешнего соединения в SQL.

Или целая модель является соответствующей, или ничто не является соответствующим. Помните это ГДЕ
часть описания модели, и предикаты рассмотрят в то время как
поиск соответствий, не после. Это имеет значение особенно в случае разнообразного
(ДОПОЛНИТЕЛЬНЫЕ) пункты СООТВЕТСТВИЯ, где крайне важно поместить ГДЕ вместе с
СООТВЕТСТВИЕ это принадлежит.

Подсказка

Чтобы понять модели, используемые в ДОПОЛНИТЕЛЬНОМ пункте СООТВЕТСТВИЯ, считайте Раздел 8.5,
"Модели".

Следующий график используется для примеров ниже:

Рисунок 10.2. График

cypher-optionalmatch-graph.svg


10.2.2. Отношение

Если отношение является дополнительным, используйте ДОПОЛНИТЕЛЬНЫЙ пункт СООТВЕТСТВИЯ. Это подобно
к как SQL внешние работы соединения. Если отношение там, оно возвращено. Если
это не, НУЛЬ возвращен в, это - место.

Запрос.

СООТВЕТСТВИЕ (a:Movie {заголовок: 'Уолл-стрит'})
ДОПОЛНИТЕЛЬНОЕ СООТВЕТСТВИЕ (a)-> (x)
ВОЗВРАТИТЕ x

НУЛЬ возвратов, так как у вершины нет никаких исходящих отношений.

Таблица 10.20. Результат

+------+
|x |
|------|
|1 строка |
|------|
| <нуль> |
+------+


10.2.3. Свойства на дополнительных элементах

Возврат свойства от дополнительного элемента, который является НУЛЕМ, также возвратится
НУЛЬ.

Запрос.

СООТВЕТСТВИЕ (a:Movie {заголовок: 'Уолл-стрит'})
ДОПОЛНИТЕЛЬНОЕ СООТВЕТСТВИЕ (a)-> (x)
ВОЗВРАТИТЕ x, x.name

Возвращает элемент x (НУЛЬ в этом запросе), и НУЛЬ как его имя.

Таблица 10.21. Результат

+-------------+
|x |x.name |
|-------------|
|1 строка |
|-------------|
| <нуль> | <нуль> |
+-------------+


10.2.4. Дополнительное введенное и именованное отношение

Так же, как с нормальным отношением, Вы можете решить, какой идентификатор это идет
в, и в каком типе отношения Вы нуждаетесь.

Запрос.

СООТВЕТСТВИЕ (a:Movie {заголовок: 'Уолл-стрит'})
ДОПОЛНИТЕЛЬНОЕ СООТВЕТСТВИЕ (a) - [r:ACTS_IN]-> ()
ВОЗВРАТИТЕ r

Это возвращает вершину, и НУЛЬ, так как у вершины нет никакого выхода ACTS_IN
отношения.

Таблица 10.22. Результат

+------+
|r |
|------|
|1 строка |
|------|
| <нуль> |
+------+


10.3. Где

10.3.1. Основное использование
10.3.2. Регулярные выражения
10.3.3. Используя модели, в ГДЕ
10.3.4. Наборы
10.3.5. Отсутствие свойств и значений

ГДЕ не пункт в своем собственном праве  -  скорее это - часть СООТВЕТСТВИЯ, ДОПОЛНИТЕЛЬНОГО
СООТВЕТСТВИЕ, ЗАПУСТИТЕ и С.

В случае С и ЗАПУСКАЮТСЯ, ГДЕ просто фильтрует результаты.

Для СООТВЕТСТВИЯ и ДОПОЛНИТЕЛЬНОГО СООТВЕТСТВИЯ с другой стороны, ГДЕ прибавляет ограничения к
модели описаны. Это не должно быть замечено как фильтр после того, как соответствие
обработанный начисто.

Замечание

В случае разнообразных (ДОПОЛНИТЕЛЬНЫХ) пунктов СООТВЕТСТВИЯ, предиката в том, ГДЕ
всегда часть моделей в прямо предыдущем СООТВЕТСТВИИ. Оба результата и
производительность может быть плотно сжата, если, КУДА помещен в неправильном пункте СООТВЕТСТВИЯ.

Рисунок 10.3. График

cypher-where-graph.svg


10.3.1. Основное использование

10.3.1.1. Логические операции

Вы можете использовать ожидаемые булевы операторы И и ИЛИ, и также булево
функция НЕТ. См. Раздел 8.7, “Работающий с НУЛЕМ” для получения дополнительной информации о как
это работает с НУЛЕМ.

Запрос.

СООТВЕТСТВИЕ (n)
ГДЕ n.name = 'Питер' КСОР (n.age <30 И n.name = "Тобиас") ИЛИ НЕ (n.name = "Тобиас" ИЛИ
  n.name = "Питер")
ВОЗВРАТИТЕ n

Этот запрос показывает, как могут использоваться булевы операторы.

Таблица 10.23. Результат

+------------------------------------------+
|n |
|------------------------------------------|
|3 строки |
|------------------------------------------|
|Node [0] {имя: "Тобиас", age:25} |
|------------------------------------------|
|Node [1] {имя: "Питер", age:34} |
|------------------------------------------|
|Node [2] {имя: "Андрес", age:36, пояс: "белый цвет"} |
+------------------------------------------+


10.3.1.2. Фильтр на метке вершины

Чтобы фильтровать вершины по метке, запишите предикат метки после ГДЕ использование ключевого слова
ГДЕ n:foo.

Запрос.

СООТВЕТСТВИЕ (n)
ГДЕ n:Swedish
ВОЗВРАТИТЕ n

Вершина "Андреса" будет возвращена.

Таблица 10.24. Результат

+------------------------------------------+
|n |
|------------------------------------------|
|1 строка |
|------------------------------------------|
|Node [2] {имя: "Андрес", age:36, пояс: "белый цвет"} |
+------------------------------------------+


10.3.1.3. Фильтр на свойстве вершины

Чтобы фильтровать на свойстве, запишите свой пункт после ГДЕ ключевое слово. Фильтрация
на отношении свойства работает только тот же самый путь.

Запрос.

СООТВЕТСТВИЕ (n)
ГДЕ n.age <30
ВОЗВРАТИТЕ n

Вершина "Тобиаса" будет возвращена.

Таблица 10.25. Результат

+-----------------------------+
|n |
|-----------------------------|
|1 строка |
|-----------------------------|
|Node [0] {имя: "Тобиас", age:25} |
+-----------------------------+


10.3.1.4. Свойство существует

Чтобы только включать вершины/отношения, у которых есть свойство, используйте ()
функционируйте и только выпишите идентификатор и свойство, к которому Вы ожидаете это
иметь.

Запрос.

СООТВЕТСТВИЕ (n)
ГДЕ ИМЕЕТ (n.belt)
ВОЗВРАТИТЕ n

Вершина по имени "Андрес" возвращена.

Таблица 10.26. Результат

+------------------------------------------+
|n |
|------------------------------------------|
|1 строка |
|------------------------------------------|
|Node [2] {имя: "Андрес", age:36, пояс: "белый цвет"} |
+------------------------------------------+


10.3.2. Регулярные выражения

10.3.2.1. Регулярные выражения

Вы можете соответствовать на регулярных выражениях при использовании = ~ "regexp", как это:

Запрос.

СООТВЕТСТВИЕ (n)
ГДЕ n.name = ~ 'Tob. *'
ВОЗВРАТИТЕ n

Вершина "Тобиаса" будет возвращена.

Таблица 10.27. Результат

+-----------------------------+
|n |
|-----------------------------|
|1 строка |
|-----------------------------|
|Node [0] {имя: "Тобиас", age:25} |
+-----------------------------+


10.3.2.2. Выход в регулярных выражениях

Если Вы нуждаетесь в наклонной черте вправо в Вашем регулярном выражении, выходите из него.
Помните, что наклонной черты влево нужно оставить в строковых литералах

Запрос.

СООТВЕТСТВИЕ (n)
ГДЕ n.name = ~ 'Some\/thing'
ВОЗВРАТИТЕ n

Никакие вершины не соответствуют это регулярное выражение.

Таблица 10.28. Результат

+--------------+
|n |
|--------------|
|0 строк |
|--------------|
| (освободите результат), |
+--------------+


10.3.2.3. Нечувствительные к регистру регулярные выражения

Предварительно ожидая регулярное выражение с (? i), целое выражение становится
нечувствительный к регистру.

Запрос.

СООТВЕТСТВИЕ (n)
ГДЕ n.name = ~' (? i) ANDR. *'
ВОЗВРАТИТЕ n

Вершина с именем "Андрес" возвращена.

Таблица 10.29. Результат

+------------------------------------------+
|n |
|------------------------------------------|
|1 строка |
|------------------------------------------|
|Node [2] {имя: "Андрес", age:36, пояс: "белый цвет"} |
+------------------------------------------+


10.3.3. Используя модели, в ГДЕ

10.3.3.1. Фильтр на моделях

Модели - выражения в Коде, выражения, которые возвращают набор
пути. Выражения набора - также предикаты  -  пустой набор
представляет ложь, и непустое представляет истину.

Так, модели не только выражения, они - также предикаты. Единственное
ограничение к Вашей модели - то, что Вы должны быть в состоянии выразить ее в единственном
путь. Вы не можете использовать запятые между разнообразными путями как Вы, делают в СООТВЕТСТВИИ. Вы
может достигнуть того же самого эффекта, комбинируя разнообразные модели с И.

Заметьте, что Вы не можете представить новые идентификаторы здесь. Хотя это могло бы смотреть
очень подобный моделям СООТВЕТСТВИЯ, ГДЕ пункт - все об устранении
соответствующие подграфы. СООТВЕТСТВИЕ (a) - [*]-> (b) очень отличается от ГДЕ (a) - [*]->
(b); первое произведет подграф для каждого пути, который это может обнаружить между a и
b, и последний устранит любые соответствующие подграфы, где a и b не делают
имейте направленную цепочку отношения между ними.

Запрос.

СООТВЕТСТВИЕ (tobias {имя: 'Тобиас'}), (другие)
ГДЕ others.name В ['Андрес ', Питер'] И (tobias) <-(другие)
ВОЗВРАТИТЕ других

Возвращены вершины, у которых есть исходящее отношение к вершине "Тобиаса".

Таблица 10.30. Результат

+------------------------------------------+
|others |
|------------------------------------------|
|1 строка |
|------------------------------------------|
|Node [2] {имя: "Андрес", age:36, пояс: "белый цвет"} |
+------------------------------------------+


10.3.3.2. Фильтр на использовании моделей НЕТ

НЕ функция может использоваться, чтобы исключить модель.

Запрос.

СООТВЕТСТВИЕ (люди), (peter {имя: 'Питер'})
ГДЕ НЕ (люди)-> (peter)
ВОЗВРАТИТЕ людей

Вершины, у которых нет исходящего отношения к вершине "Питера",
возвращенный.

Таблица 10.31. Результат

+-----------------------------+
|persons |
|-----------------------------|
|2 строки |
|-----------------------------|
|Node [0] {имя: "Тобиас", age:25} |
|-----------------------------|
|Node [1] {имя: "Питер", age:34} |
+-----------------------------+


10.3.3.3. Фильтр на моделях со свойствами

Вы можете также прибавить свойства к своим моделям:

Запрос.

СООТВЕТСТВИЕ (n)
ГДЕ (n) - [:KNOWS] - ({называют:' Тобиаса'}),
ВОЗВРАТИТЕ n

Новые месторождения все вершины, которые имеют, ЗНАЮТ отношение к вершине с именем Тобиас.

Таблица 10.32. Результат

+------------------------------------------+
|n |
|------------------------------------------|
|1 строка |
|------------------------------------------|
|Node [2] {имя: "Андрес", age:36, пояс: "белый цвет"} |
+------------------------------------------+


10.3.3.4. Фильтрация на типе отношения

Вы можете поместить точное отношение, вводят модель СООТВЕТСТВИЯ, но иногда Вас
хочу быть в состоянии сделать более усовершенствованную фильтрацию на типе. Вы можете использовать
специальное свойство TYPE, чтобы сравнить тип с чем-то еще. В этом примере,
запрос делает сравнение регулярного выражения с именем
тип отношения.

Запрос.

СООТВЕТСТВИЕ (n) - [r]-> ()
ГДЕ n.name =' Андрес' И тип (r) = ~ 'K. *'
ВОЗВРАТИТЕ r

Это возвращает отношения, у которого есть тип, имя которого запускается с K.

Таблица 10.33. Результат

+-----------+
|r |
|-----------|
|2 строки |
|-----------|
|:KNOWS [0] {} |
|-----------|
|:KNOWS [1] {} |
+-----------+


10.3.4. Наборы

10.3.4.1. В операторе

Чтобы проверить, существует ли элемент в наборе, Вы можете использовать В операторе.

Запрос.

СООТВЕТСТВИЕ (a)
ГДЕ a.name В ["Питер", "Тобиас"]
ВОЗВРАТИТЕ a

Этот запрос показывает, как проверить, существует ли свойство в литеральном наборе.

Таблица 10.34. Результат

+-----------------------------+
|a |
|-----------------------------|
|2 строки |
|-----------------------------|
|Node [0] {имя: "Тобиас", age:25} |
|-----------------------------|
|Node [1] {имя: "Питер", age:34} |
+-----------------------------+


10.3.5. Отсутствие свойств и значений

10.3.5.1. Значение по умолчанию ко лжи, если свойство пропускает

Как отсутствие свойств находят значение величины к НУЛЮ, comparision в примере будет
найдите значение величины ко ЛЖИ для вершин без свойства пояса.

Запрос.

СООТВЕТСТВИЕ (n)
ГДЕ n.belt = 'белый цвет'
ВОЗВРАТИТЕ n

Только вершины со свойством пояса возвращены.

Таблица 10.35. Результат

+------------------------------------------+
|n |
|------------------------------------------|
|1 строка |
|------------------------------------------|
|Node [2] {имя: "Андрес", age:36, пояс: "белый цвет"} |
+------------------------------------------+


10.3.5.2. Значение по умолчанию к истине, если свойство пропускает

Если Вы хотите сравнить свойство на элементе графика, но только если это существует,
Вы можете сравнить свойство и со значением, которое Вы ищете и
НУЛЬ, как:

Запрос.

СООТВЕТСТВИЕ (n)
КУДА n.belt = 'белый цвет' ИЛИ n.belt НУЛЬ IS ВОЗВРАЩАЮТ n
ПОРЯДОК n.name

Это возвращает все вершины, даже те без свойства пояса.

Таблица 10.36. Результат

+------------------------------------------+
|n |
|------------------------------------------|
|3 строки |
|------------------------------------------|
|Node [2] {имя: "Андрес", age:36, пояс: "белый цвет"} |
|------------------------------------------|
|Node [1] {имя: "Питер", age:34} |
|------------------------------------------|
|Node [0] {имя: "Тобиас", age:25} |
+------------------------------------------+


10.3.5.3. Фильтр на НУЛЕ

Иногда Вы могли бы хотеть протестировать, если значение или идентификатор - НУЛЬ. Это
сделанный точно так же, как SQL делает это, с НУЛЕМ IS. Также как SQL, отрицательная величина - IS НЕТ
НУЛЬ, хотя НЕ (НУЛЬ IS x) также работает.

Запрос.

СООТВЕТСТВИЕ (человек)
КУДА person.name = 'Питер' И person.belt НУЛЬ IS ВОЗВРАЩАЮТ человека

Возвращены вершины, с которыми не соединен Тобиас.

Таблица 10.37. Результат

+----------------------------+
|person |
|----------------------------|
|1 строка |
|----------------------------|
|Node [1] {имя: "Питер", age:34} |
+----------------------------+


10.4. Запустить

10.4.1. Получите вершину, или отношение от индексируют
10.4.2. Получите вершину или отношение идентификатором
10.4.3. Получите разнообразными или все вершины

Каждый запрос описывает модель, и в той модели можно иметь разнообразный
начальные точки. Начальная точка - отношение или вершина где модель
привязан. Вы можете или представить начальные точки идентификатором, или индексируют
поиски. Заметьте, что попытка использовать индексирование, которое не существует, генерирует
погрешность.

Замечание

ЗАПУСК является дополнительным. Если Вы не определите явные начальные точки, то Код будет
попытайтесь вывести начальные точки из своего запроса. Это сделано основанное на вершине
метки и предикаты делились без остатка в Вашем запросе. См. Главу 13, Схему для больше
информация. Вообще, пункт ЗАПУСКА только действительно необходим при использовании
наследство индексирует.

Это - график, который используют примеры:

Рисунок 10.4. График

cypher-start-graph.svg


10.4.1. Получите вершину, или отношение от индексируют

10.4.1.1. Вершина индексирует поиск

Когда начальная точка может быть найдена при использовании, индексируют поиски, она может быть сделана
как это: node:index-имя (ключ = "значение"). В этом примере, там существует вершина
индексируйте названные вершины.

Запрос.

ЗАПУСТИТЕ n=node:nodes (имя =)
ВОЗВРАТИТЕ n

Запрос возвращает вершину, индексированную с именем "A".

Таблица 10.38. Результат

+-----------------+
|n |
|-----------------|
|1 строка |
|-----------------|
|Node [0] {имя:} |
+-----------------+


10.4.1.2. Отношение индексирует поиск

Когда начальная точка может быть найдена при использовании, индексируют поиски, она может быть сделана
как это: relationship:index-имя (ключ = "значение").

Запрос.

ЗАПУСТИТЕ r=relationship:rels (имя = "Андрес")
ВОЗВРАТИТЕ r

Отношение, индексированное с набором свойств имени "Андресу", возвращено
запрос.

Таблица 10.39. Результат

+-----------------------+
|r |
|-----------------------|
|1 строка |
|-----------------------|
|:KNOWS [0] {имя: "Андрес" |
+-----------------------+


10.4.1.3. Вершина индексирует запрос

Когда начальная точка может быть найдена более комплексными запросами Лукина, это
синтаксис, чтобы использовать: node:index-имя ("запрос").This позволяет Вам писать больше
усовершенствованный индексируют запросы.

Запрос.

ЗАПУСТИТЕ n=node:nodes ("name:A")
ВОЗВРАТИТЕ n

Вершина, индексированная с именем "A", возвращена запросом.

Таблица 10.40. Результат

+-----------------+
|n |
|-----------------|
|1 строка |
|-----------------|
|Node [0] {имя:} |
+-----------------+


10.4.2. Получите вершину или отношение идентификатором

10.4.2.1. Вершина идентификатором

Связывая вершину, поскольку начальная точка сделана с вершиной (*) функция.

Замечание

Neo4j повторно использует свои внутренние идентификаторы, когда вершины и отношения стерты, который
средства это - плохая практика, чтобы отослать к ним этот путь. Вместо этого используйте приложение
сгенерированные идентификаторы.

Запрос.

ЗАПУСТИТЕ n=node (0)
ВОЗВРАТИТЕ n

Соответствующая вершина возвращена.

Таблица 10.41. Результат

+-----------------+
|n |
|-----------------|
|1 строка |
|-----------------|
|Node [0] {имя:} |
+-----------------+


10.4.2.2. Отношение идентификатором

Связывая отношение, поскольку начальная точка сделана с отношением (*)
функция, которая может также быть сокращенным рэлом (*). См. Раздел 10.4.2.1, “Вершина
идентификатор” для получения дополнительной информации об идентификаторах Neo4j.

Запрос.

ЗАПУСТИТЕ r=relationship (0)
ВОЗВРАТИТЕ r

Отношение с идентификатором 0 возвращено.

Таблица 10.42. Результат

+-----------+
|r |
|-----------|
|1 строка |
|-----------|
|:KNOWS [0] {} |
+-----------+


10.4.2.3. Разнообразные вершины идентификатором

Разнообразные вершины выбраны, перечисляя их разделенный запятыми.

Запрос.

ЗАПУСТИТЕ n=node (0, 1, 2)
ВОЗВРАТИТЕ n

Это возвращает вершины, перечисленные в операторе START.

Таблица 10.43. Результат

+-----------------+
|n |
|-----------------|
|3 строки |
|-----------------|
|Node [0] {имя:} |
|-----------------|
|Node [1] {имя: "B"} |
|-----------------|
|Node [2] {имя: "C"} |
+-----------------+


10.4.3. Получите разнообразными или все вершины

10.4.3.1. Все вершины

Чтобы получить все вершины, используйте звездочку. Это может быть сделано с отношениями как
хорошо.

Подсказка

Привилегированный способ сделать это должно использовать пункт СООТВЕТСТВИЯ, видеть Раздел 10.1.2.1,
“Получите все вершины” в Разделе 10.1, "Соответствии" для того, как сделать это.

Запрос.

ЗАПУСТИТЕ n=node (*)
ВОЗВРАТИТЕ n

Этот запрос возвращает все вершины в графике.

Таблица 10.44. Результат

+-----------------+
|n |
|-----------------|
|3 строки |
|-----------------|
|Node [0] {имя:} |
|-----------------|
|Node [1] {имя: "B"} |
|-----------------|
|Node [2] {имя: "C"} |
+-----------------+


10.4.3.2. Разнообразные начальные точки

Иногда Вы хотите связать разнообразные начальные точки. Только перечислите их разделенный
запятыми.

Запрос.

ЗАПУСТИТЕ a=node (0), b=node (1)
ВОЗВРАТИТЕ a, b

И вершины A и B возвращены.

Таблица 10.45. Результат

+-----------------------------------+
|a |b |
|-----------------------------------|
|1 строка |
|-----------------------------------|
|Node [0] {имя:} |Node [1] {имя: "B"} |
+-----------------------------------+


10.5. Агрегация

10.5.1. Введение
10.5.2. КОЛИЧЕСТВО
10.5.3. Статистика
10.5.4. собраться
10.5.5. ЯВНЫЙ

10.5.1. Введение

Чтобы вычислить агрегированные данные, Код предлагает агрегацию, очень как ГРУППА SQL
.

Совокупные функции принимают значения многократного ввода и вычисляют агрегированный
значение от них. Примеры в среднем, который вычисляет среднее число разнообразных
числовые значения, или минута, которая обнаруживает самое малое числовое значение в ряде
значения.

Агрегация может быть сделана по всему соответствию sub графики, или это может быть далее
разделенный, представляя значения ключа. Они - несоставные выражения, это
используются, чтобы сгруппировать значения, входящие в совокупные функции.

Так, если оператор возврата выглядит примерно так:

ВОЗВРАТИТЕ n, количество (*)

У нас есть два выражения возврата  -  n, и количество (*). Первым, n, не является никакой агрегат
функция, и таким образом, это будет группирующийся ключ. Последний, количество (*)
составное выражение. Таким образом, соответствующие подграфы будут разделены на различный
блоки, в зависимости от группирующегося ключа. Совокупная функция будет тогда работать
эти блоки, вычисляя совокупные значения.

Если Вы хотите использовать агрегации, чтобы сортировать Ваш набор результатов, агрегация должна
будьте включены в ВОЗВРАТ, который будет использоваться в Вашем ПОРЯДКЕ.

Последняя часть проблемы - ЯВНОЕ ключевое слово. Это используется, чтобы сделать все
оценивает уникальный прежде, чем выполнить их через совокупную функцию.

Пример мог бы быть полезным. В этом случае, мы выполняем запрос против
следующие данные:

aggregation-introduction.preparation-graph.svg

Запрос.

СООТВЕТСТВИЕ (me:Person)-> (friend:Person)-> (friend_of_friend:Person)
ГДЕ me.name =
ВОЗВРАТИТЕ количество (ЯВНЫЙ friend_of_friend), количество (friend_of_friend)

В этом примере мы пытаемся обнаружить всех наших друзей друзей, и количество
их. Первая совокупная функция, количество (ЯВНЫЙ friend_of_friend), будет только
см. friend_of_friend однажды  -  ЯВНЫЕ перемещения копии. Последний
совокупная функция, количество (friend_of_friend), могла бы очень хорошо видеть то же самое
friend_of_friend многократно. В этом случае, и B и C знают D и таким образом D
получит считаемым дважды, если не используя ЯВНЫЙ.

Таблица 10.46. Результат

+--------------------------------------------------------+
|count (явный friend_of_friend) |count (friend_of_friend) |
|--------------------------------------------------------|
|1 строка |
|--------------------------------------------------------|
|1 |2 |
+--------------------------------------------------------+


Следующие примеры принимают строение графика в качестве примера ниже.

Рисунок 10.5. График

cypher-aggregation-graph.svg


10.5.2. КОЛИЧЕСТВО

ГРАФ используется, чтобы считать номер строк. ГРАФ может использоваться в два
формы  -  ГРАФ (*), который только считает номер соответствия строк, и ГРАФА
(<идентификатор>), который считает номер НЕНУЛЕВЫХ ЗНАЧЕНИЙ в <идентификаторе>.

10.5.2.1. Вершины графа

Чтобы считать номер вершин, например номер вершин соединялся с одним
вершина, Вы можете использовать количество (*).

Запрос.

СООТВЕТСТВИЕ (n {имя:})-> (x)
ВОЗВРАТИТЕ n, количество (*)

Это возвращает вершину запуска и количество связанных вершин.

Таблица 10.47. Результат

+--------------------------------------+
|n |count (*) |
|--------------------------------------|
|1 строка |
|--------------------------------------|
|Node [1] {имя: property:13} |3 |
+--------------------------------------+


10.5.2.2. Групповые Типы граф Релэйшншип

Чтобы считать группы типов отношения, возвратите типы и считайте их с
количество (*).

Запрос.

СООТВЕТСТВИЕ (n {имя:}) - [r]-> ()
ВОЗВРАТИТЕ тип (r), количество (*)

Типы отношения и их групповое количество возвращены запросом.

Таблица 10.48. Результат

+-----------------+
|type (r) |count (*) |
|-----------------|
|1 строка |
|-----------------|
| "ЗНАЕТ" |3 |
+-----------------+


10.5.2.3. Объекты графа

Вместо того, чтобы считать номер результатов с количеством (*), это могло бы быть больше
выразительный, чтобы включать имя идентификатора Вы заботитесь о.

Запрос.

СООТВЕТСТВИЕ (n {имя:})-> (x)
ВОЗВРАТИТЕ количество (x)

Запрос в качестве примера возвращает номер соединенных вершин от вершины запуска.

Таблица 10.49. Результат

+--------+
|count (x) |
|--------|
|1 строка |
|--------|
|3 |
+--------+


10.5.2.4. Подсчитайте ненулевые значения

Вы можете считать ненулевые значения при использовании количества (<идентификатор>).

Запрос.

СООТВЕТСТВИЕ (n:Person)
ВОЗВРАТИТЕ количество (n.property)

Количество связанных вершин с набором свойств свойства возвращено
запрос.

Таблица 10.50. Результат

+-----------------+
|count (n.property) |
|-----------------|
|1 строка |
|-----------------|
|3 |
+-----------------+


10.5.3. Статистика

10.5.3.1. сумма

Функция агрегации суммы просто суммирует все числовые значения, с которыми она встречается.
НУЛИ тихо отброшены.

Запрос.

СООТВЕТСТВИЕ (n:Person)
ВОЗВРАТИТЕ сумму (n.property)

Это возвращает сумму всех значений в свойстве свойства.

Таблица 10.51. Результат

+---------------+
|sum (n.property) |
|---------------|
|1 строка |
|---------------|
|90 |
+---------------+


10.5.3.2. в среднем

в среднем вычисляет среднее число числового столбца.

Запрос.

СООТВЕТСТВИЕ (n:Person)
ВОЗВРАТИТЕСЬ в среднем (n.property)

Среднее число всех значений в свойстве свойства возвращено
запрос в качестве примера.

Таблица 10.52. Результат

+---------------+
|avg (n.property) |
|---------------|
|1 строка |
|---------------|
|30.0 |
+---------------+


10.5.3.3. percentileDisc

percentileDisc вычисляет процентиль данного значения по группе, с a
процентиль от 0.0 до 1.0. Это использует метод округления, возвращая самое близкое
оцените процентили. Для интерполированных значений, см. percentileCont.

Запрос.

СООТВЕТСТВИЕ (n:Person)
ВОЗВРАТИТЕ percentileDisc (n.property, 0.5)

50-ая процентиль значений в свойстве свойства возвращена
запрос в качестве примера. В этом случае, 0.5 медиана, или 50-ая процентиль.

Таблица 10.53. Результат

+-------------------------------+
|percentileDisc (n.property, 0.5) |
|-------------------------------|
|1 строка |
|-------------------------------|
|33 |
+-------------------------------+


10.5.3.4. percentileCont

percentileCont вычисляет процентиль данного значения по группе, с a
процентиль от 0.0 до 1.0. Это использует линейный метод интерполяции, вычисляя
взвешенное среднее число между двумя значениями, если требуемая процентиль находится между
их. Для самых близких значений, используя метод округления, см. percentileDisc.

Запрос.

СООТВЕТСТВИЕ (n:Person)
ВОЗВРАТИТЕ percentileCont (n.property, 0.4)

40-ая процентиль значений в свойстве свойства возвращена
запрос в качестве примера, вычисленный со взвешенным средним числом.

Таблица 10.54. Результат

+-------------------------------+
|percentileCont (n.property, 0.4) |
|-------------------------------|
|1 строка |
|-------------------------------|
|29.0 |
+-------------------------------+


10.5.3.5. stdev

stdev вычисляет среднее квадратическое отклонение для данного значения по группе. Это использует
должен использоваться стандартный метод с двумя передачами, с N - 1 как знаменатель, и
беря выборку совокупности для объективной оценки. Когда
стандартная вариация всей совокупности вычисляется, stdevp должен
использоваться.

Запрос.

СООТВЕТСТВИЕ (n)
ГДЕ n.name В ['B', 'C']
ВОЗВРАТИТЕ stdev (n.property)

Среднее квадратическое отклонение значений в свойстве свойства возвращено
запрос в качестве примера.

Таблица 10.55. Результат

+------------------+
|stdev (n.property) |
|------------------|
|1 строка |
|------------------|
|15.716233645501712 |
+------------------+


10.5.3.6. stdevp

stdevp вычисляет среднее квадратическое отклонение для данного значения по группе. Это
использует стандартный метод с двумя передачами, с N как знаменатель, и должен использоваться
вычисляя среднее квадратическое отклонение для всей совокупности. Когда
стандартная вариация только выборки совокупности вычисляется,
stdev должен использоваться.

Запрос.

СООТВЕТСТВИЕ (n)
ГДЕ n.name В ['B', 'C']
ВОЗВРАТИТЕ stdevp (n.property)

Среднее квадратическое отклонение совокупности значений в свойстве свойства
возвращенный запросом в качестве примера.

Таблица 10.56. Результат

+------------------+
|stdevp (n.property) |
|------------------|
|1 строка |
|------------------|
|12.832251036613439 |
+------------------+


10.5.3.7. максимальный

максимальное новое месторождение самое большое значение в числовом столбце.

Запрос.

СООТВЕТСТВИЕ (n:Person)
ВОЗВРАТИТЕСЬ максимальный (n.property)

Самое большое из всех значений в свойстве свойства возвращено.

Таблица 10.57. Результат

+---------------+
|max (n.property) |
|---------------|
|1 строка |
|---------------|
|44 |
+---------------+


10.5.3.8. минута

минута берет числовое свойство как входной, и возвращает самое малое значение в этом
столбец.

Запрос.

СООТВЕТСТВИЕ (n:Person)
ВОЗВРАТИТЕ минуту (n.property)

Это возвращает самое малое из всех значений в свойстве свойства.

Таблица 10.58. Результат

+---------------+
|min (n.property) |
|---------------|
|1 строка |
|---------------|
|13 |
+---------------+


10.5.4. собраться

соберитесь собирает все значения в список. Это игнорирует, ОБНУЛЯЕТ.

Запрос.

СООТВЕТСТВИЕ (n:Person)
ВОЗВРАТ собирается (n.property)

Возвращает единственную строку, со всеми собранными значениями.

Таблица 10.59. Результат

+-------------------+
|collect (n.property) |
|-------------------|
|1 строка |
|-------------------|
| [13,33,44] |
+-------------------+


10.5.5. ЯВНЫЙ

Все функции агрегации также берут ЯВНЫЙ модификатор, который перемещает
копии от значений. Так, чтобы считать номер уникальных цветов глаз от
вершины имели отношение к a, этот запрос может использоваться:

Запрос.

СООТВЕТСТВИЕ (a:Person {имя:})-> (b)
ВОЗВРАТИТЕ количество (ЯВНЫЙ b.eyes)

Возвращает номер цветов глаз.

Таблица 10.60. Результат

+----------------------+
|count (явный b.eyes) |
|----------------------|
|1 строка |
|----------------------|
|2 |
+----------------------+


Глава 11. Запись Пунктов

Запишите данные в базу данных.

11.1. Создать

11.1.1. Создайте вершины
11.1.2. Создайте отношения
11.1.3. Создайте полный путь
11.1.4. Используйте параметры с, СОЗДАЮТ

Создавая элементы графика  -  вершины и отношения, сделан с, СОЗДАЮТ.

Подсказка

В СОЗДАТЬ пункте модели используются много. Считайте Раздел 8.5, "Модели" для
введение.

11.1.1. Создайте вершины

11.1.1.1. Создайте единственную вершину

Создание единственной вершины сделано, выпуская следующий запрос.

Запрос.

СОЗДАЙТЕ (n)

Ничто не возвращено из этого запроса, кроме количества вершин, на которые влияют.

Таблица 11.1. Результат

+----------------+
|Nodes создал: 1 |
|----------------|
| (освободите результат), |
+----------------+


11.1.1.2. Создайте вершину с меткой

Чтобы прибавить метку, создавая вершину, используйте синтаксис ниже.

Запрос.

СОЗДАЙТЕ (n:Person)

Ничто не возвращено из этого запроса.

Таблица 11.2. Результат

+----------------+
|Nodes создал: 1 |
|----------------|
|Labels добавлялся: 1 |
|----------------|
| (освободите результат), |
+----------------+


11.1.1.3. Создайте вершину с разнообразными метками

Чтобы прибавить метки, создавая вершину, используйте синтаксис ниже. В этом случае, мы добавляемся
две метки.

Запрос.

СОЗДАЙТЕ (n:Person:Swedish)

Ничто не возвращено из этого запроса.

Таблица 11.3. Результат

+----------------+
|Nodes создал: 1 |
|----------------|
|Labels добавлялся: 2 |
|----------------|
| (освободите результат), |
+----------------+


11.1.1.4. Создайте вершину и прибавьте метки и свойства

Создавая новую вершину с метками, Вы можете прибавить свойства одновременно.

Запрос.

СОЗДАЙТЕ (n:Person {имя: 'Андрес, заголовок: 'Разработчик'})

Ничто не возвращено из этого запроса.

Таблица 11.4. Результат

+-----------------+
|Nodes создал: 1 |
|-----------------|
|Properties устанавливают: 2 |
|-----------------|
|Labels добавлялся: 1 |
|-----------------|
| (освободите результат), |
+-----------------+


11.1.1.5. Возвратите создаваемую вершину

Создание единственной вершины сделано, выпуская следующий запрос.

Запрос.

СОЗДАЙТЕ ({имя: 'Андрес'})
ВОЗВРАТИТЕ a

Недавно создаваемая вершина возвращена.

Таблица 11.5. Результат

+----------------------+
|a |
|----------------------|
|1 строка |
|----------------------|
|Nodes создал: 1 |
|----------------------|
|Properties устанавливают: 1 |
|----------------------|
|Node [1] {имя: "Андрес"} |
+----------------------+


11.1.2. Создайте отношения

11.1.2.1. Создайте отношение между двумя вершинами

Чтобы создать отношение между двумя вершинами, мы сначала получаем эти две вершины. Однажды
вершины загружены, мы просто создаем отношение между ними.

Запрос.

СООТВЕТСТВИЕ (a:Person), (b:Person)
ГДЕ a.name = 'Вершина' И b.name = 'Вершина B'
СОЗДАЙТЕ (a) - [r:RELTYPE]-> (b)
ВОЗВРАТИТЕ r

Создаваемое отношение возвращено запросом.

Таблица 11.6. Результат

+------------------------+
|r |
|------------------------|
|1 строка |
|------------------------|
|Relationships создал: 1 |
|------------------------|
|:RELTYPE [1] {} |
+------------------------+


11.1.2.2. Создайте отношение и установите свойства

Установка свойств на отношениях сделана подобным образом к тому, как это
сделанный, создавая вершины. Заметьте, что значения могут быть любым выражением.

Запрос.

СООТВЕТСТВИЕ (a:Person), (b:Person)
ГДЕ a.name = 'Вершина' И b.name = 'Вершина B'
СОЗДАЙТЕ (a) - [r:RELTYPE {имя: a.name +' <->' + b.name}]-> (b)
ВОЗВРАТИТЕ r

Недавно создаваемое отношение возвращено запросом в качестве примера.

Таблица 11.7. Результат

+-----------------------------------+
|r |
|-----------------------------------|
|1 строка |
|-----------------------------------|
|Relationships создал: 1 |
|-----------------------------------|
|Properties устанавливают: 1 |
|-----------------------------------|
|:RELTYPE [1] {имя: "Вершина <-> Вершина B"} |
+-----------------------------------+


11.1.3. Создайте полный путь

Когда Вы используете, СОЗДАЮТ и модель, все части модели, которые не являются
уже в контексте в это время будет создаваться.

Запрос.

СОЗДАЙТЕ p = (andres {называют:' Андреса'}) - [:WORKS_AT]-> (нео) <-[:WORKS_AT] - (michael {называют:' Майкла'}),
ВОЗВРАТИТЕ p

Этот запрос создает три вершины и два отношения сразу, присваивает это a
идентификатор пути, и возвраты это.

Таблица 11.8. Результат

+-----------------------------------------------------------------------------+
|p |
|-----------------------------------------------------------------------------|
|1 строка |
|-----------------------------------------------------------------------------|
|Nodes создал: 3 |
|-----------------------------------------------------------------------------|
|Relationships создал: 2 |
|-----------------------------------------------------------------------------|
|Properties устанавливают: 2 |
|-----------------------------------------------------------------------------|
| [Вершина [3] {имя: "Андрес"}:WORKS_AT [2] {}, Вершина [4] {}:WORKS_AT [3] {}, Вершина [5] |
| {имя: "Майкл"}] |
+-----------------------------------------------------------------------------+


11.1.4. Используйте параметры с, СОЗДАЮТ

11.1.4.1. Создайте вершину с параметром для свойств

Вы можете также создать объект графика из карты. Все пары ключа/значения в
карта будет установлена как свойства на создаваемом отношении или вершине. В этом случае
мы прибавляем метку Человека к вершине также.

Параметры.

{
  "опоры": {
    "имя": "Андрес",
    "позиция": "Разработчик"
  }
}

Запрос.

СОЗДАЙТЕ (n:Person {опоры})
ВОЗВРАТИТЕ n

Таблица 11.9. Результат

+-------------------------------------------+
|n |
|-------------------------------------------|
|1 строка |
|-------------------------------------------|
|Nodes создал: 1 |
|-------------------------------------------|
|Properties устанавливают: 2 |
|-------------------------------------------|
|Labels добавлялся: 1 |
|-------------------------------------------|
|Node [1] {имя: "Андрес", позиция: "Разработчик"} |
+-------------------------------------------+


11.1.4.2. Создайте разнообразные вершины с параметром для их свойств

Обеспечивая Код массив карт, это создаст вершину для каждой карты.

Замечание

Когда Вы делаете это, Вы не можете создать ничто больше в том же самом, СОЗДАЮТ пункт.

Параметры.

{
  "опоры": [{
    "имя": "Андрес",
    "позиция": "Разработчик"
  }, {
    "имя": "Майкл",
    "позиция": "Разработчик"
  } ]
}

Запрос.

СОЗДАЙТЕ (n {опоры})
ВОЗВРАТИТЕ n

Таблица 11.10. Результат

+--------------------------------------------+
|n |
|--------------------------------------------|
|2 строки |
|--------------------------------------------|
|Nodes создал: 2 |
|--------------------------------------------|
|Properties устанавливают: 4 |
|--------------------------------------------|
|Node [2] {имя: "Андрес", позиция: "Разработчик"} |
|--------------------------------------------|
|Node [3] {имя: "Майкл", позиция: "Разработчик"} |
+--------------------------------------------+


11.2. Создайте Уникальный

11.2.1. Создайте уникальные вершины
11.2.2. Создайте уникальные отношения
11.2.3. Опишите комплексную модель

СОЗДАЙТЕ УНИКАЛЬНЫЙ, находится в середине СООТВЕТСТВИЯ, и СОЗДАЙТЕ  - , это будет соответствовать то, что это может,
и создайте то, что пропускает. СОЗДАЙТЕ УНИКАЛЬНЫЙ, будет всегда производить наименьшее количество изменения
возможный к графику  - , если это может использовать части существующего графика, это будет.

Другая разность для СООТВЕТСТВИЯ, это СОЗДАЕТ УНИКАЛЬНЫЙ, предполагает, что модель
уникальный. Если разнообразные подграфы соответствия будут найдены, то погрешность будет сгенерирована.

Подсказка

В СОЗДАВАНИИ УНИКАЛЬНОГО пункта модели используются много. Считайте Раздел 8.5,
"Модели" для введения.

Примеры начинаются со следующим набором данных:

cypher-createunique-graph.svg

11.2.1. Создайте уникальные вершины

11.2.1.1. Создайте вершину, пропуская

Если модель описала потребности вершина, и она не может быть соответствующей, новая вершина будет
быть созданным.

Запрос.

СООТВЕТСТВИЕ (корень {имя: 'корень'})
СОЗДАЙТЕ УНИКАЛЬНЫЙ (корень) - [:LOVES] - (кто-то)
ВОЗВРАТИТЕ кого-то

Корневой узел не имеет, любой ЛЮБИТ отношения, и таким образом, вершина создается,
и также отношение к той вершине.

Таблица 11.11. Результат

+------------------------+
|someone |
|------------------------|
|1 строка |
|------------------------|
|Nodes создал: 1 |
|------------------------|
|Relationships создал: 1 |
|------------------------|
|Node [5] {} |
+------------------------+


11.2.1.2. Создайте вершины со значениями

Описанная модель может также содержать значения на вершине. Они даны
использование следующего синтаксиса: опора: <выражение>.

Запрос.

СООТВЕТСТВИЕ (корень {имя: 'корень'})
СОЗДАЙТЕ УНИКАЛЬНЫЙ (корень) - [:X] - (лист {называют:'D'}),
ВОЗВРАТИТЕ лист

Ни у какой вершины, соединенной с корневым узлом, нет имени D, и таким образом, новая вершина
создаваемый, чтобы соответствовать модель.

Таблица 11.12. Результат

+------------------------+
|leaf |
|------------------------|
|1 строка |
|------------------------|
|Nodes создал: 1 |
|------------------------|
|Relationships создал: 1 |
|------------------------|
|Properties устанавливают: 1 |
|------------------------|
|Node [5] {имя: "D"} |
+------------------------+


11.2.1.3. Создайте маркированную вершину, пропуская

Если модель описала потребности маркированная вершина и нет ни одного с данным
метки, Код создаст новый.

Запрос.

СООТВЕТСТВИЕ ({имя:})
СОЗДАЙТЕ УНИКАЛЬНЫЙ (a) - [:KNOWS] - (c:blue)
ВОЗВРАТИТЕ c

Вершина соединена в, ЗНАЕТ отношение к c вершине, но с тех пор C
не имеет метки:blue, новая вершина маркированный, поскольку:blue создается наряду с
ЗНАЕТ отношение от до этого.

Таблица 11.13. Результат

+------------------------+
|c |
|------------------------|
|1 строка |
|------------------------|
|Nodes создал: 1 |
|------------------------|
|Relationships создал: 1 |
|------------------------|
|Labels добавлялся: 1 |
|------------------------|
|Node [5] {} |
+------------------------+


11.2.2. Создайте уникальные отношения

11.2.2.1. Создайте отношение, если оно пропускает

СОЗДАЙТЕ УНИКАЛЬНЫЙ, используется, чтобы описать модель, которая должна быть найдена или создана.

Запрос.

СООТВЕТСТВИЕ (lft {имя:}), (rgt)
ГДЕ rgt.name В ['B', 'C']
СОЗДАЙТЕ УНИКАЛЬНЫЙ (lft) - [r:KNOWS]-> (rgt)
ВОЗВРАТИТЕ r

Вершина левой стороны является соответствующей agains две правильных вершины. Одно отношение уже
существует и может быть соответствующим, и другое отношение создается прежде, чем это будет
возвращенный.

Таблица 11.14. Результат

+------------------------+
|r |
|------------------------|
|2 строки |
|------------------------|
|Relationships создал: 1 |
|------------------------|
|:KNOWS [5] {} |
|------------------------|
|:KNOWS [3] {} |
+------------------------+


11.2.2.2. Создайте отношение со значениями

Отношения, которые будут созданы, могут также быть соответствующими на значениях.

Запрос.

СООТВЕТСТВИЕ (корень {имя: 'корень'})
СОЗДАЙТЕ УНИКАЛЬНЫЙ (корень) - [r:X {начиная с:'forever'}] - ()
ВОЗВРАТИТЕ r

В этом примере мы хотим, чтобы у отношения было значение, и с тех пор не такой
отношение может быть найдено, новая вершина и отношение создаются. Заметьте это
так как мы не интересуемся создаваемой вершиной, мы не называем ее.

Таблица 11.15. Результат

+------------------------+
|r |
|------------------------|
|1 строка |
|------------------------|
|Nodes создал: 1 |
|------------------------|
|Relationships создал: 1 |
|------------------------|
|Properties устанавливают: 1 |
|------------------------|
|:X [5] {так как: "навсегда"} |
+------------------------+


11.2.3. Опишите комплексную модель

Модель, описанная, СОЗДАЕТ УНИКАЛЬНЫЙ, может быть разделен запятыми, точно так же как в
СООТВЕТСТВУЙТЕ и СОЗДАЙТЕ.

Запрос.

СООТВЕТСТВИЕ (корень {имя: 'корень'})
СОЗДАЙТЕ УНИКАЛЬНЫЙ (корень) - [:FOO]-> (x), (корень) - [:BAR]-> (x)
ВОЗВРАТИТЕ x

Эта модель в качестве примера использует два пути, разделенные запятой.

Таблица 11.16. Результат

+------------------------+
|x |
|------------------------|
|1 строка |
|------------------------|
|Nodes создал: 1 |
|------------------------|
|Relationships создал: 2 |
|------------------------|
|Node [5] {} |
+------------------------+


11.3. Слияние

11.3.1. Введение
11.3.2. Вершины слияния
11.3.3. Используйте НА, СОЗДАЮТ и НА СООТВЕТСТВИИ
11.3.4. Отношения слияния
11.3.5. Используя уникальные ограничения со СЛИЯНИЕМ
11.3.6. Используя параметры карты со СЛИЯНИЕМ

11.3.1. Введение

Предварительная Функция

СЛИЯНИЕ - новое прибавление и предварительная функция Кода. Его контекст и
синтаксис подвержен изменениям. Поэтому, пожалуйста знайте, что Вы, возможно, нуждаетесь к
измените запросы, которые используют СЛИЯНИЕ в будущем.

СЛИЯНИЕ гарантирует, что модель существует в графике. Любой модель уже
существует, или это должно быть создано.

ОБЪЕДИНИТЕ или соответствия существующие вершины, и связывает их, или это создает новые данные и
связывает это. Это походит на комбинацию СООТВЕТСТВИЯ, и СОЗДАЙТЕ это дополнительно
позволяет Вам определять то, что происходит, если данные были соответствующими или созданы.

Например, Вы можете определить, что график должен содержать вершину для пользователя с
определенное имя. Если не будет вершины с корректным именем, то новая вершина будет
создаваемый и его набор свойств имени.

При использовании СЛИЯНИЯ на полных моделях поведение - это любой целое
копируйте соответствия, или целая модель создается. СЛИЯНИЕ не будет частично использовать
существующие модели  -  это все или ничего. Если частичные соответствия необходимы, это
может быть выполнен, разделяя модель в разнообразные пункты СЛИЯНИЯ.

Как с СООТВЕТСТВИЕМ, СЛИЯНИЕ может соответствовать разнообразные возникновения модели. Если есть
разнообразные соответствия, они будут все переданы более поздним этапам запроса.

Последняя часть СЛИЯНИЯ НА, СОЗДАЮТ и НА СООТВЕТСТВИИ. Они позволяют запрос
выразите дополнительные изменения свойствам вершины или отношения,
в зависимости от того, если элемент был СООТВЕТСТВУЮЩИМ в базе данных или если это СОЗДАВАЛОСЬ.

Следующий график используется для примеров ниже:

Рисунок 11.1. График

cypher-merge-graph.svg


11.3.2. Вершины слияния

11.3.2.1. Слияние единственная вершина с меткой

Слияние единственной вершины с данной меткой.

Запрос.

СЛИЯНИЕ (robert:Critic)
ВОЗВРАТИТЕ robert, метки (robert)

Поскольку нет никаких вершин маркированного Критика в базе данных, новая вершина
создаваемый.

Таблица 11.17. Результат

+-------------------------+
|robert |labels (robert) |
|-------------------------|
|1 строка |
|-------------------------|
|Nodes создал: 1 |
|-------------------------|
|Labels добавлялся: 1 |
|-------------------------|
|Node [8] {} | ["Критик"] |
+-------------------------+


11.3.2.2. Слияние единственная вершина со свойствами

Слияние единственной вершины со свойствами, где не все свойства соответствуют любому
существующая вершина.

Запрос.

СЛИЯНИЕ (charlie {называют:' Чарли Шина', age:10}),
ВОЗВРАТИТЕ charlie

Новая вершина с именем Чарли Шин будет создаваться с тех пор не все свойства
соответствующий существующая вершина Чарли Шина.

Таблица 11.18. Результат

+------------------------------------+
|charlie |
|------------------------------------|
|1 строка |
|------------------------------------|
|Nodes создал: 1 |
|------------------------------------|
|Properties устанавливают: 2 |
|------------------------------------|
|Node [8] {имя: "Чарли Шин", age:10} |
+------------------------------------+


11.3.2.3. Слияние единственная вершина, определяющая и метка и свойство

Слияние единственной вершины и с меткой и со свойством, соответствующим существующую вершину.

Запрос.

СЛИЯНИЕ (michael:Person {называют:' Майкла Дугласа'}),
ВОЗВРАТИТЕ michael

Майкл Дуглас будет соответствующим и возвращен.

Таблица 11.19. Результат

+-------------------------------+
|michael |
|-------------------------------|
|1 строка |
|-------------------------------|
|Node [6] {имя: "Майкл Дуглас"} |
+-------------------------------+


11.3.3. Используйте НА, СОЗДАЮТ и НА СООТВЕТСТВИИ

11.3.3.1. Слияние с НА СОЗДАЕТ

Объедините вершину и установите свойства, если вершина должна быть создана.

Запрос.

СЛИЯНИЕ (keanu:Person {называют:' Киану Ривза'}),
НА СОЗДАЮТ НАБОР keanu.created = метка времени ()
ВОЗВРАТИТЕ keanu

Создает вершину Киану, и устанавливает метку времени на времени создания.

Таблица 11.20. Результат

+--------------------------------------------------+
|keanu |
|--------------------------------------------------|
|1 строка |
|--------------------------------------------------|
|Nodes создал: 1 |
|--------------------------------------------------|
|Properties устанавливают: 2 |
|--------------------------------------------------|
|Labels добавлялся: 1 |
|--------------------------------------------------|
|Node [8] {имя: "Киану Ривз", created:1386514444417} |
+--------------------------------------------------+


11.3.3.2. Слияние с НА СООТВЕТСТВИИ

Слияние вершин и устанавливая свойства на найденных вершинах.

Запрос.

СЛИЯНИЕ (person:Person)
НА НАБОРЕ СООТВЕТСТВИЯ person.found = ИСТИНА ВОЗВРАЩАЮТ человека

Новые месторождения все вершины Человека, устанавливает свойство на них, и возвращает их.

Таблица 11.21. Результат

+------------------------------------------+
|person |
|------------------------------------------|
|5 строк |
|------------------------------------------|
|Properties устанавливают: 5 |
|------------------------------------------|
|Node [0] {имя: "Оливер Стоун", found:true} |
|------------------------------------------|
|Node [1] {имя: "Чарли Шин", found:true} |
|------------------------------------------|
|Node [2] {имя: "Мартеновский Блеск", found:true} |
|------------------------------------------|
|Node [5] {имя: "Роб Райнер", found:true} |
|------------------------------------------|
|Node [6] {имя: "Майкл Дуглас", found:true} |
+------------------------------------------+


11.3.3.3. Слияние с НА СОЗДАЕТ и НА СООТВЕТСТВИИ

Объедините вершину и установите свойства, если вершина должна быть создана.

Запрос.

СЛИЯНИЕ (keanu:Person {называют:' Киану Ривза'}),
НА СОЗДАЮТ НАБОР keanu.created = метка времени ()
НА НАБОРЕ СООТВЕТСТВИЯ keanu.lastSeen = метка времени ()
ВОЗВРАТИТЕ keanu

Запрос создает вершину Киану, и устанавливает метку времени на времени создания. Если
Киану уже существовал, различное свойство будет установлено.

Таблица 11.22. Результат

+--------------------------------------------------+
|keanu |
|--------------------------------------------------|
|1 строка |
|--------------------------------------------------|
|Nodes создал: 1 |
|--------------------------------------------------|
|Properties устанавливают: 2 |
|--------------------------------------------------|
|Labels добавлялся: 1 |
|--------------------------------------------------|
|Node [8] {created:1386514447501, имя: "Киану Ривз"} |
+--------------------------------------------------+


11.3.4. Отношения слияния

11.3.4.1. Слияние на отношении

СЛИЯНИЕ может использоваться, чтобы соответствовать или создать отношение.

Запрос.

СООТВЕТСТВИЕ (charlie:Person {называют:' Чарли Шина'}), (wallStreet:Movie {заголовок:'Wall улица'})
СЛИЯНИЕ (charlie) - [r:ACTED_IN]-> (wallStreet)
ВОЗВРАТИТЕ r

Чарли Шин был уже отмечен как действующий на Уолл-стрит, таким образом, существующее
отношение найдено и возвращено. Заметьте что, чтобы соответствовать или создать a
отношение при использовании СЛИЯНИЯ, по крайней мере одна связанная вершина должна быть определена, который
сделан через пункт СООТВЕТСТВИЯ в вышеупомянутом примере.

Таблица 11.23. Результат

+--------------+
|r |
|--------------|
|1 строка |
|--------------|
|:ACTED_IN [0] {} |
+--------------+


11.3.4.2. Слияние на разнообразных отношениях

Когда СЛИЯНИЕ используется на целой модели, или все соответствует, или все
создается.

Запрос.

СООТВЕТСТВИЕ (oliver:Person {называют:' Оливера Стоуна'}), (reiner:Person {называют:' Роба Райнера'}),
СЛИЯНИЕ (oliver) - [:DIRECTED]-> (movie:Movie) <-[:ACTED_IN] - (reiner)
ВОЗВРАТИТЕ фильм

В нашем графике в качестве примера никогда не сотрудничали Оливер Стоун и Роб Райнер.
Когда мы попытаемся ОБЪЕДИНИТЬ фильм между ними, Код не будет использовать ни одного из
существующие фильмы уже соединялись с любым человеком. Вместо этого новая вершина фильма
создается.

Таблица 11.24. Результат

+------------------------+
|movie |
|------------------------|
|1 строка |
|------------------------|
|Nodes создал: 1 |
|------------------------|
|Relationships создал: 2 |
|------------------------|
|Labels добавлялся: 1 |
|------------------------|
|Node [8] {} |
+------------------------+


11.3.5. Используя уникальные ограничения со СЛИЯНИЕМ

Код предотвращает получение, конфликтующее следствия СЛИЯНИЯ при использовании моделей это
включите уникальность, ограничивает. В этом случае, должна быть самое большее одна вершина
это соответствует ту модель.

Например, учитывая два ограничения уникальности на:Person (идентификатор) и:Person (ssn):
тогда запрос, такой как СЛИЯНИЕ (n:Person {идентификатор: 12, ssn: 437}), перестанет работать, если там
две различных вершины (один с идентификатором 12 и один с ssn 437) или если есть
только одна вершина с только одним из свойств. Другими словами, должен быть
точно одна вершина, которая соответствует модель, или никакие вершины соответствия.

Заметьте, что следующие примеры принимают существование ограничений уникальности
это было создано, используя:

СОЗДАЙТЕ ОГРАНИЧЕНИЕ НА (n:Person), УТВЕРЖДАЮТ n.name УНИКАЛЬНЫЙ IS;
СОЗДАЙТЕ ОГРАНИЧЕНИЕ НА (n:Person), УТВЕРЖДАЮТ n.role УНИКАЛЬНЫЙ IS;

11.3.5.1. Слияние используя уникальные ограничения создает новую вершину, если никакая вершина не найдена

Слияние используя уникальные ограничения создает новую вершину, если никакая вершина не найдена.

Запрос.

СЛИЯНИЕ (laurence:Person {имя: 'Лоуренс Фишберн'})
ВОЗВРАТИТЕ laurence

Запрос создает laurence вершину. Если laurence уже существовал, слияние было бы
только возвратите существующую вершину.

Таблица 11.25. Результат

+----------------------------------+
|laurence |
|----------------------------------|
|1 строка |
|----------------------------------|
|Nodes создал: 1 |
|----------------------------------|
|Properties устанавливают: 1 |
|----------------------------------|
|Labels добавлялся: 1 |
|----------------------------------|
|Node [8] {имя: "Лоуренс Фишберн"} |
+----------------------------------+


11.3.5.2. Слияние используя уникальные ограничения соответствует существующую вершину

Слияние используя уникальные ограничения соответствует существующую вершину.

Запрос.

СЛИЯНИЕ (oliver:Person {называют:' Оливера Стоуна'}),
ВОЗВРАТИТЕ oliver

oliver вершина уже существует, таким образом, слияние только возвращает ее.

Таблица 11.26. Результат

+----------------------------+
|oliver |
|----------------------------|
|1 строка |
|----------------------------|
|Node [0] {имя: "Оливер Стоун"} |
+----------------------------+


11.3.5.3. Слияние с уникальными ограничениями и частичными соответствиями

Слияние используя уникальные ограничения перестало работать, обнаруживая частичные соответствия.

Запрос.

СЛИЯНИЕ (michael:Person {называют:' Майкла Дугласа, роль:' Гордон Гекко'}),
ВОЗВРАТИТЕ michael

В то время как есть соответствующая уникальная michael вершина с именем Майкл Дуглас,
нет никакой уникальной вершины с ролью Гордона Гекко, и слияние не в состоянии соответствовать.

Сообщение об ошибке.

Слияние не обнаруживало соответствующую вершину и не может создать новый сбор вершины к конфликтам
и с существующими и с пропускающими уникальными вершинами. Конфликтные ограничения идут:
:Person.name и:Person.role

11.3.5.4. Слияние с уникальными ограничениями и конфликтными соответствиями

Слияние используя уникальные ограничения перестало работать, обнаруживая конфликтные соответствия.

Запрос.

СЛИЯНИЕ (oliver:Person {называют:' Оливера Стоуна', роль:' Гордон Гекко'}),
ВОЗВРАТИТЕ oliver

В то время как есть соответствующая уникальная oliver вершина с именем Оливер Стоун, там
также другая уникальная вершина с ролью Гордона Гекко, и слияние перестало работать к
соответствие.

Сообщение об ошибке.

Слияние не обнаруживало соответствующую вершину и не может создать новый сбор вершины к конфликтам
и с существующими и с пропускающими уникальными вершинами. Конфликтные ограничения идут:
:Person.name и:Person.role

11.3.6. Используя параметры карты со СЛИЯНИЕМ

СЛИЯНИЕ не поддерживает параметры карты, любят, например СОЗДАЮТ, делает. Использовать карту
параметры со СЛИЯНИЕМ, необходимо явно использовать ожидаемый
свойства, как в следующем примере. Для получения дополнительной информации по параметрам,
см. Раздел 7.5, "Параметры".

Параметры.

{
  "param": {
    "имя": "Киану Ривз",
    "роль": "Нео"
  }
}

Запрос.

СЛИЯНИЕ (oliver:Person {имя: {param}.name, роль: {param}.role})
ВОЗВРАТИТЕ oliver

Таблица 11.27. Результат

+---------------------------------------+
|oliver |
|---------------------------------------|
|1 строка |
|---------------------------------------|
|Nodes создал: 1 |
|---------------------------------------|
|Properties устанавливают: 2 |
|---------------------------------------|
|Labels добавлялся: 1 |
|---------------------------------------|
|Node [8] {имя: "Киану Ривз", роль: "Нео"} |
+---------------------------------------+


11.4. Набор

11.4.1. Установите свойство
11.4.2. Переместите свойство
11.4.3. Копирование свойств между вершинами и отношениями
11.4.4. Установите свойство, используя параметр
11.4.5. Установите все свойства, используя параметр
11.4.6. Установите метку на вершине
11.4.7. Установите разнообразные метки на вершине

Обновление меток на вершинах и свойств на вершинах и отношениях сделано с
пункт НАБОРА. НАБОР Может также использоваться с картами от параметров, чтобы установить
свойства.

Замечание

Установка меток на вершине является идемпотентными операциями  - , если Вы пытаетесь установить a
метка на вершине, у которой уже есть та метка на этом, ничто не происходит. Запрос
статистика скажет Вам, если что-то должно было быть сделано или нет.

Примеры используют этот график в качестве начальной точки:

cypher-set-graph.svg

11.4.1. Установите свойство

Чтобы установить свойство на вершине или отношении, используйте НАБОР.

Запрос.

СООТВЕТСТВИЕ (n {имя: 'Андрес'})
НАБОР n.surname = 'Тэйлор'
ВОЗВРАТИТЕ n

Недавно измененная вершина возвращена запросом.

Таблица 11.28. Результат

+-----------------------------------------------------------+
|n |
|-----------------------------------------------------------|
|1 строка |
|-----------------------------------------------------------|
|Properties устанавливают: 1 |
|-----------------------------------------------------------|
|Node [3] {имя: "Андрес", age:36, awesome:true, фамилия: "Тейлор"} |
+-----------------------------------------------------------+


11.4.2. Переместите свойство

Обычно Вы перемещаете свойство при использовании ПЕРЕМЕЩЕНИЯ, но это иногда поворотливо сделать
это использующий команду SET. Один пример - то, если свойство прибывает из a
параметр.

Запрос.

СООТВЕТСТВИЕ (n {имя: 'Андрес'})
НАБОР n.name = НУЛЬ ВОЗВРАЩАЕТ n

Вершина возвращена запросом, и свойство имени теперь пропускает.

Таблица 11.29. Результат

+----------------------------+
|n |
|----------------------------|
|1 строка |
|----------------------------|
|Properties устанавливают: 1 |
|----------------------------|
|Node [3] {age:36, awesome:true} |
+----------------------------+


11.4.3. Копирование свойств между вершинами и отношениями

Вы можете также использовать НАБОР, чтобы скопировать все свойства от одного элемента графика до другого.
Помните, что выполнение этого переместит все другие свойства на получении
элемент графика.

Запрос.

СООТВЕТСТВИЕ (в {имя: 'Андрес'}), (pn {имя: 'Питер'})
НАБОР в = pn
ВОЗВРАТИТЕСЬ в, pn

У вершины Андреса было все, что это - свойства, замененные свойствами в
Вершина Питера.

Таблица 11.30. Результат

+---------------------------------------------------------+
|at |pn |
|---------------------------------------------------------|
|1 строка |
|---------------------------------------------------------|
|Properties устанавливают: 3 |
|---------------------------------------------------------|
|Node [3] {age:34, имя: "Питер"} |Node [2] {имя: "Питер", age:34} |
+---------------------------------------------------------+


11.4.4. Установите свойство, используя параметр

Используйте параметр, чтобы дать значение свойства.

Параметры.

{
  "фамилия": "Тейлор"
}

Запрос.

СООТВЕТСТВИЕ (n {имя: 'Андрес'})
НАБОР n.surname = {фамилия}
ВОЗВРАТИТЕ n

Вершине Андреса прибавляли фамилию.

Таблица 11.31. Результат

+-----------------------------------------------------------+
|n |
|-----------------------------------------------------------|
|1 строка |
|-----------------------------------------------------------|
|Properties устанавливают: 1 |
|-----------------------------------------------------------|
|Node [3] {имя: "Андрес", age:36, awesome:true, фамилия: "Тейлор"} |
+-----------------------------------------------------------+


11.4.5. Установите все свойства, используя параметр

Это заменит все существующие свойства на вершине с новым обеспеченным набором
параметром.

Параметры.

{
  "опоры": {
    "имя": "Андрес",
    "позиция": "Разработчик"
  }
}

Запрос.

СООТВЕТСТВИЕ (n {имя: 'Андрес'})
НАБОР n = {опоры}
ВОЗВРАТИТЕ n

У вершины Андреса было все, что это - свойства, замененные свойствами в
параметр опор.

Таблица 11.32. Результат

+-------------------------------------------+
|n |
|-------------------------------------------|
|1 строка |
|-------------------------------------------|
|Properties устанавливают: 4 |
|-------------------------------------------|
|Node [3] {позиция: "Разработчик", имя: "Андрес"} |
+-------------------------------------------+


11.4.6. Установите метку на вершине

Чтобы установить метку на вершине, используйте НАБОР.

Запрос.

СООТВЕТСТВИЕ (n {имя: 'Штефан'})
НАБОР n:German
ВОЗВРАТИТЕ n

Недавно маркированная вершина возвращена запросом.

Таблица 11.33. Результат

+----------------------+
|n |
|----------------------|
|1 строка |
|----------------------|
|Labels добавлялся: 1 |
|----------------------|
|Node [1] {имя: "Штефан"} |
+----------------------+


11.4.7. Установите разнообразные метки на вершине

Чтобы установить разнообразные метки на вершине, используйте НАБОР и разделите различные метки
использование:.

Запрос.

СООТВЕТСТВИЕ (n {имя: 'Эмиль'})
НАБОР n:Swedish:Bossman
ВОЗВРАТИТЕ n

Недавно маркированная вершина возвращена запросом.

Таблица 11.34. Результат

+--------------------+
|n |
|--------------------|
|1 строка |
|--------------------|
|Labels добавлялся: 2 |
|--------------------|
|Node [0] {имя: "Эмиль"} |
+--------------------+


11.5. Стереть

11.5.1. Сотрите единственную вершину
11.5.2. Сотрите вершину и соединенные отношения
11.5.3. Сотрите все вершины и отношения

Стирая элементы графика  -  вершины и отношения, сделан с, СТИРАЮТ.

Для того, чтобы переместить свойства и метки, см. Раздел 11.6, "Перемещение".

Примеры начинаются со следующей базой данных:

cypher-delete-graph.svg

11.5.1. Сотрите единственную вершину

Чтобы стереть вершину, используйте СТИРАТЬ пункт.

Запрос.

СООТВЕТСТВИЕ (n {имя: 'Питер'})
СОТРИТЕ n

Ничто не возвращено из этого запроса, кроме количества вершин, на которые влияют.

Таблица 11.35. Результат

+----------------+
|Nodes стирал: 1 |
|----------------|
| (освободите результат), |
+----------------+


11.5.2. Сотрите вершину и соединенные отношения

Если Вы пытаетесь стереть вершину с отношениями на этом, Вы должны стереть
они также.

Запрос.

СООТВЕТСТВИЕ (n {имя: 'Андрес'}) - [r] - ()
СОТРИТЕ n, r

Ничто не возвращено из этого запроса, кроме количества вершин, на которые влияют.

Таблица 11.36. Результат

+------------------------+
|Nodes стирал: 1 |
|------------------------|
|Relationships стирал: 2 |
|------------------------|
| (освободите результат), |
+------------------------+


11.5.3. Сотрите все вершины и отношения

Этот запрос не для того, чтобы стереть большие объемы данных, но хорош, играя
вокруг с малыми наборами данных в качестве примера.

Запрос.

СООТВЕТСТВИЕ (n)
ДОПОЛНИТЕЛЬНОЕ СООТВЕТСТВИЕ (n) - [r] - ()
СОТРИТЕ n, r

Ничто не возвращено из этого запроса, кроме количества вершин, на которые влияют.

Таблица 11.37. Результат

+------------------------+
|Nodes стирал: 3 |
|------------------------|
|Relationships стирал: 2 |
|------------------------|
| (освободите результат), |
+------------------------+


11.6. Перемещение

11.6.1. Переместите свойство
11.6.2. Переместите метку от вершины
11.6.3. Передвижение разнообразных меток

Передвижение свойств и меток от элементов графика сделано, используя ПЕРЕМЕЩЕНИЕ.

Для того, чтобы стереть вершины и отношения, см. Раздел 11.5, "Стереть".

Замечание

Передвижение меток от вершины является идемпотентной работой: Если Вы пытаетесь переместить a
метка от вершины, у которой нет той метки на этом, ничто не происходит.
статистика запроса скажет Вам, если что-то должно было быть сделано или нет.

Примеры начинаются со следующей базой данных:

cypher-remove-graph.svg

11.6.1. Переместите свойство

Neo4j не позволяет хранить нуль в свойствах. Вместо этого если никакое значение не существует,
свойство только не там. Так, чтобы переместить значение свойства на вершине или a
отношение, также сделан с ПЕРЕМЕЩЕНИЕМ.

Запрос.

СООТВЕТСТВИЕ (andres {имя: 'Андрес'})
ПЕРЕМЕЩЕНИЕ andres.age
ВОЗВРАТИТЕ andres

Вершина возвращена, и никакой возраст свойства не существует на ней.

Таблица 11.38. Результат

+----------------------+
|andres |
|----------------------|
|1 строка |
|----------------------|
|Properties устанавливают: 1 |
|----------------------|
|Node [2] {имя: "Андрес"} |
+----------------------+


11.6.2. Переместите метку от вершины

Чтобы переместить метки, Вы используете ПЕРЕМЕЩЕНИЕ.

Запрос.

СООТВЕТСТВИЕ (n {имя: 'Питер'})
ПЕРЕМЕЩЕНИЕ n:German
ВОЗВРАТИТЕ n

Таблица 11.39. Результат

+----------------------------+
|n |
|----------------------------|
|1 строка |
|----------------------------|
|Labels переместил: 1 |
|----------------------------|
|Node [1] {имя: "Питер", age:34} |
+----------------------------+


11.6.3. Передвижение разнообразных меток

Чтобы переместить разнообразные метки, Вы используете ПЕРЕМЕЩЕНИЕ.

Запрос.

СООТВЕТСТВИЕ (n {имя: 'Питер'})
ПЕРЕМЕЩЕНИЕ n:German:Swedish
ВОЗВРАТИТЕ n

Таблица 11.40. Результат

+----------------------------+
|n |
|----------------------------|
|1 строка |
|----------------------------|
|Labels переместил: 2 |
|----------------------------|
|Node [1] {имя: "Питер", age:34} |
+----------------------------+


11.7. Foreach

11.7.1. Отметьте все вершины вдоль пути

Наборы и пути - ключевые понятия в Коде. Использовать их для того, чтобы обновить
данные, Вы можете использовать конструкцию FOREACH. Это позволяет Вам делать команды обновления
на элементах в наборе  -  путь, или набор создан агрегацией.

Контекст идентификатора в foreach круглой скобке является отдельным от
один снаружи. Это означает это, если Вы СОЗДАЕТЕ идентификатор вершины в a
FOREACH, Вы не будете в состоянии использовать это за пределами foreach оператора,
если Вы не соответствуете, чтобы обнаружить это.

В круглых скобках FOREACH, Вы можете сделать любое обновление
команды  -  СОЗДАЮТ, СОЗДАЮТ УНИКАЛЬНЫЙ, СТИРАЮТ, и FOREACH.

Рисунок 11.2. Данные для примеров

cypher-foreach-graph.svg


11.7.1. Отметьте все вершины вдоль пути

Этот запрос установит свойство, отмеченное в истину на всех вершинах вдоль пути.

Запрос.

СООТВЕТСТВУЙТЕ p = (начинаются) - [*]-> (КОНЕЦ)
ГДЕ begin.name ='A' И КОНЕЦ.name ='D'
FOREACH (n В вершинах (p) | УСТАНАВЛИВАЕТ n.marked = ИСТИНА),

Ничто не возвращено из этого запроса, но четыре свойства установлены.

Таблица 11.41. Результат

+-----------------+
|Properties устанавливают: 4 |
|-----------------|
| (освободите результат), |
+-----------------+


Глава 12. Функции

Эта глава содержит информацию обо всех функциях в Коде. Заметьте, что это имело отношение
информация существует в Разделе 8.1, "Операторах".

Замечание

Большинство функций в Коде возвратит НУЛЬ, если входной параметр будет НУЛЕМ.

12.1. Предикаты

12.1.1. ВСЕ
12.1.2. ЛЮБОЙ
12.1.3. НИ ОДИН
12.1.4. ЕДИНСТВЕННЫЙ

Предикаты - булевы функции, которые возвращают истину или ложь для данного набора
ввод. Они обычно используются, чтобы отфильтровать подграфы в ГДЕ часть
запрос.

См. также Раздел 8.1.2, "Операторы сравнения".

Рисунок 12.1. График

cypher-functions-graph.svg


12.1.1. ВСЕ

Тесты, содержит ли предикат для всего элемента этого набора набора.

Синтаксис: ВСЕ (идентификатор в наборе, ГДЕ предикат)

Параметры:

  * набор: выражение, которое возвращает набор
  * идентификатор: Это - идентификатор, который может использоваться от предиката.
  * предикат: предикат, который протестирован против всех элементов в наборе.

Запрос.

СООТВЕТСТВУЙТЕ p = (a) - [*1.. 3]-> (b)
ГДЕ a.name =' Элис' И b.name =' Даниэль' И ВСЕ (x В вершинах (p), ГДЕ x.age> 30)
ВОЗВРАТИТЕ p

У всех вершин в возвращенных путях будет свойство возраста по крайней мере 30.

Таблица 12.1. Результат

+-----------------------------------------------------------------------------+
|p |
|-----------------------------------------------------------------------------|
|1 строка |
|-----------------------------------------------------------------------------|
| [Вершина [2] {имя: "Элис", age:38, глаза: "коричневый цвет"}:KNOWS [1] {}, Вершина [4] |
| {имя: "Чарли", age:53, глаза: "зелень"}:KNOWS [3] {}, Вершина [0] |
| {имя: "Даниэль", age:54, глаза: "коричневый цвет"}] |
+-----------------------------------------------------------------------------+


12.1.2. ЛЮБОЙ

Тесты, содержит ли предикат по крайней мере для одного элемента в наборе.

Синтаксис: ЛЮБОЙ (идентификатор в наборе, ГДЕ предикат)

Параметры:

  * набор: выражение, которое возвращает набор
  * идентификатор: Это - идентификатор, который может использоваться от предиката.
  * предикат: предикат, который протестирован против всех элементов в наборе.

Запрос.

СООТВЕТСТВИЕ (a)
ГДЕ a.name ='Eskil' И ЛЮБОЙ (x В a.array, ГДЕ x = "один")
ВОЗВРАТИТЕ a

У всех вершин в возвращенных путях есть по крайней мере один один набор значений в массиве
свойство назвало массив.

Таблица 12.2. Результат

+--------------------------------------------------------------------+
|a |
|--------------------------------------------------------------------|
|1 строка |
|--------------------------------------------------------------------|
|Node [1] {имя: "Eskil", age:41, глаза: "синий", массив: ["один", "два", "три"]} |
+--------------------------------------------------------------------+


12.1.3. НИ ОДИН

Возвращает true, если предикат не содержит ни для какого элемента в наборе.

Синтаксис: НИ ОДИН (идентификатор в наборе, ГДЕ предикат)

Параметры:

  * набор: выражение, которое возвращает набор
  * идентификатор: Это - идентификатор, который может использоваться от предиката.
  * предикат: предикат, который протестирован против всех элементов в наборе.

Запрос.

СООТВЕТСТВУЙТЕ p = (n) - [*1.. 3]-> (b)
ГДЕ n.name =' Элис' И НИ ОДИН (x В вершинах (p), ГДЕ x.age = 25)
ВОЗВРАТИТЕ p

Ни у каких вершин в возвращенных путях нет набора свойств возраста к 25.

Таблица 12.3. Результат

+-----------------------------------------------------------------------------+
|p |
|-----------------------------------------------------------------------------|
|2 строки |
|-----------------------------------------------------------------------------|
| [Вершина [2] {имя: "Элис", age:38, глаза: "коричневый цвет"}:KNOWS [1] {}, Вершина [4] |
| {имя: "Чарли", age:53, глаза: "зелень"}] |
|-----------------------------------------------------------------------------|
| [Вершина [2] {имя: "Элис", age:38, глаза: "коричневый цвет"}:KNOWS [1] {}, Вершина [4] |
| {имя: "Чарли", age:53, глаза: "зелень"}:KNOWS [3] {}, Вершина [0] |
| {имя: "Даниэль", age:54, глаза: "коричневый цвет"}] |
+-----------------------------------------------------------------------------+


12.1.4. ЕДИНСТВЕННЫЙ

Возвращает true, если предикат содержит для точно одного из элементов в
набор.

Синтаксис: ЕДИНСТВЕННЫЙ (идентификатор в наборе, ГДЕ предикат)

Параметры:

  * набор: выражение, которое возвращает набор
  * идентификатор: Это - идентификатор, который может использоваться от предиката.
  * предикат: предикат, который протестирован против всех элементов в наборе.

Запрос.

СООТВЕТСТВУЙТЕ p = (n)-> (b)
ГДЕ n.name =' Элис' И ЕДИНСТВЕННЫЙ (var В вершинах (p), ГДЕ var.eyes = "синий")
ВОЗВРАТИТЕ p

Точно у одной вершины в каждом возвращенном пути будет глазной набор свойств к
"синий".

Таблица 12.4. Результат

+-----------------------------------------------------------------------------+
|p |
|-----------------------------------------------------------------------------|
|1 строка |
|-----------------------------------------------------------------------------|
| [Вершина [2] {имя: "Элис", age:38, глаза: "коричневый цвет"}:KNOWS [0] {}, Вершина [3] |
| {имя: "Отвес", age:25, глаза: "синий"}] |
+-----------------------------------------------------------------------------+


12.2. Скалярные функции

12.2.1. ДЛИНА
12.2.2. ВВЕСТИ
12.2.3. ID
12.2.4. ОБЪЕДИНИТЬ
12.2.5. ГОЛОВА
12.2.6. ПОСЛЕДНИЙ
12.2.7. МЕТКА ВРЕМЕНИ
12.2.8. STARTNODE
12.2.9. ENDNODE

Скалярные функции возвращают единственное значение.

Рисунок 12.2. График

cypher-functions-graph.svg


12.2.1. ДЛИНА

Чтобы возвратить или фильтровать на длине набора, используйте ДЛИНУ () функция.

Синтаксис: ДЛИНА (набор)

Параметры:

  * набор: выражение, которое возвращает набор

Запрос.

СООТВЕТСТВУЙТЕ p = (a)-> (b)-> (c)
ГДЕ a.name =' Элис'
ВОЗВРАТИТЕ длину (p)

Длина пути p возвращена запросом.

Таблица 12.5. Результат

+---------+
|length (p) |
|---------|
|3 строки |
|---------|
|2 |
|---------|
|2 |
|---------|
|2 |
+---------+


12.2.2. ВВЕСТИ

Возвращает строковое представление типа отношения.

Синтаксис: ВВЕДИТЕ (отношение)

Параметры:

  * отношение: отношение.

Запрос.

СООТВЕТСТВИЕ (n) - [r]-> ()
ГДЕ n.name =' Элис'
ВОЗВРАТИТЕ тип (r)

Тип отношения r возвращен запросом.

Таблица 12.6. Результат

+-------+
|type (r) |
|-------|
|2 строки |
|-------|
| "ЗНАЕТ" |
|-------|
| "ЗНАЕТ" |
+-------+


12.2.3. ID

Возвращает идентификатор отношения или вершины.

Синтаксис: ID (контейнер свойства)

Параметры:

  * контейнер свойства: вершина или отношение.

Запрос.

СООТВЕТСТВИЕ (a)
ВОЗВРАТИТЕ идентификатор (a)

Это возвращает идентификатор вершины для трех вершин.

Таблица 12.7. Результат

+------+
|id (a) |
|------|
|5 строк |
|------|
|0 |
|------|
|1 |
|------|
|2 |
|------|
|3 |
|------|
|4 |
+------+


12.2.4. ОБЪЕДИНИТЬ

Возвращается первое НЕНУЛЕВОЕ ЗНАЧЕНИЕ в списке выражений передало к этому. В
случай все параметры - НУЛЬ, НУЛЬ, будет возвращен.

Синтаксис: ОБЪЕДИНИТЕ (выражение [выражение] *)

Параметры:

  * выражение: выражение, которое могло бы возвратить НУЛЬ.

Запрос.

СООТВЕТСТВИЕ (a)
ГДЕ a.name =' Элис'
ВОЗВРАТ объединяет (a.hairColor, a.eyes)

Таблица 12.8. Результат

+-----------------------------+
|coalesce (a.hairColor, a.eyes) |
|-----------------------------|
|1 строка |
|-----------------------------|
| "коричневый цвет" |
+-----------------------------+


12.2.5. ГОЛОВА

ВОЗГЛАВЬТЕ возвращает первый элемент в наборе.

Синтаксис: ГОЛОВА (выражение)

Параметры:

  * выражение: Это выражение должно возвратить набор некоторого вида.

Запрос.

СООТВЕТСТВИЕ (a)
ГДЕ a.name ='Eskil'
ВОЗВРАТИТЕ a.array, возглавьте (a.array)

Первая вершина в пути возвращена.

Таблица 12.9. Результат

+-----------------------------------+
|a.array |head (a.array) |
|-----------------------------------|
|1 строка |
|-----------------------------------|
| ["один", "два", "три"] | "один" |
+-----------------------------------+


12.2.6. ПОСЛЕДНИЙ

ПРОДЛИТЕСЬ возвраты последний элемент в наборе.

Синтаксис: ПОСЛЕДНИЙ (выражение)

Параметры:

  * выражение: Это выражение должно возвратить набор некоторого вида.

Запрос.

СООТВЕТСТВИЕ (a)
ГДЕ a.name ='Eskil'
ВОЗВРАТИТЕ a.array, последний (a.array)

Последняя вершина в пути возвращена.

Таблица 12.10. Результат

+-----------------------------------+
|a.array |last (a.array) |
|-----------------------------------|
|1 строка |
|-----------------------------------|
| ["один", "два", "три"] | "три" |
+-----------------------------------+


12.2.7. МЕТКА ВРЕМЕНИ

УСТАНОВИТЕ МЕТКУ ВРЕМЕНИ возвращает разность, измеренную в миллисекундах, между током
время и полночь, 1 января 1970 UTC. Это возвратит то же самое значение во время
целый запрос, даже если запрос - длинное выполнение того.

Синтаксис: МЕТКА ВРЕМЕНИ ()

Параметры:

Запрос.

ВОЗВРАТИТЕ метку времени ()

Время в миллисекундах возвращено.

Таблица 12.11. Результат

+-------------+
|timestamp () |
|-------------|
|1 строка |
|-------------|
|1386514453776 |
+-------------+


12.2.8. STARTNODE

STARTNODE возвращает запускающуюся вершину отношения

Синтаксис: STARTNODE (отношение)

Параметры:

  * отношение: выражение, которое возвращает отношение

Запрос.

СООТВЕТСТВИЕ (x:foo) - [r] - ()
ВОЗВРАТИТЕ startNode (r)

Таблица 12.12. Результат

+-----------------------------------------+
|startNode (r) |
|-----------------------------------------|
|2 строки |
|-----------------------------------------|
|Node [2] {имя: "Элис", age:38, глаза: "коричневый цвет"} |
|-----------------------------------------|
|Node [2] {имя: "Элис", age:38, глаза: "коричневый цвет"} |
+-----------------------------------------+


12.2.9. ENDNODE

ENDNODE возвращает конечный узел отношения

Синтаксис: ENDNODE (отношение)

Параметры:

  * отношение: выражение, которое возвращает отношение

Запрос.

СООТВЕТСТВИЕ (x:foo) - [r] - ()
ВОЗВРАТИТЕ endNode (r)

Таблица 12.13. Результат

+-------------------------------------------+
|endNode (r) |
|-------------------------------------------|
|2 строки |
|-------------------------------------------|
|Node [3] {имя: "Отвес", age:25, глаза: "синий"} |
|-------------------------------------------|
|Node [4] {имя: "Чарли", age:53, глаза: "зелень"} |
+-------------------------------------------+


12.3. Функции набора

12.3.1. ВЕРШИНЫ
12.3.2. ОТНОШЕНИЯ
12.3.3. МЕТКИ
12.3.4. ВЫТЯЖКА
12.3.5. ФИЛЬТР
12.3.6. ОСТАТОК
12.3.7. ДИАПАЗОН
12.3.8. ПОНИЗИТЬ

Набор функционирует наборы возврата вещей  -  вершины в пути, и так далее.

См. также Раздел 8.1.5, “Операторы набора”.

Рисунок 12.3. График

cypher-functions-graph.svg


12.3.1. ВЕРШИНЫ

Возвраты все вершины в пути.

Синтаксис: ВЕРШИНЫ (путь)

Параметры:

  * путь: путь.

Запрос.

СООТВЕТСТВУЙТЕ p = (a)-> (b)-> (c)
ГДЕ a.name =' Элис' И c.name ='Eskil'
ВОЗВРАТИТЕ вершины (p)

Все вершины в пути p возвращены запросом в качестве примера.

Таблица 12.14. Результат

+-----------------------------------------------------------------------------+
|nodes (p) |
|-----------------------------------------------------------------------------|
|1 строка |
|-----------------------------------------------------------------------------|
| [Вершина [2] {имя: "Элис", age:38, глаза: "коричневый цвет"}, Вершина [3] |
| {имя: "Отвес", age:25, глаза: "синий"}, Вершина [1] |
| {имя: "Eskil", age:41, глаза: "синий", массив: ["один", "два", "три"]}] |
+-----------------------------------------------------------------------------+


12.3.2. ОТНОШЕНИЯ

Возвраты все отношения в пути.

Синтаксис: ОТНОШЕНИЯ (путь)

Параметры:

  * путь: путь.

Запрос.

СООТВЕТСТВУЙТЕ p = (a)-> (b)-> (c)
ГДЕ a.name =' Элис' И c.name ='Eskil'
ВОЗВРАТИТЕ отношения (p)

Все отношения в пути p возвращены.

Таблица 12.15. Результат

+---------------------------+
|relationships (p) |
|---------------------------|
|1 строка |
|---------------------------|
| [:KNOWS [0] {}:MARRIED [4] {}] |
+---------------------------+


12.3.3. МЕТКИ

Возвращает набор строковых представлений для меток, присоединенных к a
вершина.

Синтаксис: МЕТКИ (вершина)

Параметры:

  * вершина: Любое выражение, которое возвращает единственную вершину

Запрос.

СООТВЕТСТВИЕ (a)
ГДЕ a.name =' Элис'
ВОЗВРАТИТЕ метки (a)

Метки n возвращены запросом.

Таблица 12.16. Результат

+-------------+
|labels (a) |
|-------------|
|1 строка |
|-------------|
| ["foo", "бар"] |
+-------------+


12.3.4. ВЫТЯЖКА

Возвратить единственное свойство, или значение функции от набора
вершины или отношения, Вы можете использовать ВЫТЯЖКУ. Это пройдет через набор,
выполните выражение на каждом элементе, и возвратите результаты в наборе
с этими значениями. Это работает как метод карты на функциональных языках такой как
Lisp и Скала.

Синтаксис: ВЫТЯЖКА (идентификатор в наборе | выражение)

Параметры:

  * набор: выражение, которое возвращает набор
  * идентификатор: закрытию представят идентификатор в, это - контекст.
    Здесь Вы решаете который идентификатор использовать.
  * выражение: Это выражение будет работать однажды на значение в наборе, и
    производит набор результата.

Запрос.

СООТВЕТСТВУЙТЕ p = (a)-> (b)-> (c)
ГДЕ a.name =' Элис' И b.name =' Боб' И c.name =' Даниэль'
ВОЗВРАТИТЕ вытяжку (n В вершинах (p) | n.age) извлеченный AS

Свойство возраста всех вершин в пути возвращено.

Таблица 12.17. Результат

+----------+
|extracted |
|----------|
|1 строка |
|----------|
| [38,25,54] |
+----------+


12.3.5. ФИЛЬТР

ФИЛЬТРУЙТЕ возвращает все элементы в наборе, которые подчиняются к предикату.

Синтаксис: ФИЛЬТР (идентификатор в наборе, ГДЕ предикат)

Параметры:

  * набор: выражение, которое возвращает набор
  * идентификатор: Это - идентификатор, который может использоваться от предиката.
  * предикат: предикат, который протестирован против всех элементов в наборе.

Запрос.

СООТВЕТСТВИЕ (a)
ГДЕ a.name ='Eskil'
ВОЗВРАТИТЕ a.array, фильтр (x В a.array ГДЕ длина (x) = 3)

Это возвращает свойство, названное массивом и списком значений в этом, которые имеют
длина 3.

Таблица 12.18. Результат

+--------------------------------------------------------------+
|a.array |filter (x в a.array, ГДЕ длина (x) = 3) |
|--------------------------------------------------------------|
|1 строка |
|--------------------------------------------------------------|
| ["один", "два", "три"] | ["один", "два"] |
+--------------------------------------------------------------+


12.3.6. ОСТАТОК

ОСТАТОК возвращает всех кроме первого элемента в наборе.

Синтаксис: ОСТАТОК (выражение)

Параметры:

  * выражение: Это выражение должно возвратить набор некоторого вида.

Запрос.

СООТВЕТСТВИЕ (a)
ГДЕ a.name ='Eskil'
ВОЗВРАТИТЕ a.array, остаток (a.array)

Это возвращает свойство, названное массивом и всеми элементами того свойства кроме
первый.

Таблица 12.19. Результат

+-------------------------------------+
|a.array |tail (a.array) |
|-------------------------------------|
|1 строка |
|-------------------------------------|
| ["один", "два", "три"] | ["два", "три"] |
+-------------------------------------+


12.3.7. ДИАПАЗОН

Численные значения возвратов в диапазоне с ненулевым шагом оценивают шаг. Диапазон
включительно в обоих концах.

Синтаксис: ДИАПАЗОН (запускаются, конец [шаг]),

Параметры:

  * запустите: численное выражение.
  * конец: численное выражение.
  * шаг: численное выражение.

Запрос.

ВОЗВРАТИТЕ диапазон (0,10), диапазон (2,18,3)

Возвращены два списка номеров.

Таблица 12.20. Результат

+-----------------------------------------+
|range (0,10) |range (2,18,3) |
|-----------------------------------------|
|1 строка |
|-----------------------------------------|
| [0,1,2,3,4,5,6,7,8,9,10] | [2,5,8,11,14,17] |
+-----------------------------------------+


12.3.8. ПОНИЗИТЬ

Выполнять выражение против индивидуальных элементов набора, и хранить
результат выражения в аккумуляторе, Вы можете использовать, ПОНИЖАЮТ. Это пойдет
через набор, выполненный выражение на каждом элементе, храня частичное
результат в аккумуляторе. Это работает как сгиб, или понизьте метод в
функциональные языки, такие как Lisp и Скала.

Синтаксис: ПОНИЗЬТЕ (аккумулятор = начальная буква, идентификатор в наборе | выражение)

Параметры:

  * аккумулятор: идентификатор, который будет содержать результат и частичное
    результаты как набор выполнены с помощью итераций
  * начальная буква: выражение, которое работает однажды дать начальное значение
    аккумулятор
  * набор: выражение, которое возвращает набор
  * идентификатор: закрытию представят идентификатор в, это - контекст.
    Здесь Вы решаете который идентификатор использовать.
  * выражение: Это выражение будет работать однажды на значение в наборе, и
    производит значение результата.

Запрос.

СООТВЕТСТВУЙТЕ p = (a)-> (b)-> (c)
ГДЕ a.name =' Элис' И b.name =' Боб' И c.name =' Даниэль'
ВОЗВРАТ понижает (totalAge = 0, n В вершинах (p) | totalAge + n.age) понижение AS

Свойство возраста всех вершин в пути суммировано и возвращено как единственное
значение.

Таблица 12.21. Результат

+---------+
|reduction |
|---------|
|1 строка |
|---------|
|117 |
+---------+


12.4. Математические функции

12.4.1. ABS
12.4.2. ACOS
12.4.3. ASIN
12.4.4. ATAN
12.4.5. ATAN2
12.4.6. COS
12.4.7. РАСКЛАДУШКА
12.4.8. ГРАДУСЫ
12.4.9. E
12.4.10. EXP
12.4.11. ПОЛ
12.4.12. HAVERSIN
12.4.13. ЖУРНАЛ
12.4.14. LOG10
12.4.15. PI
12.4.16. РАДИАНЫ
12.4.17. РАНТ
12.4.18. ОКРУЖНОСТЬ
12.4.19. ЗНАК
12.4.20. ГРЕХ
12.4.21. SQRT
12.4.22. ДУБИЛЬНАЯ КОРА

Эти функции все работают по численным выражениям только, и возвратятся
погрешность если использующийся на любых других значениях.

См. также Раздел 8.1.1, "Математические операторы".

Рисунок 12.4. График

cypher-functions-graph.svg


12.4.1. ABS

ABS возвращает абсолютное значение номера.

Синтаксис: ABS (выражение)

Параметры:

  * выражение: числовое выражение.

Запрос.

СООТВЕТСТВИЕ (a), (e)
ГДЕ a.name = 'Элис' И e.name = 'Eskil'
ВОЗВРАТИТЕ a.age, e.age, abs (a.age - e.age)

Абсолютное значение возрастных различий возвращено.

Таблица 12.22. Результат

+-------------------------------+
|a.age|e.age|abs (a.age - e.age) |
|-------------------------------|
|1 строка |
|-------------------------------|
|38 |41 |3.0 |
+-------------------------------+


12.4.2. ACOS

ACOS возвращает arccosine выражения, в радианах.

Синтаксис: ACOS (выражение)

Параметры:

  * выражение: числовое выражение.

Запрос.

ВОЗВРАТИТЕ acos (0.5)

arccosine 0.5.

Таблица 12.23. Результат

+------------------+
|acos (0.5) |
|------------------|
|1 строка |
|------------------|
|1.0471975511965979 |
+------------------+


12.4.3. ASIN

ASIN возвращает arcsine выражения, в радианах.

Синтаксис: ASIN (выражение)

Параметры:

  * выражение: числовое выражение.

Запрос.

ВОЗВРАТИТЕ asin (0.5)

arcsine 0.5.

Таблица 12.24. Результат

+------------------+
|asin (0.5) |
|------------------|
|1 строка |
|------------------|
|0.5235987755982989 |
+------------------+


12.4.4. ATAN

ATAN возвращает арктангенс выражения, в радианах.

Синтаксис: ATAN (выражение)

Параметры:

  * выражение: числовое выражение.

Запрос.

ВОЗВРАТИТЕ atan (0.5)

Арктангенс 0.5.

Таблица 12.25. Результат

+------------------+
|atan (0.5) |
|------------------|
|1 строка |
|------------------|
|0.4636476090008061 |
+------------------+


12.4.5. ATAN2

ATAN2 возвращает arctangent2 ряда координат, в радианах.

Синтаксис: ATAN2 (выражение, выражение)

Параметры:

  * выражение: числовое выражение для y.
  * выражение: числовое выражение для x.

Запрос.

ВОЗВРАТИТЕ atan2 (0.5, 0.6)

arctangent2 0.5, 0.6.

Таблица 12.26. Результат

+------------------+
|atan2 (0.5, 0.6) |
|------------------|
|1 строка |
|------------------|
|0.6947382761967033 |
+------------------+


12.4.6. COS

COS возвращает косинус выражения.

Синтаксис: COS (выражение)

Параметры:

  * выражение: числовое выражение.

Запрос.

ВОЗВРАТИТЕСЬ потому что (0.5)

Косинус 0.5 возвращен.

Таблица 12.27. Результат

+------------------+
|cos (0.5) |
|------------------|
|1 строка |
|------------------|
|0.8775825618903728 |
+------------------+


12.4.7. РАСКЛАДУШКА

РАСКЛАДУШКА возвращает котангенс выражения.

Синтаксис: РАСКЛАДУШКА (выражение)

Параметры:

  * выражение: числовое выражение.

Запрос.

ВОЗВРАТИТЕ раскладушку (0.5)

Котангенс 0.5 возвращен.

Таблица 12.28. Результат

+-----------------+
|cot (0.5) |
|-----------------|
|1 строка |
|-----------------|
|1.830487721712452 |
+-----------------+


12.4.8. ГРАДУСЫ

ГРАДУСЫ преобразовывают радианы в градусы.

Синтаксис: ГРАДУСЫ (выражение)

Параметры:

  * выражение: числовое выражение.

Запрос.

ВОЗВРАТИТЕ градусы (3.14159)

Номер градусов в чем-то близко к пи.

Таблица 12.29. Результат

+------------------+
|degrees (3.14159) |
|------------------|
|1 строка |
|------------------|
|179.99984796050427 |
+------------------+


12.4.9. E

E возвращает константу, e.

Синтаксис: E (выражение)

Параметры:

Запрос.

ВОЗВРАТИТЕ e ()

Постоянный e возвращен (основа естественного журнала).

Таблица 12.30. Результат

+-----------------+
|e () |
|-----------------|
|1 строка |
|-----------------|
|2.718281828459045 |
+-----------------+


12.4.10. EXP

EXP возвращает значение e возведенный в степень выражения.

Синтаксис: EXP (выражение)

Параметры:

  * выражение: числовое выражение.

Запрос.

ВОЗВРАТИТЕ exp (2)

exp 2 возвращен: e^2.

Таблица 12.31. Результат

+----------------+
|exp (2) |
|----------------|
|1 строка |
|----------------|
|7.38905609893065 |
+----------------+


12.4.11. ПОЛ

НАСТЕЛИТЕ возвращает самое большое целое число, меньше чем или равное выражению.

Синтаксис: ПОЛ (выражение)

Параметры:

  * выражение: числовое выражение.

Запрос.

ВОЗВРАТИТЕ пол (0.9)

Пол 0.9 возвращен.

Таблица 12.32. Результат

+----------+
|floor (0.9) |
|----------|
|1 строка |
|----------|
|0.0 |
+----------+


12.4.12. HAVERSIN

HAVERSIN возвращает половину versine выражения.

Синтаксис: HAVERSIN (выражение)

Параметры:

  * выражение: числовое выражение.

Запрос.

ВОЗВРАТИТЕ haversin (0.5)

haversine 0.5 возвращен.

Таблица 12.33. Результат

+-------------------+
|haversin (0.5) |
|-------------------|
|1 строка |
|-------------------|
|0.06120871905481362 |
+-------------------+


12.4.12.1. Сферическое расстояние используя функцию haversin

Функция haversin может использоваться, чтобы вычислить расстояние на поверхности a
сфера между двумя точками (каждый данный их широтой и долготой). В этом
пример сферическое расстояние (в км) между Берлином в Германии (в lat 52.5,
lon 13.4), и Сан-Матео в Калифорнии (в lat 37.5, lon-122.3) вычислен
использование среднего наземного радиуса 6371 км.

Запрос.

СОЗДАЙТЕ (ber:City {lat: 52.5, lon: 13.4}), (sm:City {lat: 37.5, lon:-122.3})
ВОЗВРАТИТЕСЬ 2 * 6371 * asin (sqrt (haversin (радианы (sm.lat - ber.lat)) +, потому что (радианы (sm.lat)) *
  потому что (радианы (ber.lat)) * haversin (радианы (sm.lon - ber.lon)))) AS dist

Расстояние между Берлином и Сан-Матео возвращено (приблизительно 9129 км).

Таблица 12.34. Результат

+-----------------+
|dist |
|-----------------|
|1 строка |
|-----------------|
|Nodes создал: 2 |
|-----------------|
|Properties устанавливают: 4 |
|-----------------|
|Labels добавлялся: 2 |
|-----------------|
|9129.969740051658 |
+-----------------+


12.4.13. ЖУРНАЛ

ЗАРЕГИСТРИРУЙТЕ возвращает неперов логарифм выражения.

Синтаксис: ЖУРНАЛ (выражение)

Параметры:

  * выражение: числовое выражение.

Запрос.

ВОЗВРАТИТЕ журнал (27)

Журнал 27 возвращен.

Таблица 12.35. Результат

+-----------------+
|log (27) |
|-----------------|
|1 строка |
|-----------------|
|3.295836866004329 |
+-----------------+


12.4.14. LOG10

LOG10 возвращает основу 10 логарифмов выражения.

Синтаксис: LOG10 (выражение)

Параметры:

  * выражение: числовое выражение.

Запрос.

ВОЗВРАТИТЕ log10 (27)

log10 27 возвращен.

Таблица 12.36. Результат

+------------------+
|log10 (27) |
|------------------|
|1 строка |
|------------------|
|1.4313637641589874 |
+------------------+


12.4.15. PI

PI возвращает mathmatical постоянную пи.

Синтаксис: PI ()

Параметры:

Запрос.

ВОЗВРАТИТЕ пи ()

Постоянная пи возвращена.

Таблица 12.37. Результат

+-----------------+
|pi () |
|-----------------|
|1 строка |
|-----------------|
|3.141592653589793 |
+-----------------+


12.4.16. РАДИАНЫ

РАДИАНЫ преобразовывают градусы в радианы.

Синтаксис: РАДИАНЫ (выражение)

Параметры:

  * выражение: числовое выражение.

Запрос.

ВОЗВРАТИТЕ радианы (180)

Номер радианов в 180 возвращен (пи).

Таблица 12.38. Результат

+-----------------+
|radians (180) |
|-----------------|
|1 строка |
|-----------------|
|3.141592653589793 |
+-----------------+


12.4.17. РАНТ

РАНТ возвращает случайное двойное количество между 0 и 1.0.

Синтаксис: РАНТ (выражение)

Параметры:

  * выражение: числовое выражение.

Запрос.

ВОЗВРАТИТЕ рант () AS x1

Случайное число возвращено.

Таблица 12.39. Результат

+-------------------+
|x1 |
|-------------------|
|1 строка |
|-------------------|
|0.16105338985811957 |
+-------------------+


12.4.18. ОКРУЖНОСТЬ

ОКРУГЛИТЕ возвращает численное выражение, округленное к самому близкому целому числу.

Синтаксис: ОКРУЖНОСТЬ (выражение)

Параметры:

  * выражение: численное выражение.

Запрос.

ВОЗВРАТИТЕ окружность (3.141592)

Таблица 12.40. Результат

+---------------+
|round (3.141592) |
|---------------|
|1 строка |
|---------------|
|3 |
+---------------+


12.4.19. ЗНАК

ПОДПИШИТЕСЬ возвращает знак номера  -  нуль, если выражение - нуль,-1 для
любое отрицательное число, и 1 для любого положительного числа.

Синтаксис: ЗНАК (выражение)

Параметры:

  * выражение: численное выражение

Запрос.

ВОЗВРАТИТЕ знак (-17), знак (0.1)

Таблица 12.41. Результат

+-------------------+
|sign (-17) |sign (0.1) |
|-------------------|
|1 строка |
|-------------------|
|-1.0 |1.0 |
+-------------------+


12.4.20. ГРЕХ

ГРЕШИТЕ возвращает синус выражения.

Синтаксис: ГРЕХ (выражение)

Параметры:

  * выражение: числовое выражение.

Запрос.

ВОЗВРАТИТЕ грех (0.5)

Синус 0.5 возвращен.

Таблица 12.42. Результат

+-----------------+
|sin (0.5) |
|-----------------|
|1 строка |
|-----------------|
|0.479425538604203 |
+-----------------+


12.4.21. SQRT

SQRT возвращает квадратный корень номера.

Синтаксис: SQRT (выражение)

Параметры:

  * выражение: численное выражение

Запрос.

ВОЗВРАТИТЕ sqrt (256)

Таблица 12.43. Результат

+---------+
|sqrt (256) |
|---------|
|1 строка |
|---------|
|16.0 |
+---------+


12.4.22. ДУБИЛЬНАЯ КОРА

ДУБИТЕ возвращает касательную выражения.

Синтаксис: ДУБИЛЬНАЯ КОРА (выражение)

Параметры:

  * выражение: числовое выражение.

Запрос.

ВОЗВРАТИТЕ дубильную кору (0.5)

Касательная 0.5 возвращена.

Таблица 12.44. Результат

+------------------+
|tan (0.5) |
|------------------|
|1 строка |
|------------------|
|0.5463024898437905 |
+------------------+


12.5. Строковые функции

12.5.1. STR
12.5.2. ЗАМЕНА
12.5.3. ПОДСТРОКА
12.5.4. ЛЕВАЯ СТОРОНА
12.5.5. ПРАВО
12.5.6. LTRIM
12.5.7. RTRIM
12.5.8. ОБРЕЗАТЬ
12.5.9. НИЖЕ
12.5.10. ВЕРХНИЙ

Эти функции все работают по строковым выражениям только, и возвратятся
погрешность если использующийся на любых других значениях. Кроме STR (), который преобразовывает в строки.

См. также Раздел 8.1.4, “Представьте операторы в виде строки”.

Рисунок 12.5. График

cypher-functions-graph.svg


12.5.1. STR

STR возвращает строковое представление выражения.

Синтаксис: STR (выражение)

Параметры:

  * выражение: выражение, которое возвращает что-либо

Запрос.

ВОЗВРАТИТЕ str (1)

Таблица 12.45. Результат

+------+
|str (1) |
|------|
|1 строка |
|------|
| "1" |
+------+


12.5.2. ЗАМЕНА

ЗАМЕНИТЕ возвращает строку со строкой поиска, замененной строкой замены.
Это заменяет все возникновения.

Синтаксис: ЗАМЕНА (исходный, поиск, замена)

Параметры:

  * исходный: выражение, которое возвращает строку
  * поиск: выражение, которое возвращает строку, чтобы искать
  * замена: выражение, которое возвращает строку, чтобы заменить строку поиска
    с

Запрос.

ВОЗВРАТИТЕ замену ("привет", "l", "w")

Таблица 12.46. Результат

+--------------------------+
|replace ("привет", "l", "w") |
|--------------------------|
|1 строка |
|--------------------------|
| "hewwo" |
+--------------------------+


12.5.3. ПОДСТРОКА

Возвраты ПОДСТРОКИ, которые подстроку оригинала, с на основе 0 индексируют, запускаются и
длина. Если длина опущена, она возвращает подстроку из запуска до конца
из строки.

Синтаксис: ПОДСТРОКА (исходный, запустите [длина]),

Параметры:

  * исходный: выражение, которое возвращает строку
  * запустите: выражение, которое возвращает положительное число
  * длина: выражение, которое возвращает положительное число

Запрос.

ВОЗВРАТИТЕ подстроку ("привет", 1, 3), подстрока ("привет", 2)

Таблица 12.47. Результат

+----------------------------------------------+
|substring ("привет", 1, 3) |substring ("привет", 2) |
|----------------------------------------------|
|1 строка |
|----------------------------------------------|
| "эль" | "Лло" |
+----------------------------------------------+


12.5.4. ЛЕВАЯ СТОРОНА

ЛЕВАЯ СТОРОНА возвращает строку, содержащую левую сторону n символы исходной строки.

Синтаксис: ЛЕВАЯ СТОРОНА (исходный, длина)

Параметры:

  * исходный: выражение, которое возвращает строку
  * n: выражение, которое возвращает положительное число

Запрос.

ВОЗВРАТИТЕ левую сторону ("привет", 3)

Таблица 12.48. Результат

+----------------+
|left ("привет", 3) |
|----------------|
|1 строка |
|----------------|
| "hel" |
+----------------+


12.5.5. ПРАВО

ПРАВО возвращает строку, содержащую право n символы оригинала
строка.

Синтаксис: ПРАВО (исходный, длина)

Параметры:

  * исходный: выражение, которое возвращает строку
  * n: выражение, которое возвращает положительное число

Запрос.

ВОЗВРАТИТЕ право ("привет", 3)

Таблица 12.49. Результат

+-----------------+
|right ("привет", 3) |
|-----------------|
|1 строка |
|-----------------|
| "Лло" |
+-----------------+


12.5.6. LTRIM

LTRIM возвращает исходную строку с пробелом, удаленным от левой стороны.

Синтаксис: (исходный) LTRIM

Параметры:

  * исходный: выражение, которое возвращает строку

Запрос.

ВОЗВРАТИТЕ ltrim (" привет")

Таблица 12.50. Результат

+---------------+
|ltrim (" привет") |
|---------------|
|1 строка |
|---------------|
| "привет" |
+---------------+


12.5.7. RTRIM

RTRIM возвращает исходную строку с пробелом, удаленным от правой стороны.

Синтаксис: (исходный) RTRIM

Параметры:

  * исходный: выражение, которое возвращает строку

Запрос.

ВОЗВРАТИТЕ rtrim ("привет")

Таблица 12.51. Результат

+---------------+
|rtrim ("привет") |
|---------------|
|1 строка |
|---------------|
| "привет" |
+---------------+


12.5.8. ОБРЕЗАТЬ

ОБРЕЖЬТЕ возвраты исходная строка с пробелом, удаленным от обеих сторон.

Синтаксис: ОБРЕЖЬТЕ (исходный)

Параметры:

  * исходный: выражение, которое возвращает строку

Запрос.

ВОЗВРАТ обрезает (" привет")

Таблица 12.52. Результат

+---------------+
|trim (" привет") |
|---------------|
|1 строка |
|---------------|
| "привет" |
+---------------+


12.5.9. НИЖЕ

ПОНИЗЬТЕ возвраты исходная строка в нижнем регистре.

Синтаксис: НИЖЕ (исходный)

Параметры:

  * исходный: выражение, которое возвращает строку

Запрос.

ВОЗВРАТИТЕСЬ ниже ("ПРИВЕТ")

Таблица 12.53. Результат

+--------------+
|lower ("ПРИВЕТ") |
|--------------|
|1 строка |
|--------------|
| "привет" |
+--------------+


12.5.10. ВЕРХНИЙ

ВЕРХНИЕ возвраты исходная строка в верхнем регистре.

Синтаксис: ВЕРХНИЙ (оригинал)

Параметры:

  * исходный: выражение, которое возвращает строку

Запрос.

ВОЗВРАТИТЕСЬ верхний ("привет")

Таблица 12.54. Результат

+--------------+
|upper ("привет") |
|--------------|
|1 строка |
|--------------|
| "ПРИВЕТ" |
+--------------+


Глава 13. Схема

Neo4j 2.0 представлял дополнительную схему для графика, базируемого вокруг понятия
из меток. Метки используются в спецификации, индексирует, и для того, чтобы определить
ограничения на график. Вместе, индексирует, и ограничения - схема
график. Код включает язык определения данных (DDL) операторы для
управление схемы.

13.1. Индексирует

13.1.1. Создайте индексируют на метке
13.1.2. Отбрасывание индексирует на метке
13.1.3. Использование индексирует

Код позволяет создание, индексирует по свойству для всех вершин, у которых есть a
данная метка. Они индексируют, автоматически управляются и усовершенствованы
база данных всякий раз, когда график изменен.

13.1.1. Создайте индексируют на метке

Чтобы создать индексирование на свойстве для всех вершин, у которых есть метка, использование СОЗДАЕТ
ИНДЕКСИРУЙТЕ НА. Заметьте, что индексирование не сразу доступно, но будет создаваться
на заднем плане. См. Раздел 3.7.1, "Индексирует" для деталей.

Запрос.

СОЗДАЙТЕ ИНДЕКСИРУЮТ НА:Person (имя)

Таблица 13.1. Результат

+----------------+
|Indexes добавлялся: 1 |
|----------------|
| (освободите результат), |
+----------------+


13.1.2. Отбрасывание индексирует на метке

Отбрасывать индексирование на всех вершинах, у которых есть метка, использование, ОТБРАСЫВАНИЕ ИНДЕКСИРУЕТ пункт.

Запрос.

ОТБРАСЫВАНИЕ ИНДЕКСИРУЕТ НА:Person (имя)

Таблица 13.2. Результат

+------------------+
|Indexes переместил: 1 |
|------------------|
| (освободите результат), |
+------------------+


13.1.3. Использование индексирует

обычно нет никакой потребности определить, который индексирует, чтобы использовать в запросе, Коде
поймет это отдельно. Например запрос ниже будет использовать Человека
(имя) индексирует, если оно существует. Если Вы по некоторым причинам хотите подсказать определенному
индексирует, см. Раздел 9.7, "Используя".

Запрос.

СООТВЕТСТВИЕ (n:Person {имя: 'Андрес'})
ВОЗВРАТИТЕ n

Таблица 13.3. Результат

+--------------+
|n |
|--------------|
|0 строк |
|--------------|
| (освободите результат), |
+--------------+


13.2. Ограничения

13.2.1. Создайте ограничение уникальности
13.2.2. Ограничение уникальности отбрасывания
13.2.3. Создайте вершину, которая выполняет ограничения
13.2.4. Создайте вершину, которая нарушает ограничение

Neo4j помогает осуществить целостность данных с использованием ограничений.

Вы можете использовать уникальные ограничения, чтобы гарантировать, что значения свойств уникальны для
все вершины с определенной меткой. Уникальные ограничения не означают что все вершины
должны иметь единственное значение для свойств  - , вершины без свойства
не подвергают этому правилу.

Помните, что добавление ограничений является атомарной работой, которая может взять a
в то время как  -  все существующие данные должен быть отсканирован прежде, чем Neo4j может повернуться
ограничение "на".

У Вас могут быть разнообразные уникальные ограничения для данной метки.

Заметьте, что добавление ограничения уникальности на свойство также прибавит индексирование
на том свойстве, таким образом, Вы не можете прибавить такой индексировать отдельно. Код будет использовать
это индексирует для поисков точно так же, как другой индексирует. Если Вы отбрасываете ограничение и
все еще хочу индексирование на свойстве, Вы должны будете создать индексирование.

13.2.1. Создайте ограничение уникальности

Создать ограничение, которое удостоверяется, что Ваша база данных никогда не будет делиться без остатка
больше чем одна вершина с определенной меткой и одним значением свойства, используйте IS
УНИКАЛЬНЫЙ синтаксис.

Запрос.

СОЗДАЙТЕ ОГРАНИЧЕНИЕ НА (book:Book), УТВЕРЖДАЮТ book.isbn УНИКАЛЬНЫЙ IS

Таблица 13.4. Результат

+--------------------+
|Constraints добавлялся: 1 |
|--------------------|
| (освободите результат), |
+--------------------+


13.2.2. Ограничение уникальности отбрасывания

При использовании ОГРАНИЧЕНИЯ ОТБРАСЫВАНИЯ Вы перемещаете ограничение от базы данных.

Запрос.

ОГРАНИЧЕНИЕ ОТБРАСЫВАНИЯ НА (book:Book) УТВЕРЖДАЕТ book.isbn УНИКАЛЬНЫЙ IS

Таблица 13.5. Результат

+----------------------+
|Constraints переместил: 1 |
|----------------------|
| (освободите результат), |
+----------------------+


13.2.3. Создайте вершину, которая выполняет ограничения

Создайте Книжную вершину с isbn, который уже не находится в базе данных.

Запрос.

СОЗДАЙТЕ (book:Book {isbn: '1449356265', заголовок: 'Базы данных графика'})

Таблица 13.6. Результат

+-----------------+
|Nodes создал: 1 |
|-----------------|
|Properties устанавливают: 2 |
|-----------------|
|Labels добавлялся: 1 |
|-----------------|
| (освободите результат), |
+-----------------+


13.2.4. Создайте вершину, которая нарушает ограничение

Создайте Книжную вершину с isbn, который уже используется в базе данных.

Запрос.

СОЗДАЙТЕ (book:Book {isbn: '1449356265', заголовок: 'Базы данных графика'})

Сообщение об ошибке.

Вершина 0 уже существует с Книгой метки и свойством "isbn" = [1449356265]

Глава 14. От SQL до Кода

Это руководство для людей, которые понимают SQL. Вы можете использовать те предварительные знания
быстро начаться с Кодом и начать зондировать Neo4j.

14.1. Запустить

SQL запускается с результата, Вы хотите  - , мы ВЫБИРАЕМ то, что мы хотим и затем объявляем
как определить источник этого. В Коде пункт ЗАПУСКА - совершенно другое понятие
который определяет начальные точки в графике, от которого выполнится запрос.

С точки зрения SQL идентификаторы в ЗАПУСКЕ походят на имена таблиц это
укажите на ряд вершин или отношений. Набор может быть перечислен буквально, приехать
через параметры, или поскольку я показываю в следующем примере, определяюсь индексированием
поиск.

Так фактически вместо того, чтобы быть ПОДОБНЫМ ВЫБОРУ, пункт ЗАПУСКА где-нибудь между
ОТ и, ГДЕ пункт в SQL.

Запрос SQL.

ВЫБЕРИТЕ *
ОТ "Человека"
ГДЕ имя = 'Anakin'

+--------------------+
|NAME |ID|AGE|HAIR |
|--------------------|
|1 строка |
|--------------------|
|Anakin|1 |20 |blonde |
+--------------------+

Запрос кода.

ЗАПУСТИТЕ person=node:Person (имя = 'Anakin')
ВОЗВРАТИТЕ человека

+------------------------------------------------+
|person |
|------------------------------------------------|
|1 строка |
|------------------------------------------------|
|Node [0] {имя: "Anakin", id:1, age:20, волосы: "блондинка"} |
+------------------------------------------------+

Код позволяет разнообразные начальные точки. Это не должно быть странным от SQL
перспектива  -  каждая таблица в ИЗ пункта является другой начальной точкой.

14.2. Соответствие

В отличие от SQL, который работает на наборах, Код преобладающе работает над подграфами.
Реляционный эквивалент - текущий набор кортежей, оцениваемых во время a
ВЫБЕРИТЕ запрос.

Форма подграфа определена в пункте СООТВЕТСТВИЯ. Пункт СООТВЕТСТВИЯ
походит на JOIN в SQL. Нормаль a→b отношение является внутренним соединением
между вершинами a и b  -  обе стороны должны иметь по крайней мере одно соответствие, или ничто
возвращен.

Мы запустим с простого примера, где мы обнаруживаем все адреса электронной почты, которые являются
соединенный с человеком “Anakin”. Это - обыкновенное отношение "одно многим".

Запрос SQL.

ВЫБЕРИТЕ "Электронную почту".*
ОТ "Человека"
СОЕДИНИТЕ "к Электронной почте" НА "Человеке".id = "Электронная почта".person_id
ГДЕ "Человек".name = 'Anakin'

+------------------------------------+
|ADDRESS |COMMENT|PERSON_ID |
|------------------------------------|
|2 строки |
|------------------------------------|
|anakin@example.com|home |1 |
|------------------+-------+---------|
|anakin@example.org|work |1 |
+------------------------------------+

Запрос кода.

ЗАПУСТИТЕ person=node:Person (имя = 'Anakin')
Человек СООТВЕТСТВИЯ - [:email]-> электронная почта
ВОЗВРАТИТЕ электронную почту

+----------------------------------------------------+
|email |
|----------------------------------------------------|
|2 строки |
|----------------------------------------------------|
|Node [6] {адрес: "anakin@example.com", комментарий: "домой"} |
|----------------------------------------------------|
|Node [7] {адрес: "anakin@example.org", комментарий: "работа"} |
+----------------------------------------------------+

Нет никакой таблицы соединения здесь, но если Вы будете необходимы, то следующий пример покажет
как сделать это, пишущий отношение модели как так: - [r:belongs_to]->
представит (эквивалент) таблицу соединения, доступную как переменная r. В
действительность это - именованное отношение в Коде, таким образом, мы говорим “Человека соединения
Группа через belongs_to.” Чтобы пояснять это, рассмотрите это изображение, сравниваясь
Модель SQL и Neo4j/Cypher.

RDBMSvsGraph.svg

И вот запросы в качестве примера:

Запрос SQL.

ВЫБЕРИТЕ "Группу". *, "Person_Group".*
ОТ "Человека"
СОЕДИНИТЕ "к Person_Group" НА "Человеке".id = "Person_Group".person_id
СОЕДИНИТЕ "к Группе" НА "Person_Group".Group_id = "Группа".id
ГДЕ "Человек".name = 'Бриджит'

+-----------------------------------------------+
|NAME |ID|BELONGS_TO_GROUP_ID|PERSON_ID|GROUP_ID|
|-----------------------------------------------|
|1 строка |
|-----------------------------------------------|
|Admin|4 |3 |2 |4 |
+-----------------------------------------------+

Запрос кода.

ЗАПУСТИТЕ person=node:Person (имя = 'Бриджит')
Человек СООТВЕТСТВИЯ - [r:belongs_to]-> группа
ВОЗВРАТИТЕ группу, r

+-------------------------------------------+
|group |r |
|-------------------------------------------|
|1 строка |
|-------------------------------------------|
|Node [5] {имя: "Администратор", id:4} |:belongs_to [0] {} |
+-------------------------------------------+

Внешнее соединение <http://www.codinghorror.com/blog/2007/10/
a-visual-explanation-of-sql-joins.html> столь легок. Добавьтесь ДОПОЛНИТЕЛЬНЫЙ прежде
соответствие и это - дополнительное отношение между вершинами  -  внешнее соединение
Код.

Является ли это левой стороной внешнее соединение, или правильное внешнее соединение определено который сторона
из модели имеет начальную точку. Этот пример - левая сторона внешнее соединение, потому что
связанная вершина находится на левой стороне:

Запрос SQL.

ВЫБЕРИТЕ "Человека".name, "Электронная почта".address
ОТ ОСТАВЛЕННОГО "Человека"
СОЕДИНИТЕ "к Электронной почте" НА "Человеке".id = "Электронная почта".person_id

+---------------------------+
|NAME |ADDRESS |
|---------------------------|
|3 строки |
|---------------------------|
|Anakin |anakin@example.com |
|-------+-------------------|
|Anakin |anakin@example.org |
|-------+-------------------|
|Bridget | <нуль> |
+---------------------------+

Запрос кода.

ЗАПУСТИТЕ person=node:Person ('имя: *')
ДОПОЛНИТЕЛЬНЫЙ человек СООТВЕТСТВИЯ - [:email]-> электронная почта
ВОЗВРАТИТЕ person.name, email.address

+--------------------------------+
|person.name|email.address |
|--------------------------------|
|3 строки |
|--------------------------------|
| "Anakin" | "anakin@example.com" |
|-----------+--------------------|
| "Anakin" | "anakin@example.org" |
|-----------+--------------------|
| "Бриджит" | <нуль> |
+--------------------------------+

Отношения в Neo4j - граждане первого класса  - , он походит на таблицы SQL,
предварительно соединенный друг с другом. Так, естественно, Код разработан, чтобы быть в состоянии к
обработайте чрезвычайно соединенные данные легко.

Один такой домен - древовидные структуры  -  любой, который попытался хранить дерево
строения в SQL знают, что Вы должны упорно трудиться, чтобы двигаться
ограничения реляционной модели. Есть четные книги по предмету.

Чтобы обнаружить все группы и подгруппы, которым принадлежит Бриджит, этот запрос
достаточно в Коде:

Запрос кода.

ЗАПУСТИТЕ person=node:Person ('имя: Бриджит')
Человек СООТВЕТСТВИЯ - [:belongs_to *]-> группа
ВОЗВРАТИТЕ person.name, group.name

+--------------------------+
|person.name|group.name |
|--------------------------|
|3 строки |
|--------------------------|
| "Бриджит" | "Администратор" |
|-----------+--------------|
| "Бриджит" | "Technichian" |
|-----------+--------------|
| "Бриджит" | "Пользователь" |
+--------------------------+

* после того, как тип отношения означает, что могут быть разнообразные транзитные участки через
отношения belongs_to между группой и пользователем. Некоторые диалекты SQL имеют
рекурсивные возможности, которые позволяют выражение запросов как это, но Вы
может прийтись, нелегко обертывая Вашу голову вокруг тех. Выражение чего-то как
это в SQL чрезвычайно непрактично если не фактически невозможный.

14.3. Где

Это - самая легкая вещь понять  - , это - то же самое животное в обоих
языки. Это отфильтровывает наборы/подграфы результата. Не все предикаты имеют
эквивалентный на другом языке, но понятии то же самое.

Запрос SQL.

ВЫБЕРИТЕ *
ОТ "Человека"
ГДЕ "Человек".age> 35 И "Человек".hair = 'блондинка'

+----------------------+
|NAME |ID|AGE|HAIR |
|----------------------|
|1 строка |
|----------------------|
|Bridget |2 |40 |blonde |
+----------------------+

Запрос кода.

ЗАПУСТИТЕ person=node:Person ('имя: *')
ГДЕ person.age> 35 И person.hair = 'блондинка'
ВОЗВРАТИТЕ человека

+-------------------------------------------------+
|person |
|-------------------------------------------------|
|1 строка |
|-------------------------------------------------|
|Node [1] {имя: "Бриджит", id:2, age:40, волосы: "блондинка"} |
+-------------------------------------------------+

14.4. Возвратиться

Это - ИЗБРАННЫЙ SQL. Мы только помещаем это в конец, потому что чувствовало себя лучше иметь
это там  -  Вы делает большое соответствие и фильтрацию, и наконец, Вы возвращаетесь
что-то.

Агрегат запрашивает работу точно так же, как они делают в SQL, кроме факта это там
не явная ГРУППА пунктом. Все в пункте возврата, который не является
совокупная функция будет использоваться в качестве группирующихся столбцов.

Запрос SQL.

ВЫБЕРИТЕ "Человека".name, количество (*)
ОТ "Человека"
ГРУППА "Человеком".name
ПОРЯДОК "Человеком".name

+-----------+
|NAME |C2 |
|-----------|
|2 строки |
|-----------|
|Anakin |1 |
|--------+--|
|Bridget |1 |
+-----------+

Запрос кода.

ЗАПУСТИТЕ person=node:Person ('имя: *')
ВОЗВРАТИТЕ person.name, количество (*)
ПОРЯДОК person.name

+---------------------+
|person.name |count (*) |
|---------------------|
|2 строки |
|---------------------|
| "Anakin" |1 |
|------------+--------|
| "Бриджит" |1 |
+---------------------+

Порядок является тем же самым на обоих языках  -  ПОРЯДОК ПО выражению ASC/DESC. Ничто
странный здесь.

IV части. Ссылка

Ссылочная часть - авторитетный источник для деталей относительно использования Neo4j. Это
покрытия детализируют на возможностях, транзакциях, индексируя и запросах среди другого
темы.

Оглавление

15. Возможности

    15.1. Защита информации
    15.2. Целостность данных
    15.3. Интегрирование данных
    15.4. Доступность и Надежность
    15.5. Емкость

16. Управление транзакцией

    16.1. Цикл взаимодействия
    16.2. Уровни изоляции
    16.3. Поведение блокировки значения по умолчанию
    16.4. Тупики
    16.5. Сотрите семантику
    16.6. Создание уникальных вершин
    16.7. События транзакции

17. Импорт данных
18. Алгоритмы графика

    18.1. Введение

19. API REST

    19.1. Транзакционная конечная точка HTTP
    19.2. Коды состояний Neo4j
    19.3. Корень службы
    19.4. Потоковая передача
    19.5. Код запрашивает через REST
    19.6. Значения свойств
    19.7. Вершины
    19.8. Отношения
    19.9. Типы отношения
    19.10. Свойства вершины
    19.11. Свойства отношения
    19.12. Метки вершины
    19.13. Индексация
    19.14. Ограничения
    19.15. Обходы
    19.16. Алгоритмы графика
    19.17. Групповые процессы
    19.18. Индексация наследства
    19.19. Уникальная Индексация
    19.20. Автоматическое наследство Индексирует
    19.21. Конфигурируемое Наследство Автоматическая Индексация
    19.22. Поддержка WADL

20. Осуждения

Глава 15. Возможности

15.1. Защита информации

Некоторые данные, возможно, должны быть предохранены от несанкционированного доступа (например, воровство,
изменение). Neo4j не имеет дело с шифрованием данных явно, но
поддерживает все средства, встроенные в язык программирования Java и JVM к
предохраните данные, шифруя это перед хранением.

Кроме того, данные могут быть легко защищены, работая на зашифрованном datastore в
уровень файловой системы. Наконец, защиту данных нужно рассмотреть в
верхние уровни окружающей системы, чтобы предотвратить проблемы с
очистка, злонамеренная вставка данных, и другие угрозы.

15.2. Целостность данных

15.2.1. Базовый Механизм Графика
15.2.2. Различные Хранилища данных

Чтобы сохранить данные непротиворечивыми, должны быть механизмы и строения
та гарантия целостность всех запоминаемых данных. В Neo4j целостность данных
сохраняемый для базового механизма графика вместе с другими хранилищами данных - см.
ниже.

15.2.1. Базовый Механизм Графика

В Neo4j целая модель данных сохранена как график на диске и сохранена как
часть каждой фиксировавшей транзакции. В уровне хранения, Отношениях,
У вершин, и Свойств есть прямые указатели друг на друга. Это поддерживает
целостность без потребности в дублировании данных между различным бэкэндом
храните файлы.

15.2.2. Различные Хранилища данных

Во многих сценариях базовый механизм графика объединен с другими системами
чтобы достигнуть оптимальной производительности для поисков неграфика. Например,
Apache Lucene часто используется в качестве дополнительного, индексирует систему для текстовых запросов
это иначе было бы очень интенсивно обработкой в уровне графика.

Сохранить эти внешние системы в синхронизации друг с другом, Neo4j
обеспечивает полные Два Фазовых управления транзакцией Фиксации, с поддержкой отката
по всем хранилищам данных. Таким образом, отказавший индексируют вставки в Lucene, может быть
прозрачно откатываемый во всех хранилищах данных и таким образом сохраняют данные актуальными.

15.3. Интегрирование данных

15.3.1. Основанная на событии Синхронизация
15.3.2. Периодическая Синхронизация
15.3.3. Периодический Полный Экспорт/Импорт Данных

Большинство предприятий полагается прежде всего на реляционные базы данных, чтобы хранить их данные,
но это может вызвать ограничения производительности. В некоторых из этих случаев может Neo4j
используйтесь в качестве расширения, чтобы дополнить поиск/поиск более быстрого принятия решений.
Однако, в любой ситуации, где разнообразные репозитарии данных содержат то же самое
данные, синхронизация может быть проблемой.

В некоторых приложениях приемлемо для платформы поиска быть немного
из синхронизации с реляционной базой данных. В других, плотная целостность данных (eg.,
между Neo4j и RDBMS), необходимо. Как правило, это должно адресоваться для
данные, изменяющиеся в в реальном времени и для объемных изменений данных, происходящих в RDBMS.

Несколько стратегий синхронизации интегрированных данных следуют.

15.3.1. Основанная на событии Синхронизация

В этом сценарии все хранилища данных, и RDBMS и Neo4j, питаются
проблемно-ориентированные события через шину события. Таким образом, данные сохранены в различном
бэкэнды фактически не синхронизируются, а скорее тиражированы.

15.3.2. Периодическая Синхронизация

Другой жизнеспособный сценарий - периодический экспорт самых последних изменений в
RDBMS к Neo4j через некоторую форму запроса SQL. Это позволяет небольшое количество
задержка в синхронизации, но имеет преимущество использования RDBMS как
ведущее устройство для всех целей данных. Тот же самый процесс может быть применен с Neo4j как
основное хранилище данных.

15.3.3. Периодический Полный Экспорт/Импорт Данных

Используя Пакетные инструменты Вставки для Neo4j, даже большие объемы данных могут быть
импортированный в базу данных в очень короткое время. Таким образом, полный экспорт от
RDBMS и импорт в Neo4j становятся возможными. Если инерционность распространения между
RDBMS и Neo4j не большая проблема, это - очень жизнеспособное решение.

15.4. Доступность и Надежность

15.4.1. Операционная Доступность
15.4.2. Аварийное восстановление / Упругость

Большинство систем для решения ответственных задач требует, чтобы подсистема базы данных была доступна
всегда. Neo4j гарантирует доступность и надежность через некоторых
различные стратегии.

15.4.1. Операционная Доступность

Чтобы не создать единственную точку отказа, Neo4j поддерживает отличающийся
подходы, которые обеспечивают прозрачную нейтрализацию и/или восстановление после отказов.

15.4.1.1. Онлайновое резервное копирование (Холодная запчасть)

В этом подходе единственный экземпляр основной базы данных используется, с Онлайн
Резервное копирование включено. В случае отказа резервные файлы могут быть смонтированы на a
новый экземпляр Neo4j и воссоединенный в приложение.

15.4.1.2. Онлайновая Резервная Высокая доступность (Горячая запчасть)

Здесь, "резервный" экземпляр Neo4j слушает онлайновые передачи изменений от
ведущее устройство. В случае отказа ведущего устройства уже работает резервное копирование
и может прямо принять загрузку.

15.4.1.3. Кластер высокой доступности

Этот подход использует кластер экземпляров базы данных, с одним (чтение-запись)
ведущее устройство и много ведомых устройств (только для чтения). Сбой ведомых устройств может просто быть
запущенный снова и возвращенный онлайн. Альтернативно, новое ведомое устройство может быть прибавлено
вегетативное размножение существующего. Если основной сбой экземпляра, новое ведущее устройство будет
избранный остающимися вершинами кластера.

15.4.2. Аварийное восстановление / Упругость

В случаях отказа большой части инфраструктуры ИТ, там нуждайтесь к
будьте механизмами на месте, которые включают быстрому восстановлению и перегруппировке
остающиеся службы и серверы. В Neo4j есть различные компоненты это
являются соответствующими, чтобы быть частью стратегии аварийного восстановления.

15.4.2.1. Предотвращение

  * Онлайновая Резервная Высокая доступность к другим расположениям вне текущих данных
    центр.
  * Онлайновое Резервное копирование к различным расположениям файловой системы: это - более простая форма
    резервное копирование, применяя изменения прямо к резервным файлам; это таким образом больше подходит
    для локальных резервных сценариев.
  * Кластер высокой доступности Neo4j: кластер одного сервера ведущего устройства записи Нео4дж
    и много ведомых устройств чтения, получая журналы транзакций от ведущего устройства.
    Основной записью failover обработан выборами кворума среди ведомых устройств чтения
    для нового ведущего устройства.

15.4.2.2. Обнаружение

  * SNMP и контроль JMX могут использоваться для базы данных Neo4j.

15.4.2.3. Исправление

  * Онлайновое Резервное копирование: новый сервер Neo4j может быть запущен прямо на поддержанном
    файлы и принимают новые запросы.
  * Кластер высокой доступности Neo4j: нарушенный Neo4j читал, ведомое устройство может быть
    вновь установленный в кластер, получая самые последние обновления от ведущего устройства.
    Альтернативно, новый сервер может быть вставлен, копируя существующий сервер
    и применяя самые последние обновления к этому.

15.5. Емкость

15.5.1. Размеры файла
15.5.2. Считайте скорость
15.5.3. Запишите скорость
15.5.4. Размер данных

15.5.1. Размеры файла

Neo4j полагается на подсистему ввода-вывода Неблокирования Java для всей обработки файла.
Кроме того, в то время как расположение файла хранения оптимизировано для соединенного
данные, Neo4j не требует необработанных устройств. Таким образом, размеры файла только ограничены
емкость базовой операционной системы обработать большие файлы. Физически,
нет никакого встроенного предела емкости обработки файла в Neo4j.

Neo4j пробует к карте памяти так много базовых файлов хранилища насколько возможно. Если
доступная RAM не достаточна, чтобы сохранить все данные в RAM, Neo4j будет использовать
буферы в некоторых случаях, перераспределяя эффективный ввод-вывод с отображенной памятью
окна к областям с большинством действия ввода-вывода динамически. Таким образом, скорость ACID
ухудшается корректно, поскольку RAM становится ограничивающим фактором.

15.5.2. Считайте скорость

Предприятия хотят оптимизировать использование аппаратных средств, чтобы поставить максимум
бизнес-ценность от доступных ресурсов. Neo4j’s приближаются к чтению данных
обеспечивает самое лучшее использование всех доступных аппаратных ресурсов. Neo4j
не блокирует или блокирует операции чтения; таким образом, нет никакой опасности для
тупики в операциях чтения и никакой потребности в транзакциях чтения. С поточным
считайте доступ к базе данных, запросы могут быть выполнены одновременно на так многих
процессоры, как может быть доступным. Это предоставляет очень хорошим сценариям увеличения масштаба
большие серверы.

15.5.3. Запишите скорость

Запишите, что скорость - рассмотрение для многих приложений для предприятия. Однако, там
два различных сценария:

 1. длительная непрерывная работа и
 2. объемный доступ (например, резервное копирование, начальная буква или загрузка пакета).

Чтобы поддерживать несоизмеримые требования этих сценариев, Neo4j поддерживает два
режимы записи в уровень хранения.

В транзакционном, совместимом ACID нормальном функционировании уровень изоляции
сохраняемый и операции чтения может произойти одновременно как запись
процесс. В каждой фиксации данные сохранены, чтобы обработать почву дисковым культиватором и могут быть восстановлены к
непротиворечивое состояние на системные отказы. Это требует доступа записи диска и a
реальное сбрасывание данных. Таким образом, скорость записи Neo4j на единственном сервере в
непрерывный режим ограничен емкостью ввода-вывода аппаратных средств. Следовательно,
использование быстрых SSD настоятельно рекомендовано для производственных сценариев.

У Neo4j есть Пакетная Вставка, которая работает прямо на файлах хранилища. Этот режим
не обеспечивает транзакционную безопасность, таким образом, она может только использоваться, когда есть a
выберите поток записи. Поскольку данные записаны последовательно, и никогда не сбрасываются к
логические журналы, огромные усиления производительности достигнуты. Пакетная Вставка
оптимизированный для нетранзакционного объемного импорта больших объемов данных.

15.5.4. Размер данных

В Neo4j размер данных, главным образом, ограничен адресным пространством первичных ключей
для Вершин, Отношений, Свойств и RelationshipTypes. В настоящий момент,
адресное пространство следующие:

вершины 2^35 (∼ 34 миллиарда)

отношения 2^35 (∼ 34 миллиарда)

свойства 2^36 к 2^38 в зависимости от типов свойства (максимум ∼ 274 миллиарда,
              всегда, по крайней мере,  68 миллиардов)

отношение 2^15 (∼ 32 000)
типы

Глава 16. Управление транзакцией

Чтобы полностью поддержать целостность данных и гарантировать хороший транзакционный
поведение, Neo4j поддерживает свойства ACID:

  * атомарность: Если какая-либо часть транзакции перестала работать, состояние базы данных оставляют
    неизменный.
  * непротиворечивость: Любая транзакция оставит базу данных в непротиворечивом состоянии.
  * изоляция: Во время транзакции к модифицируемым данным не может получить доступ другой
    операции.
  * длительность: DBMS может всегда восстанавливать результаты фиксировавшего
    транзакция.

Определенно:

  * Все операции базы данных, которые получают доступ к графику, индексируют, или схема должна
    будьте выполнены в транзакции.
  * уровень изоляции значения по умолчанию - READ_COMMITTED.
  * Данные, полученные обходами, не предохранены от изменения другим
    транзакции.
  * Неповторимые чтения могут произойти (то есть, только запишите, что блокировки получены и
    сохраненный до конца транзакции).
  * можно вручную получить запись, соединяет вершины и отношения, чтобы достигнуть
    верхний горизонт (СЕРИАЛИЗУЕМОЙ) изоляции.
  * Блокировки получены на уровне Вершины и Отношения.
  * обнаружение Тупика встроено в базовое управление транзакцией.

16.1. Цикл взаимодействия

Все операции базы данных, которые получают доступ к графику, индексируют, или схема должна быть
выполняемый в транзакции. Транзакции - ограниченный поток и могут быть вложены
как “плоскость вкладывала транзакции”. Плоскость вкладывала средства транзакций, которые все вкладывали
транзакции прибавлены к контексту высокоуровневой транзакции. Вложенный
транзакция может отметить высокоуровневую транзакцию для отката, означая все
транзакция будет откатываться. Только откатывать изменения, произведенные во вложенном
транзакция не возможна.

Цикл взаимодействия работы с транзакциями похож на это:

 1. Начните транзакцию.
 2. Выполните операции базы данных.
 3. Отметьте транзакцию как успешная или нет.
 4. Обработайте начисто транзакцию.

Очень важно обработать начисто каждую транзакцию. Транзакция не будет
выпустите блокировки или память, которую это получило, пока это не было обработано начисто.
идиоматическое использование транзакций в Neo4j должно использовать блок попытки наконец, запускаясь
транзакция и затем пытается выполнить операции записи. Последнее
работа в блоке попытки должна отметить транзакцию как успешную в то время как
наконец блок должен обработать начисто транзакцию. Окончательная отделка транзакции будет
выполните фиксацию или откат в зависимости от состояния успеха.

Предостережение

Все изменения, выполняемые в транзакции, сохранены в памяти. Это означает
тот очень большие обновления должны быть разделены на несколько высокоуровневых транзакций к
избегите исчерпывать память. Это должна быть высокоуровневая транзакция начиная с разделения
работа во многих вложенных транзакциях только прибавит всю работу к вершине
транзакция уровня.

В среде, которая использует поток, объединяющий другие погрешности в пул, может произойти когда
будучи не в состоянии обработать начисто транзакцию должным образом. Считайте пропущенную транзакцию этим
не получал обработанным начисто должным образом. Это будет связано к потоку и когда тот поток
получает запланированным выполнить работу, начинающую новое (что надеется быть a), верхний уровень
транзакция это фактически будет вложенная транзакция. Если пропущенная транзакция
состояние “отмечено для отката” (который произойдет, если тупик был обнаружен),
больше работы не может быть выполнено на той транзакции. Попытка сделать так будет следовать
по ошибке на каждом звонке в работу записи.

16.2. Уровни изоляции

По умолчанию работа чтения не считает последнее фиксировавшее значение если локальная переменная
изменение в пределах текущей транзакции существует. Уровень изоляции значения по умолчанию
очень подобно READ_COMMITTED: чтения не блокируют или берут блокировки так
могут произойти неповторимые чтения. Возможно достигнуть более сильной изоляции
уровень (такой как REPETABLE_READ и СЕРИАЛИЗУЕМЫЙ), вручную получая чтение и
запишите блокировки.

16.3. Поведение блокировки значения по умолчанию

  *, добавляясь, изменяясь или перемещая свойство на вершине или отношении a
    запишите, что блокировка будет взята на определенной вершине или отношении.
  *, создавая или стирая вершину блокировка записи будет взята для
    определенная вершина.
  *, создавая или стирая отношение блокировка записи будет взята
    определенное отношение и обе его вершины.

Блокировки будут прибавлены к транзакции и выпущены когда транзакция
отделки.

16.4. Тупики

Так как блокировки используются, для тупиков возможно произойти. Neo4j будет однако
обнаружьте любой тупик (вызванный, получая блокировку) прежде, чем они произойдут и бросят
исключение. Прежде, чем исключение выдано, транзакция отмечена для
откат. Все блокировки, полученные транзакцией, все еще сохранены, но будет
будьте выпущены, когда транзакция обработана начисто (в наконец блоке как указано
ранее). Как только блокировки выпущены другие транзакции, которые ожидали
для блокировок, сохраненных транзакцией, вызывающей тупик, может продолжиться. Работа
выполняемый транзакцией, вызывающей тупик, может тогда быть повторен
пользователь если нужно.

Испытание частых тупиков является индикацией относительно параллельных запросов записи
случай таким способом, которым не возможно выполнить их в то время как в
то же самое время соответствует намеченной изоляции и непротиворечивости. Решение к
удостоверьтесь, что параллельные обновления происходят разумным способом. Например учитывая два
определенные вершины (A и B), добавляясь или стирая отношения к обеим этим вершинам
в произвольном порядке для каждой транзакции будет следовать тупиками, когда есть
две или больше транзакции, делающие это одновременно. Одно решение состоит в том, чтобы удостовериться
это обновляет, всегда происходит в том же самом порядке (сначала тогда B). Другой
решение состоит в том, чтобы удостовериться, что у каждого потока/транзакции нет никого
конфликтные записи к вершине или отношению как некоторый другой параллельный
транзакция. Это может например быть достигнуто, пуская единственному потоку сделать все
обновления определенного типа.

Важный

Тупики, вызванные при помощи другой синхронизации чем блокировки, которыми управляют
Neo4j может все еще произойти. Так как все операции в API Neo4j - безопасный поток
если не определено иначе, нет никакой потребности во внешней синхронизации.
Другой код, который требует синхронизации, должен синхронизироваться таким способом
то, что это никогда не выполняет работы Neo4j в синхронизируемом блоке.

16.5. Сотрите семантику

Стирая вершину или отношение все свойства для того объекта будут
автоматически удаленный, но отношения вершины не будет удален.

Предостережение

Neo4j осуществляет ограничение (на фиксацию), что у всех отношений должен быть a
допустимая вершина запуска и конечный узел. В действительности это означает что, пытаясь стереть a
вершина, которой все еще присоединили отношения к этому, выдаст исключение на
фиксация. Однако возможно выбрать в который порядок стереть вершину и
присоединенные отношения пока никакие отношения существуют когда
транзакция фиксируется.

Стирать семантика может быть получена в итоге в следующих маркерах:

  Свойства * All вершины или отношения будут удалены, когда это будет
    стертый.
  * У стертой вершины не может быть никаких присоединенных отношений когда транзакция
    фиксации.
  * возможно получить ссылку на стертое отношение или вершину
    это еще не фиксировалось.
  * Любая работа записи на вершине или отношении после того, как это было стерто
    (но еще фиксировавший), выдаст исключение
  * После фиксации, пытающейся получать новое или работу со старой ссылкой на a
    стертая вершина или отношение выдадут исключение.

16.6. Создание уникальных вершин

16.6.1. Единственный поток
16.6.2. Получите или создайте
16.6.3. Пессимистическая блокировка

Во многих вариантах использования определенный уровень уникальности требуется среди объектов. Вы
мог например предположить, что только один пользователь с определенным адресом электронной почты может
существуйте в системе. Если разнообразные параллельные потоки наивно пытаются создать
пользователь, копии будут создаваться. Есть три основных стратегии обеспечения
уникальность, и они все работают через Высокую доступность и единственный экземпляр
развертывание.

16.6.1. Единственный поток

При использовании единственного потока никакие два потока даже не попытаются создать деталь
объект одновременно. На Высокой доступности, внешнем однопоточном клиенте
может выполнить операции на кластере.

16.6.2. Получите или создайте

Привилегированный способ добраться или создать уникальную вершину состоит в том, чтобы использовать уникальные ограничения
и Код. См. Раздел 32.11.1, “Получите или создайте уникальную вершину, используя Код и
уникальные ограничения” для получения дополнительной информации.

При использовании "помещенного, если отсутствующий" <http://components.neo4j.org/neo4j/2.0.0/apidocs/org/
neo4j/graphdb/index/Index.html#
putIfAbsent%28T,%20java.lang.String,%20java.lang.Object%29> функциональность,
уникальность объекта может быть гарантирована, используя наследство, индексируют. Здесь наследство индексирует
действия как блокировка и только заблокируют самую малую часть, необходимую к гарантируемому
уникальность через потоки и транзакции.

См. Раздел 32.11.2, “Получите или создайте уникальную вершину, используя наследство, индексируют” для как
сделать это использование базового API Java. При использовании остальных API, см. Раздел 19.19,
“Уникальная Индексация”.

16.6.3. Пессимистическая блокировка

Важный

В то время как это - рабочее решение, пожалуйста, рассмотрите использование привилегированного
Раздел 16.6.2, “Получают или создают” вместо этого.

При использовании явной, пессимистической блокировки уникальное создание объектов может быть
достигнутый в многопоточной среде. Это обычно сделано, блокируя
на единственном или ряде общих вершин.

См. Раздел 32.11.3, “Пессимистическая блокировка для создания вершины” для того, как сделать это
использование базового API Java.

16.7. События транзакции

Обработчики событий транзакции могут быть зарегистрированы, чтобы получить Транзакцию Neo4j
события. Как только это было зарегистрировано в экземпляре GraphDatabaseService, это будет
получите события о том, что произошло в каждой транзакции, которая собирается быть
фиксировавший. Обработчики не будут получать уведомленными о транзакциях, которые не имеют
выполняемый любая работа записи или не будет фиксироваться (также, если Transaction#
успех () не вызвали, или транзакция была отмечена как отказавший
Transaction#failure (). Прямо прежде, чем транзакция собирается фиксироваться
метод beforeCommit вызывают со всей разностью изменений, сделанных в
транзакция. В этой точке транзакция все еще работает так, изменения могут
все еще будьте сделаны. Однако нет никакой гарантии, что другие обработчики будут видеть такой
изменения начиная с порядка, в котором выполняются обработчики, неопределены. Это
метод может также выдать исключение и, в таком случае, предотвратит
транзакция от того, чтобы быть фиксировавшимся (где звонок afterRollback будет следовать).
Если beforeCommit будет успешно выполняться, то транзакция будет фиксироваться и
afterCommit метод вызовут с теми же самыми данными транзакции так же как
объект возвратился из beforeCommit. Это предполагает что все другие обработчики (если
больше было зарегистрировано), также выполнил beforeCommit успешно.

Глава 17. Импорт данных

Для того, чтобы импортировать данные в Neo4j, см. http://www.neo4j.org/develop/import <http://
www.neo4j.org/develop/import>.

Для эффективного импорта данных, см. Главу 35, Пакетную Вставку.

Глава 18. Алгоритмы графика

Алгоритмы графика Neo4j - компонент, который содержит реализации Neo4j
некоторые общие алгоритмы для графиков. Это включает алгоритмы как:

  * Кратчайшие пути,
  * все пути,
  * все простые пути,
  * Dijkstra и
  * A*.

18.1. Введение

Алгоритмы графика найдены в neo4j-graph-algo компоненте, который является
включенный в стандартную загрузку Neo4j.

  * Javadocs <http://components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/
    graphalgo/package-summary.html>
  * Загрузка <http://search.maven.org/#
    search%7Cgav%7C1%7Cg%3A%22org.neo4j%22%20AND%20a%3A%22neo4j-graph-algo%22>
  * Исходный код <https://github.com/neo4j/neo4j/tree/2.0.0/community/
    график-algo>

Для примеров, см. Раздел 19.16, “Алгоритмы Графика” (API REST) и
Раздел 32.9, “Примеры Алгоритма графика” (встроенная база данных).

Для получения информации о том, как использовать neo4j-graph-algo в качестве зависимости со Знатоком и
другие инструменты управления зависимости, см. org.neo4j:neo4j-graph-algo <http://
search.maven.org/#
search%7Cgav%7C1%7Cg%3A%22org.neo4j%22%20AND%20a%3A%22neo4j-graph-algo%22> Замечание
то, что это должно использоваться с той же самой версией org.neo4j:neo4j-ядра <http://
search.maven.org/#
search%7Cgav%7C1%7Cg%3A%22org.neo4j%22%20AND%20a%3A%22neo4j-kernel%22>.
Различные версии графика-algo и компонентов ядра не являются совместимыми
в общем случае. Оба компонента включены transitively
org.neo4j:neo4j <http://search.maven.org/#
search%7Cgav%7C1%7Cg%3A%22org.neo4j%22%20AND%20a%3A%22neo4j%22> артефакт, который
делает простым сохранить версии в синхронизации.

Начальной точкой, чтобы обнаружить и использовать алгоритмы графика является GraphAlgoFactory <http:/
/components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/graphalgo/
GraphAlgoFactory.html> при использовании API ядра Java.

Глава 19. API REST

API REST Neo4j разработан с discoverability в памяти, так, чтобы Вы могли
запустите с GET на Разделе 19.3, “Корень службы” и оттуда обнаруживает
URI, чтобы выполнить другие запросы. Примеры ниже используют URI в примерах;
они подвержены изменениям в будущем, таким образом, для будущей защищенности обнаруживают URI
где только возможно, вместо того, чтобы положиться на текущее расположение. Значение по умолчанию
представление - json <http://www.json.org/>, и для реакций и для данных
отправленный с запросами POST/ПОМЕЩАТЬ.

Ниже следует за перечислением способов взаимодействовать с остальными API. Для языка
привязка остальным API, см. Главу 6, Языки.

Чтобы взаимодействовать с интерфейсом ДЖСОНА, Вы должны явно установить головную часть запроса
Аксепт:эппликэйшн/джсон для тех запросов, который отвечает данными. Вы должны
также установите головную часть Content-Type:application/json, если Ваш запрос отправляет данные,
например, когда Вы создаете отношение. Примеры включают
соответствующий запрос и головные части реакции.

Сервер поддерживает результаты потоковой передачи, с лучшей производительностью и более низкой памятью
издержки. См. Раздел 19.4, "Передавая потоком" для получения дополнительной информации.

19.1. Транзакционная конечная точка HTTP

19.1.1. Начните транзакцию
19.1.2. Выполните операторы в открытой транзакции
19.1.3. Выполните операторы в открытой транзакции в формате REST для возврата
19.1.4. Тайм-аут транзакции сброса открытой транзакции
19.1.5. Фиксируйте открытую транзакцию
19.1.6. Откатывайте открытую транзакцию
19.1.7. Начните и фиксируйте транзакцию в одном запросе
19.1.8. Возвратите результаты в формате графика
19.1.9. Ошибки из-за неправильного обращения

Транзакционная конечная точка HTTP Neo4j позволяет Вам выполнять серию Кода
операторы в рамках транзакции. Транзакция может быть сохранена открытой
через разнообразные запросы HTTP, пока клиент не хочет фиксировать или откатывать.
Каждый запрос HTTP может включать список операторов, и для удобства Вы можете
включайте операторы наряду с запросом, чтобы начать или фиксировать транзакцию.

Сервер принимает меры против осиротевших транзакций при использовании тайм-аута. Если там
не запросы на данную транзакцию в пределах периода тайм-аута, сервера
будет откатывать это. Вы можете сконфигурировать тайм-аут в конфигурации сервера,
установкой org.neo4j.server.transaction.timeout к номеру секунд прежде
тайм-аут. Тайм-аут значения по умолчанию составляет 60 секунд.

Основное отличие между транзакционной конечной точкой HTTP и Кодом
конечная точка (см. Раздел 19.5, “Запросы кода через REST”) является возможностью использовать
та же самая транзакция через разнообразные запросы HTTP. Конечная точка кода всегда
попытки фиксировать транзакцию в конце каждого запроса HTTP.

Замечание

Формат сериализации для результатов кода - главным образом то же самое как код
конечная точка. Однако, формат для необработанных объектов немного менее многословен и
не включает ссылки гиперсреды.

Замечание

Открытые транзакции не совместно использованы среди элементов кластера HA. Поэтому, если
Вы используете эту конечную точку в кластере HA, Вы должны гарантировать что все запросы на a
данная транзакция отправлена тому же самому экземпляру Neo4j.

Подсказка

Чтобы ускорить запросы в повторенных сценариях, попытайтесь не использовать литералы, но
замените их параметрами везде, где возможный, чтобы пустить кэшу сервера
схемы запроса.

19.1.1. Начните транзакцию

Вы начинаете новую транзакцию, отправляя нуль или больше операторов Cypher к
конечная точка транзакции. Сервер ответит результатом Вашего
операторы, так же как расположение Вашей открытой транзакции.

Запрос в качестве примера

  * POST http://localhost:7474/db/data/transaction
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "операторы": [{
    "оператор": "СОЗДАЙТЕ (n {опоры}) ВОЗВРАЩАЮТ n",
    "параметры": {
      "опоры": {
        "имя": "Моя Вершина"
      }
    }
  } ]
}

Реакция в качестве примера

  * 201: Создаваемый
  * Тип контента: application/json
  * Расположение: http://localhost:7474/db/data/transaction/7

{
  "фиксация": "http://localhost:7474/db/data/transaction/7/commit",
  "результаты": [{
    "столбцы": ["n"],
    "данные": [{
      "строка": [{
        "имя": "Моя Вершина"
      } ]
    } ]
  } ],
  "транзакция": {
    "истекает": "Sun, 08 декабря 2013 15:05:52 +0000"
  },
  "погрешности": []
}

19.1.2. Выполните операторы в открытой транзакции

Учитывая, что у Вас есть открытая транзакция, Вы можете обратиться со многими просьбами,
каждый из которых выполняет дополнительные операторы, и сохраняет транзакцию открытой
сброс тайм-аута транзакции.

Запрос в качестве примера

  * POST http://localhost:7474/db/data/transaction/9
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "операторы": [{
    "оператор": "СОЗДАЙТЕ ВОЗВРАТ n n"
  } ]
}

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json

{
  "фиксация": "http://localhost:7474/db/data/transaction/9/commit",
  "результаты": [{
    "столбцы": ["n"],
    "данные": [{
      "строка": [{
      } ]
    } ]
  } ],
  "транзакция": {
    "истекает": "Sun, 08 декабря 2013 15:05:52 +0000"
  },
  "погрешности": []
}

19.1.3. Выполните операторы в открытой транзакции в формате REST для возврата

Учитывая, что у Вас есть открытая транзакция, Вы можете обратиться со многими просьбами,
каждый из которых выполняет дополнительные операторы, и сохраняет транзакцию открытой
сброс тайм-аута транзакции. Определение остальных форматирует, отдаст
валяйте представления API Подпорки Neo4j Вершин Neo4j, Отношений и
Пути, если возвращено.

Запрос в качестве примера

  * POST http://localhost:7474/db/data/transaction/1
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "операторы": [{
    "оператор": "СОЗДАЙТЕ ВОЗВРАТ n n",
    "resultDataContents": ["REST"]
  } ]
}

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json

{
  "фиксация": "http://localhost:7474/db/data/transaction/1/commit",
  "результаты": [{
    "столбцы": ["n"],
    "данные": [{
      "подпорка": [{
        "paged_traverse": "http://localhost:7474/db/data/node/12/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
        "метки": "http://localhost:7474/db/data/node/12/labels",
        "outgoing_relationships": "http://localhost:7474/db/data/node/12/relationships/out",
        "траверз": "http://localhost:7474/db/data/node/12/traverse/ {returnType}",
        "all_typed_relationships": "http://localhost:7474/db/data/node/12/relationships/all/ {-list|&|types}",
        "свойство": "http://localhost:7474/db/data/node/12/properties/ {ключ}",
        "all_relationships": "http://localhost:7474/db/data/node/12/relationships/all",
        "сам": "http://localhost:7474/db/data/node/12",
        "свойства": "http://localhost:7474/db/data/node/12/properties",
        "outgoing_typed_relationships": "http://localhost:7474/db/data/node/12/relationships/out/ {-list|&|types}",
        "incoming_relationships": "http://localhost:7474/db/data/node/12/relationships/in",
        "incoming_typed_relationships": "http://localhost:7474/db/data/node/12/relationships/in/ {-list|&|types}",
        "create_relationship": "http://localhost:7474/db/data/node/12/relationships",
        "данные": {
        }
      } ]
    } ]
  } ],
  "транзакция": {
    "истекает": "Sun, 08 декабря 2013 15:05:48 +0000"
  },
  "погрешности": []
}

19.1.4. Тайм-аут транзакции сброса открытой транзакции

Каждая осиротевшая транзакция автоматически истекается после периода
неактивность. Это может быть предотвращено, сбрасывая тайм-аут транзакции.

Тайм-аут может быть сброшен, отправляя под током сохраненный запрос серверу это
выполняет пустой список операторов. Этот запрос сбросит транзакцию
тайм-аут и возврат новое время, в которое транзакция истечет как
RFC1123 форматированное значение метки времени в разделе "транзакции" реакции.

Запрос в качестве примера

  * POST http://localhost:7474/db/data/transaction/2
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "операторы": []
}

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json

{
  "фиксация": "http://localhost:7474/db/data/transaction/2/commit",
  "результаты": [],
  "транзакция": {
    "истекает": "Sun, 08 декабря 2013 15:05:51 +0000"
  },
  "погрешности": []
}

19.1.5. Фиксируйте открытую транзакцию

Учитывая Вас имеют открытую транзакцию, Вы можете отправить запрос фиксации. Дополнительно,
Вы представляете дополнительные операторы наряду с запросом, который будет выполняться
прежде, чем фиксировать транзакцию.

Запрос в качестве примера

  * POST http://localhost:7474/db/data/transaction/4/commit
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "операторы": [{
    "оператор": "СОЗДАЙТЕ идентификатор ВОЗВРАТА n (n)"
  } ]
}

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json

{
  "результаты": [{
    "столбцы": ["идентификатор (n)"],
    "данные": [{
      "строка": [14]
    } ]
  } ],
  "погрешности": []
}

19.1.6. Откатывайте открытую транзакцию

Учитывая, что у Вас есть открытая транзакция, Вы можете передаться, рулон назад запрашивают.
сервер будет откатывать транзакцию.

Запрос в качестве примера

  * СТИРАЮТ http://localhost:7474/db/data/transaction/3
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

{
  "результаты": [],
  "погрешности": []
}

19.1.7. Начните и фиксируйте транзакцию в одном запросе

Если нет никакой потребности сохранить транзакцию открытой через разнообразные запросы HTTP,
Вы можете начать транзакцию, выполнить операторы, и фиксировать с только единственным
Запрос HTTP.

Запрос в качестве примера

  * POST http://localhost:7474/db/data/transaction/commit
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "операторы": [{
    "оператор": "СОЗДАЙТЕ идентификатор ВОЗВРАТА n (n)"
  } ]
}

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json

{
  "результаты": [{
    "столбцы": ["идентификатор (n)"],
    "данные": [{
      "строка": [15]
    } ]
  } ],
  "погрешности": []
}

19.1.8. Возвратите результаты в формате графика

Если Вы хотите понять строение графика вершин и отношений
возвращенный Вашим запросом, Вы можете определить формат данных результатов "графика". Для
пример, это полезно, когда Вы хотите визуализировать строение графика.
формат сопоставляет все вершины и отношения от всех столбцов результата,
и также сглаживает наборы вершин и отношений, включая пути.

Запрос в качестве примера

  * POST http://localhost:7474/db/data/transaction/commit
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "операторы": [{
    "оператор": "СОЗДАЙТЕ (bike:Bike {вес: 10}), СОЗДАЮТ (frontWheel:Wheel {спицы: 3}), СОЗДАЮТ (backWheel:Wheel {спицы: 32}), СОЗДАЮТ p1 = велосипед - [:HAS {позиция: 1}]-> с передними ведущими колесами СОЗДАЮТ p2 = велосипед - [:HAS {позиция: 2}]-> backWheel ВОЗВРАЩАЮТ велосипед, p1, p2",
    "resultDataContents": ["строка", "график"]
  } ]
}

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json

{
  "результаты": [{
    "столбцы": ["велосипед", "p1", "p2"],
    "данные": [{
      "строка": [{
        "вес": 10
      }, [{
        "вес": 10
      }, {
        "позиция": 1
      }, {
        "спицы": 3
      }], [{
        "вес": 10
      }, {
        "позиция": 2
      }, {
        "спицы": 32
      } ] ],
      "график": {
        "вершины": [{
          "идентификатор": "17",
          "метки": ["Колесо"],
          "свойства": {
            "спицы": 3
          }
        }, {
          "идентификатор": "16",
          "метки": ["Велосипед"],
          "свойства": {
            "вес": 10
          }
        }, {
          "идентификатор": "18",
          "метки": ["Колесо"],
          "свойства": {
            "спицы": 32
          }
        } ],
        "отношения": [{
          "идентификатор": "9",
          "введите": "ИМЕЕТ",
          "startNode": "16",
          "endNode": "17",
          "свойства": {
            "позиция": 1
          }
        }, {
          "идентификатор": "10",
          "введите": "ИМЕЕТ",
          "startNode": "16",
          "endNode": "18",
          "свойства": {
            "позиция": 2
          }
        } ]
      }
    } ]
  } ],
  "погрешности": []
}

19.1.9. Ошибки из-за неправильного обращения

Результат любого запроса против конечной точки транзакции передан потоком назад к
клиент. Поэтому сервер не знает, будет ли запрос
успешный или не, когда это отправляет код состояния HTTP.

Из-за этого возвратятся все запросы против транзакционной конечной точки
200 или 201 код состояния, независимо от того, были ли операторы успешно
выполняемый. В конце полезной нагрузки реакции сервер включает список
погрешности, которые произошли, выполняя операторы. Если этот список пуст,
запрос завершался успешно.

Если какие-либо погрешности произойдут, выполняя операторы, то сервер будет откатывать
транзакция.

В этом примере мы отправляем серверу недопустимый оператор, чтобы демонстрировать погрешность
обработка.

Для получения дополнительной информации по кодам состояний, см. Раздел 19.2, “Состояние Neo4j
Коды”.

Запрос в качестве примера

  * POST http://localhost:7474/db/data/transaction/8/commit
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "операторы": [{
    "оператор": "Это не допустимый Оператор Кода."
  } ]
}

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json

{
  "результаты": [],
  "погрешности": [{
    "код": "Нео. ClientError. Оператор. InvalidSyntax",
    "сообщение": "Недопустимый ввод 'T': ожидаемый SingleStatement (строка 1, столбец 1) \n \"Это не допустимый Код Statement. \"\n ^"
  } ]
}

19.2. Коды состояний Neo4j

19.2.1. Классификации
19.2.2. Коды состояний

Транзакционный май конечной точки в любой реакции включает нуль или больше состояния
коды, указывая проблемы или информацию для клиента. Каждый код состояния
следует за тем же самым форматом: "Нео. [Классификация]. [Категория]. [Заголовок]". Факт
то, что код состояния возвращен сервером, действительно всегда означает, что есть фатальное
погрешность. Коды состояний могут также указать переходные проблемы, которые могут уйти если
Вы повторяете запрос.

То, что эффект кода состояния, может быть определено его классификацией.

Замечание

Это не та же самая вещь как коды состояний HTTP. Коды состояний Neo4j
возвращенный в корпусе реакции, в самом конце реакции.

19.2.1. Классификации

Эффект Описания классификации на
                                                                    транзакция
ClientError Клиент отправил плохой запрос - изменение запроса Ни один
               мог бы привести к благоприятному итогу.

DatabaseError база данных был не в состоянии обслужить запрос. Откат

TransientError база данных не может обслужить запрос прямо сейчас, Ни один
               повторение позже могло бы привести к благоприятному итогу.

19.2.2. Коды состояний

Это - полный список всех кодов состояний, которые Neo4j может возвратить, и что они
среднее значение.

Описание Кода состояния
Нео. ClientError. Запрос. Недопустимый клиент обеспечил недопустимое
                                               запрос.

Нео. ClientError. Запрос. InvalidFormat клиент обеспечил запрос
                                               это пропускало требуемый
                                               поля, или имел значения, которые являются
                                               не позволенный.

Neo.ClientError.Schema.ConstraintViolation ограничение, наложенное
                                               база данных была нарушена.

Нео. ClientError. Схема. NoSuchConstraint запрос (прямо или
                                               косвенно), упомянул a
                                               ограничение, которое не существует.

Нео. ClientError. Схема. NoSuchIndex запрос (прямо или
                                               косвенно), упомянул индексирование
                                               это не существует.

Neo.ClientError.Statement.ArithmeticError Недопустимое использование арифметики, такого
                                               как деление на нуль.

Neo.ClientError.Statement.ConstraintViolation ограничение, наложенное
                                               оператор нарушен
                                               данные в базе данных.

Нео. ClientError. Оператор. Оператор EntityNotFound The прямо
                                               обращение к объекту, который делает
                                               не существуют.

Оператор Neo.ClientError.Statement.InvalidSemantics THE синтаксически
                                               допустимый, но экспрессы что-то
                                               то, что база данных не может сделать.

Нео. ClientError. Оператор. Оператор InvalidSyntax The делится без остатка недопустимый
                                               или незакрепленный синтаксис.

Нео. ClientError. Оператор. Оператор InvalidType The пытается к
                                               выполните операции на значениях
                                               с типами, которые не являются
                                               поддерживаемый работой.

Оператор Neo.ClientError.Statement.ParameterMissing THE обращается к a
                                               параметр, который не был обеспечен
                                               в запросе.

Neo.ClientError.Transaction.ConcurrentRequest были параллельные запросы
                                               доступ к той же самой транзакции,
                                               который не позволен.

Нео. ClientError. Транзакция. UnknownId запрос упомянул a
                                               транзакция, которая не существует.

Нео. DatabaseError. Общий. FailedIndex запрос (прямо или
                                               косвенно), упомянул индексирование
                                               это находится в отказавшем состоянии.
                                               индексируйте потребности, которые будут отброшены и
                                               воссозданный вручную.

Нео. DatabaseError. Общий. UnknownFailure неизвестный отказ произошел.

Neo.DatabaseError.Statement.ExecutionFailure база данных была неспособна к
                                               выполните оператор.

Neo.DatabaseError.Transaction.CouldNotBegin база данных была неспособна запуститься
                                               транзакция.

Neo.DatabaseError.Transaction.CouldNotCommit база данных была неспособна к
                                               фиксируйте транзакцию.

Neo.DatabaseError.Transaction.CouldNotRollback база данных была неспособна прокрутиться
                                               поддержите транзакцию.

Neo.TransientError.Network.UnknownFailure неизвестный сетевой отказ
                                               произошедший, повторная попытка может решить
                                               проблема.

19.3. Корень службы

19.3.1. Получите корень службы

19.3.1. Получите корень службы

Корень службы - Ваша начальная точка, чтобы обнаружить остальных API. Это делится без остатка
основные начальные точки для базы данных, и некоторая версия и расширение
информация.

Рисунок 19.1. Конечный График

Final-Graph-Get-service-root.svg


Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/db/data/
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

{
  "расширения": {
  },
  "вершина": "http://localhost:7474/db/data/node",
  "node_index": "http://localhost:7474/db/data/index/node",
  "relationship_index": "http://localhost:7474/db/data/index/relationship",
  "extensions_info": "http://localhost:7474/db/data/ext",
  "relationship_types": "http://localhost:7474/db/data/relationship/types",
  "пакет": "http://localhost:7474/db/data/batch",
  "код": "http://localhost:7474/db/data/cypher",
  "транзакция": "http://localhost:7474/db/data/transaction",
  "neo4j_version": "2.0.0"
}

19.4. Потоковая передача

Все реакции от остальных API могут быть переданы как потоки ДЖСОНА, следуя
в лучшей производительности и более низких издержках памяти на стороне сервера. Использовать
передавая потоком, предоставьте X-поток головной части: истина с каждым запросом.

Рисунок 19.2. Конечный График

Final-Graph-streaming.svg


Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/db/data/
  * Примите: application/json
  * X-поток: истина

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8; stream=true

{
  "расширения": {
  },
  "вершина": "http://localhost:7474/db/data/node",
  "node_index": "http://localhost:7474/db/data/index/node",
  "relationship_index": "http://localhost:7474/db/data/index/relationship",
  "extensions_info": "http://localhost:7474/db/data/ext",
  "relationship_types": "http://localhost:7474/db/data/relationship/types",
  "пакет": "http://localhost:7474/db/data/batch",
  "код": "http://localhost:7474/db/data/cypher",
  "транзакция": "http://localhost:7474/db/data/transaction",
  "neo4j_version": "2.0.0"
}

19.5. Код запрашивает через REST

19.5.1. Используйте параметры
19.5.2. Создайте вершину
19.5.3. Создайте вершину с разнообразными свойствами
19.5.4. Создайте mutiple вершины со свойствами
19.5.5. Установите все свойства на вершине, используя Код
19.5.6. Отправьте запрос
19.5.7. Обратные пути
19.5.8. Вложенные результаты
19.5.9. Получите метаданные запроса
19.5.10. Погрешности

API REST Neo4j позволяет запрашивать с Кодом, см. Часть III, “Запрос Кода
Язык”. Результаты возвращены как список строковых головных частей (столбцы), и
часть данных, строение списка всех строк, каждое строение строки списка
из представлений REST значения поля  -  Вершина, Отношение, Путь или любой
простое значение как Строка.

Подсказка

Чтобы ускорить запросы в повторенных сценариях, попытайтесь не использовать литералы, но
замените их параметрами везде, где возможный, чтобы пустить кэшу сервера
запросите схемы, см. Раздел 19.5.1, “Параметры использования” для деталей. Также см.
Раздел 7.5, "Параметры" для того, где параметры могут использоваться.

19.5.1. Используйте параметры

Код поддерживает запросы с параметрами, которые представлены как ДЖСОН.

СООТВЕТСТВИЕ (x {имя: {startName}}) - [r] - (друг)
ГДЕ friend.name = {имя}
ВОЗВРАТИТЕ ТИП (R)

Рисунок 19.3. Конечный График

Final-Graph-Use-parameters.svg


Запрос в качестве примера

  * POST http://localhost:7474/db/data/cypher
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "запрос": "СООТВЕТСТВИЕ (x {имя: {startName}}) - [r] - (друг), ГДЕ friend.name = {имя} ТИП (R) ВОЗВРАТА",
  "params": {
    "startName": "I",
    "имя": "Вы"
  }
}

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

{
  "столбцы": ["ТИП (R)"],
  "данные": [["знать"]]
}

19.5.2. Создайте вершину

Создайте вершину с меткой и свойством, используя Код. См. запрос на
параметр передался с запросом.

СОЗДАЙТЕ (n:Person {имя: {имя}})
ВОЗВРАТИТЕ n

Рисунок 19.4. Конечный График

Final-Graph-Create-a-node.svg


Запрос в качестве примера

  * POST http://localhost:7474/db/data/cypher
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "запрос": "СОЗДАЙТЕ (n:Person {имя: {имя}}), ВОЗВРАЩАЮТ n",
  "params": {
    "имя": "Андрес"
  }
}

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

{
  "столбцы": ["n"],
  "данные": [[{
    "outgoing_relationships": "http://localhost:7474/db/data/node/47/relationships/out",
    "метки": "http://localhost:7474/db/data/node/47/labels",
    "данные": {
      "имя": "Андрес"
    },
    "all_typed_relationships": "http://localhost:7474/db/data/node/47/relationships/all/ {-list|&|types}",
    "траверз": "http://localhost:7474/db/data/node/47/traverse/ {returnType}",
    "сам": "http://localhost:7474/db/data/node/47",
    "свойство": "http://localhost:7474/db/data/node/47/properties/ {ключ}",
    "свойства": "http://localhost:7474/db/data/node/47/properties",
    "outgoing_typed_relationships": "http://localhost:7474/db/data/node/47/relationships/out/ {-list|&|types}",
    "incoming_relationships": "http://localhost:7474/db/data/node/47/relationships/in",
    "расширения": {
    },
    "create_relationship": "http://localhost:7474/db/data/node/47/relationships",
    "paged_traverse": "http://localhost:7474/db/data/node/47/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
    "all_relationships": "http://localhost:7474/db/data/node/47/relationships/all",
    "incoming_typed_relationships": "http://localhost:7474/db/data/node/47/relationships/in/ {-list|&|types}"
  } ] ]
}

19.5.3. Создайте вершину с разнообразными свойствами

Создайте вершину с меткой и разнообразными свойствами, используя Код. См.
запрос на параметр передался с запросом.

СОЗДАЙТЕ (n:Person {опоры})
ВОЗВРАТИТЕ n

Рисунок 19.5. Конечный График

Final-Graph-Create-a-node-with-multiple-properties.svg


Запрос в качестве примера

  * POST http://localhost:7474/db/data/cypher
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "запрос": "СОЗДАЙТЕ (n:Person {опоры}) ВОЗВРАЩАЮТ n",
  "params": {
    "опоры": {
      "позиция": "Разработчик",
      "имя": "Майкл",
      "удивительный": истина,
      "дочерние элементы": 3
    }
  }
}

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

{
  "столбцы": ["n"],
  "данные": [[{
    "outgoing_relationships": "http://localhost:7474/db/data/node/44/relationships/out",
    "метки": "http://localhost:7474/db/data/node/44/labels",
    "данные": {
      "позиция": "Разработчик",
      "удивительный": истина,
      "имя": "Майкл",
      "дочерние элементы": 3
    },
    "all_typed_relationships": "http://localhost:7474/db/data/node/44/relationships/all/ {-list|&|types}",
    "траверз": "http://localhost:7474/db/data/node/44/traverse/ {returnType}",
    "сам": "http://localhost:7474/db/data/node/44",
    "свойство": "http://localhost:7474/db/data/node/44/properties/ {ключ}",
    "свойства": "http://localhost:7474/db/data/node/44/properties",
    "outgoing_typed_relationships": "http://localhost:7474/db/data/node/44/relationships/out/ {-list|&|types}",
    "incoming_relationships": "http://localhost:7474/db/data/node/44/relationships/in",
    "расширения": {
    },
    "create_relationship": "http://localhost:7474/db/data/node/44/relationships",
    "paged_traverse": "http://localhost:7474/db/data/node/44/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
    "all_relationships": "http://localhost:7474/db/data/node/44/relationships/all",
    "incoming_typed_relationships": "http://localhost:7474/db/data/node/44/relationships/in/ {-list|&|types}"
  } ] ]
}

19.5.4. Создайте mutiple вершины со свойствами

Создайте разнообразные вершины со свойствами, используя Код. См. запрос на
параметр передался с запросом.

СОЗДАЙТЕ (n:Person {опоры})
ВОЗВРАТИТЕ n

Рисунок 19.6. Конечный График

Final-Graph-Create-mutiple-nodes-with-properties.svg


Запрос в качестве примера

  * POST http://localhost:7474/db/data/cypher
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "запрос": "СОЗДАЙТЕ (n:Person {опоры}) ВОЗВРАЩАЮТ n",
  "params": {
    "опоры": [{
      "имя": "Андрес",
      "позиция": "Разработчик"
    }, {
      "имя": "Майкл",
      "позиция": "Разработчик"
    } ]
  }
}

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

{
  "столбцы": ["n"],
  "данные": [[{
    "outgoing_relationships": "http://localhost:7474/db/data/node/48/relationships/out",
    "метки": "http://localhost:7474/db/data/node/48/labels",
    "данные": {
      "позиция": "Разработчик",
      "имя": "Андрес"
    },
    "all_typed_relationships": "http://localhost:7474/db/data/node/48/relationships/all/ {-list|&|types}",
    "траверз": "http://localhost:7474/db/data/node/48/traverse/ {returnType}",
    "сам": "http://localhost:7474/db/data/node/48",
    "свойство": "http://localhost:7474/db/data/node/48/properties/ {ключ}",
    "свойства": "http://localhost:7474/db/data/node/48/properties",
    "outgoing_typed_relationships": "http://localhost:7474/db/data/node/48/relationships/out/ {-list|&|types}",
    "incoming_relationships": "http://localhost:7474/db/data/node/48/relationships/in",
    "расширения": {
    },
    "create_relationship": "http://localhost:7474/db/data/node/48/relationships",
    "paged_traverse": "http://localhost:7474/db/data/node/48/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
    "all_relationships": "http://localhost:7474/db/data/node/48/relationships/all",
    "incoming_typed_relationships": "http://localhost:7474/db/data/node/48/relationships/in/ {-list|&|types}"
  }], [{
    "outgoing_relationships": "http://localhost:7474/db/data/node/49/relationships/out",
    "метки": "http://localhost:7474/db/data/node/49/labels",
    "данные": {
      "позиция": "Разработчик",
      "имя": "Майкл"
    },
    "all_typed_relationships": "http://localhost:7474/db/data/node/49/relationships/all/ {-list|&|types}",
    "траверз": "http://localhost:7474/db/data/node/49/traverse/ {returnType}",
    "сам": "http://localhost:7474/db/data/node/49",
    "свойство": "http://localhost:7474/db/data/node/49/properties/ {ключ}",
    "свойства": "http://localhost:7474/db/data/node/49/properties",
    "outgoing_typed_relationships": "http://localhost:7474/db/data/node/49/relationships/out/ {-list|&|types}",
    "incoming_relationships": "http://localhost:7474/db/data/node/49/relationships/in",
    "расширения": {
    },
    "create_relationship": "http://localhost:7474/db/data/node/49/relationships",
    "paged_traverse": "http://localhost:7474/db/data/node/49/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
    "all_relationships": "http://localhost:7474/db/data/node/49/relationships/all",
    "incoming_typed_relationships": "http://localhost:7474/db/data/node/49/relationships/in/ {-list|&|types}"
  } ] ]
}

19.5.5. Установите все свойства на вершине, используя Код

Установите все свойства на вершине.

СОЗДАЙТЕ (n:Person {имя: 'это свойство должно быть стерто'}),
НАБОР n = {опоры}
ВОЗВРАТИТЕ n

Рисунок 19.7. Конечный График

Final-Graph-Set-all-properties-on-a-node-using-Cypher.svg


Запрос в качестве примера

  * POST http://localhost:7474/db/data/cypher
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "запрос": "СОЗДАЙТЕ (n:Person {имя: 'это свойство должно быть стерто'}), УСТАНАВЛИВАЕТ n = n ВОЗВРАТА {опор}",
  "params": {
    "опоры": {
      "позиция": "Разработчик",
      "firstName": "Майкл",
      "удивительный": истина,
      "дочерние элементы": 3
    }
  }
}

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

{
  "столбцы": ["n"],
  "данные": [[{
    "outgoing_relationships": "http://localhost:7474/db/data/node/75/relationships/out",
    "метки": "http://localhost:7474/db/data/node/75/labels",
    "данные": {
      "позиция": "Разработчик",
      "удивительный": истина,
      "дочерние элементы": 3,
      "firstName": "Майкл"
    },
    "all_typed_relationships": "http://localhost:7474/db/data/node/75/relationships/all/ {-list|&|types}",
    "траверз": "http://localhost:7474/db/data/node/75/traverse/ {returnType}",
    "сам": "http://localhost:7474/db/data/node/75",
    "свойство": "http://localhost:7474/db/data/node/75/properties/ {ключ}",
    "свойства": "http://localhost:7474/db/data/node/75/properties",
    "outgoing_typed_relationships": "http://localhost:7474/db/data/node/75/relationships/out/ {-list|&|types}",
    "incoming_relationships": "http://localhost:7474/db/data/node/75/relationships/in",
    "расширения": {
    },
    "create_relationship": "http://localhost:7474/db/data/node/75/relationships",
    "paged_traverse": "http://localhost:7474/db/data/node/75/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
    "all_relationships": "http://localhost:7474/db/data/node/75/relationships/all",
    "incoming_typed_relationships": "http://localhost:7474/db/data/node/75/relationships/in/ {-list|&|types}"
  } ] ]
}

19.5.6. Отправьте запрос

Простой запрос, возвращая все вершины соединялся с некоторой вершиной, возвращая вершину
и свойство имени, если это существует, иначе НУЛЬ:

СООТВЕТСТВИЕ (x {имя: 'Я'}) - [r]-> (n)
ВОЗВРАТИТЕ тип (r), n.name, n.age

Рисунок 19.8. Конечный График

Final-Graph-Send-a-query.svg


Запрос в качестве примера

  * POST http://localhost:7474/db/data/cypher
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "запрос": "СООТВЕТСТВИЕ (x {имя: 'Я'}) - [r]-> (n) ВОЗВРАЩАЮТ тип (r), n.name, n.age",
  "params": {
  }
}

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

{
  "столбцы": ["тип (r)", "n.name", "n.age"],
  "данные": [["знайте", "его", 25], ["знают", "Вы", нуль]]
}

19.5.7. Обратные пути

Пути могут быть возвращены точно так же как другие типы возврата.

Путь СООТВЕТСТВИЯ = (x {имя: 'Я'}) - (друг)
ОБРАТНЫЙ ПУТЬ, friend.name

Рисунок 19.9. Конечный График

Final-Graph-Return-paths.svg


Запрос в качестве примера

  * POST http://localhost:7474/db/data/cypher
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "запрос": "СООТВЕТСТВУЙТЕ путь = (x {имя: 'Я'}) - (друг) ОБРАТНЫЙ ПУТЬ, friend.name",
  "params": {
  }
}

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

{
  "столбцы": ["путь", "friend.name"],
  "данные": [[{
    "запустите": "http://localhost:7474/db/data/node/74",
    "вершины": ["http://localhost:7474/db/data/node/74", "http://localhost:7474/db/data/node/73"],
    "длина": 1,
    "отношения": ["http://localhost:7474/db/data/relationship/20"],
    "конец": "http://localhost:7474/db/data/node/73"
  }, "Вы"]]
}

19.5.8. Вложенные результаты

Отправляя запросы, которые возвращают вложенные результаты как список и карты, они будут
получите сериализированными во вложенные представления ДЖСОНА согласно их типам.

СООТВЕТСТВИЕ (n)
ГДЕ n.name В ['я', 'Вы']
ВОЗВРАТ собирается (n.name)

Рисунок 19.10. Конечный График

Final-Graph-nested-results.svg


Запрос в качестве примера

  * POST http://localhost:7474/db/data/cypher
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "запрос": "СООТВЕТСТВИЕ (n), ГДЕ n.name в ['я', 'Вы'] ВОЗВРАТ собираются (n.name)",
  "params": {
  }
}

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

{
  "столбцы": ["соберитесь (n.name)"],
  "данные": [[["Вы", "I"]]]
}

19.5.9. Получите метаданные запроса

Передавая в дополнительном ПОЛУЧАЮТ параметр, когда Вы выполняете запросы Кода,
метаданные о запросе будут возвращены, такой как, сколько меток было прибавлено
или удаленный запросом.

СООТВЕТСТВИЕ (n {имя: 'Я'})
НАБОР n:Actor
ПЕРЕМЕЩЕНИЕ n:Director
ВОЗВРАТИТЕ метки (n)

Рисунок 19.11. Конечный График

Final-Graph-Retrieve-query-metadata.svg


Запрос в качестве примера

  * POST http://localhost:7474/db/data/cypher?includeStats=true
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "запрос": "СООТВЕТСТВИЕ (n {имя: 'Я'}), УСТАНАВЛИВАЕТ ПЕРЕМЕЩЕНИЕ n:Actor n:Director метки ВОЗВРАТА (n)",
  "params": {
  }
}

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

{
  "столбцы": ["метки (n)"],
  "данные": [[["Агент"]]],
  "stats": {
    "relationships_created": 0,
    "nodes_deleted": 0,
    "relationship_deleted": 0,
    "indexes_added": 0,
    "properties_set": 0,
    "constraints_removed": 0,
    "indexes_removed": 0,
    "labels_removed": 1,
    "constraints_added": 0,
    "labels_added": 1,
    "nodes_created": 0,
    "contains_updates": истина
  }
}

19.5.10. Погрешности

О погрешностях на сервере сообщат как JSON-форматированное сообщение, исключение
имя и stacktrace.

СООТВЕТСТВИЕ (x {имя: 'Я'})
ВОЗВРАТИТЕ x.dummy/0

Рисунок 19.12. Конечный График

Final-Graph-Errors.svg


Запрос в качестве примера

  * POST http://localhost:7474/db/data/cypher
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "запрос": "СООТВЕТСТВИЕ (x {имя: 'Я'}), ВОЗВРАЩАЮТ x.dummy/0",
  "params": {
  }
}

Реакция в качестве примера

  * 400: Плохой Запрос
  * Тип контента: application/json; charset=UTF-8

{
  "сообщение": "/нулем",
  "исключение": "ArithmeticException",
  "fullname": "org.neo4j.cypher. ArithmeticException",
  "stacktrace": [
    "org.neo4j.cypher.internal.compiler.v2_0.commands.expressions.Divide.apply (Делятся scala:36)",
    "org.neo4j.cypher.internal.compiler.v2_0.pipes.ExtractPipe$$anonfun$internalCreateResults$1$$anonfun$apply$2.apply (ExtractPipe.scala:51)",
    "org.neo4j.cypher.internal.compiler.v2_0.pipes.ExtractPipe$$anonfun$internalCreateResults$1$$anonfun$apply$2.apply (ExtractPipe.scala:49)",
    "scala.collection.immutable.Map$Map1.foreach (Карта scala:109)",
    "org.neo4j.cypher.internal.compiler.v2_0.pipes.ExtractPipe$$anonfun$internalCreateResults$1.apply (ExtractPipe.scala:49)",
    "org.neo4j.cypher.internal.compiler.v2_0.pipes.ExtractPipe$$anonfun$internalCreateResults$1.apply (ExtractPipe.scala:48)",
    "scala.collection. Iterator$$anon$11.next (Iterator.scala:328)",
    "scala.collection. Iterator$$anon$11.next (Iterator.scala:328)",
    "org.neo4j.cypher.internal.compiler.v2_0.ClosingIterator$$anonfun$next$1.apply (ClosingIterator.scala:46)",
    "org.neo4j.cypher.internal.compiler.v2_0.ClosingIterator$$anonfun$next$1.apply (ClosingIterator.scala:45)",
    "org.neo4j.cypher.internal.compiler.v2_0.ClosingIterator.failIfThrows (ClosingIterator.scala:91)",
    "org.neo4j.cypher.internal.compiler.v2_0.ClosingIterator.next (ClosingIterator.scala:45)",
    "org.neo4j.cypher.internal.compiler.v2_0.PipeExecutionResult.next (PipeExecutionResult.scala:168)",
    "org.neo4j.cypher.internal.compiler.v2_0.PipeExecutionResult.next (PipeExecutionResult.scala:34)",
    "scala.collection. Iterator$$anon$11.next (Iterator.scala:328)",
    "scala.collection.convert.Wrappers$IteratorWrapper.next (Обертки scala:30)",
    "org.neo4j.cypher.internal.compiler.v2_0.PipeExecutionResult$$anon$1.next (PipeExecutionResult.scala:76)",
    "org.neo4j.helpers.collection.ExceptionHandlingIterable$1.next (ExceptionHandlingIterable.java:53)",
    "org.neo4j.helpers.collection.IteratorWrapper.next (IteratorWrapper.java:47)",
    "org.neo4j.server.rest.repr.ListRepresentation.serialize (ListRepresentation.java:64)",
    "org.neo4j.server.rest.repr.Serializer.serialize (Сериализатор java:75)",
    "org.neo4j.server.rest.repr.MappingSerializer.putList (MappingSerializer.java:61)",
    "org.neo4j.server.rest.repr.CypherResultRepresentation.serialize (CypherResultRepresentation.java:83)",
    "org.neo4j.server.rest.repr.MappingRepresentation.serialize (MappingRepresentation.java:41)",
    "org.neo4j.server.rest.repr.OutputFormat.assemble (OutputFormat.java:215)",
    "org.neo4j.server.rest.repr.OutputFormat.formatRepresentation (OutputFormat.java:147)",
    "org.neo4j.server.rest.repr.OutputFormat.response (OutputFormat.java:130)",
    "org.neo4j.server.rest.repr.OutputFormat.ok (OutputFormat.java:67)",
    "org.neo4j.server.rest.web.CypherService.cypher (CypherService.java:101)",
    "java.lang.reflect. Method.invoke (Метод java:606)",
    "org.neo4j.server.rest.transactional.TransactionalRequestDispatcher.dispatch (TransactionalRequestDispatcher.java:132)",
    "org.neo4j.server.rest.security.SecurityFilter.doFilter (SecurityFilter.java:112)",
    "java.lang. Thread.run (Поток java:724)"
  ]
}

19.6. Значения свойств

19.6.1. Массивы
19.6.2. Ключи свойства
19.6.3. Перечислите все ключи свойства

ОСТАЛЬНОЕ API позволяет устанавливать свойства на вершинах и отношениях через
прямые УСПОКОИТЕЛЬНЫЕ операции. Однако, есть сужения относительно какой типы
значения могут использоваться в качестве значений свойств. Позволенные типы значения следующие:

  * Номера: Оба целочисленных значения, с емкостью как Длинный тип Java, и
    плавающие точки, с емкостью как Двойное количество Java.
  * Булевские переменные.
  * Строки.
  * Массивы основных типов выше.

19.6.1. Массивы

Есть два важных момента, которые будут сделаны о значениях массива. Во-первых, все значения
в массиве должен иметь тот же самый тип. Это означает любой весь целые числа, все
плавания, все булевские переменные или все строки. Смешивание типов в настоящий момент не поддерживается.

Во-вторых, хранение пустых массивов является только возможными данными определенными предварительными условиями.
Поскольку формат передачи ДЖСОНА не содержит информацию о типе для массивов,
тип выведен из значений в массиве. Если массив пуст, Neo4j
Сервер не может определить тип. В этих случаях это проверит, ли массив
уже сохраненный для данного свойства, и будет использовать тип сохраненного массива
храня пустой массив. Если никакой массив уже не будет существовать, то сервер будет
отклоните запрос.

19.6.2. Ключи свойства

Вы можете перечислить все ключи свойства, когда-либо используемые в базе данных. Это включает и
ключи свойства Вы использовали, но стерли.

Нет в настоящий момент никакого способа сказать, которые используются и которые не,
за исключением обхода всего набора свойств в базе данных.

19.6.3. Перечислите все ключи свойства

Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/db/data/propertykeys
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

["firstName", "некоторые - ключ", "последовательность", "удивительная", "опора", "стоимость", "несуществующая", "例子 öäüÖÄÜß", "значение", "ключ", "array1", "ID", "array2", "Имя", "счастливое", "foo", "имена", "дочерние элементы", "с тех пор", "массив", "kvkey2", "a", "позиция", "возраст", "имя", "kvkey1"]

19.7. Вершины

19.7.1. Создайте вершину
19.7.2. Создайте вершину со свойствами
19.7.3. Получите вершину
19.7.4. Получите несуществующую вершину
19.7.5. Сотрите вершину
19.7.6. Вершины с отношениями не могут быть стерты

19.7.1. Создайте вершину

Рисунок 19.13. Конечный График

Final-Graph-create-node.svg


Запрос в качестве примера

  * POST http://localhost:7474/db/data/node
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 201: Создаваемый
  * Тип контента: application/json; charset=UTF-8
  * Расположение: http://localhost:7474/db/data/node/8

{
  "расширения": {
  },
  "outgoing_relationships": "http://localhost:7474/db/data/node/8/relationships/out",
  "метки": "http://localhost:7474/db/data/node/8/labels",
  "all_typed_relationships": "http://localhost:7474/db/data/node/8/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/8/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/8",
  "свойство": "http://localhost:7474/db/data/node/8/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/8/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/8/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/8/relationships/in",
  "create_relationship": "http://localhost:7474/db/data/node/8/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/8/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/8/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/8/relationships/in/ {-list|&|types}",
  "данные": {
  }
}

19.7.2. Создайте вершину со свойствами

Рисунок 19.14. Конечный График

Final-Graph-create-node-with-properties.svg


Запрос в качестве примера

  * POST http://localhost:7474/db/data/node
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "foo": "бар"
}

Реакция в качестве примера

  * 201: Создаваемый
  * Длиной до контента: 1156
  * Тип контента: application/json; charset=UTF-8
  * Расположение: http://localhost:7474/db/data/node/4

{
  "расширения": {
  },
  "outgoing_relationships": "http://localhost:7474/db/data/node/4/relationships/out",
  "метки": "http://localhost:7474/db/data/node/4/labels",
  "all_typed_relationships": "http://localhost:7474/db/data/node/4/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/4/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/4",
  "свойство": "http://localhost:7474/db/data/node/4/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/4/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/4/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/4/relationships/in",
  "create_relationship": "http://localhost:7474/db/data/node/4/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/4/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/4/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/4/relationships/in/ {-list|&|types}",
  "данные": {
    "foo": "бар"
  }
}

19.7.3. Получите вершину

Заметьте, что реакция содержит URI/шаблоны для доступных операций для
получение свойств и отношений.

Рисунок 19.15. Конечный График

Final-Graph-Get-node.svg


Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/db/data/node/30
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

{
  "расширения": {
  },
  "outgoing_relationships": "http://localhost:7474/db/data/node/30/relationships/out",
  "метки": "http://localhost:7474/db/data/node/30/labels",
  "all_typed_relationships": "http://localhost:7474/db/data/node/30/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/30/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/30",
  "свойство": "http://localhost:7474/db/data/node/30/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/30/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/30/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/30/relationships/in",
  "create_relationship": "http://localhost:7474/db/data/node/30/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/30/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/30/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/30/relationships/in/ {-list|&|types}",
  "данные": {
  }
}

19.7.4. Получите несуществующую вершину

Рисунок 19.16. Конечный График

Final-Graph-Get-non-existent-node.svg


Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/db/data/node/3400000
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 404: Не Найденный
  * Тип контента: application/json; charset=UTF-8

{
  "сообщение": "Не может обнаружить вершину с идентификатором [3400000] в базе данных.",
  "исключение": "NodeNotFoundException",
  "fullname": "org.neo4j.server.rest.web.NodeNotFoundException",
  "stacktrace": [
    "org.neo4j.server.rest.web.DatabaseActions.node (DatabaseActions.java:183)",
    "org.neo4j.server.rest.web.DatabaseActions.getNode (DatabaseActions.java:228)",
    "org.neo4j.server.rest.web.RestfulGraphDatabase.getNode (RestfulGraphDatabase.java:266)",
    "java.lang.reflect. Method.invoke (Метод java:606)",
    "org.neo4j.server.rest.transactional.TransactionalRequestDispatcher.dispatch (TransactionalRequestDispatcher.java:132)",
    "org.neo4j.server.rest.security.SecurityFilter.doFilter (SecurityFilter.java:112)",
    "java.lang. Thread.run (Поток java:724)"
  ]
}

19.7.5. Сотрите вершину

Рисунок 19.17. Конечный График

Final-Graph-Delete-node.svg


Запрос в качестве примера

  * СТИРАЮТ http://localhost:7474/db/data/node/5
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 204: Никакой Контент

19.7.6. Вершины с отношениями не могут быть стерты

Отношения на вершине должны быть стерты прежде, чем вершина может быть стерта.

Рисунок 19.18. Конечный График

Final-Graph-Nodes-with-relationships-cannot-be-deleted.svg


Запрос в качестве примера

  * СТИРАЮТ http://localhost:7474/db/data/node/12
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 409: Конфликт
  * Тип контента: application/json; charset=UTF-8

{
  "сообщение": "Вершина с идентификатором 12 не может быть стерта. Проверьте, что вершина является осиротевшей перед удалением.",
  "исключение": "OperationFailureException",
  "fullname": "org.neo4j.server.rest.web.OperationFailureException",
  "stacktrace": [
    "org.neo4j.server.rest.web.DatabaseActions.deleteNode (DatabaseActions.java:237)",
    "org.neo4j.server.rest.web.RestfulGraphDatabase.deleteNode (RestfulGraphDatabase.java:280)",
    "java.lang.reflect. Method.invoke (Метод java:606)",
    "org.neo4j.server.rest.transactional.TransactionalRequestDispatcher.dispatch (TransactionalRequestDispatcher.java:132)",
    "org.neo4j.server.rest.security.SecurityFilter.doFilter (SecurityFilter.java:112)",
    "java.lang. Thread.run (Поток java:724)"
  ]
}

19.8. Отношения

19.8.1. Получите Отношение ID
19.8.2. Создайте отношение
19.8.3. Создайте отношение со свойствами
19.8.4. Сотрите отношение
19.8.5. Получите все свойства на отношении
19.8.6. Установите все свойства на отношении
19.8.7. Получите единственное свойство на отношении
19.8.8. Набор единственное свойство на отношении
19.8.9. Получите все отношения
19.8.10. Получите входящие отношения
19.8.11. Получите исходящие отношения
19.8.12. Получите введенные отношения
19.8.13. Получите отношения на вершине без отношений

Отношения - гражданин первого класса в API REST Neo4j. Они могут быть
полученный доступ или автономный или через вершины они присоединены.

Общая модель, чтобы получить отношения от вершины:

ДОБЕРИТЕСЬ http://localhost:7474/db/data/node/123/relationships/ {dir} / {-list|&|types}

Где dir - один из всех, в, и типы разделенный от амперсанда список
типы. См. примеры ниже для получения дополнительной информации.

19.8.1. Получите Отношение ID

Рисунок 19.19. Конечный График

Final-Graph-get-Relationship-by-ID.svg


Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/db/data/relationship/30
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

{
  "расширения": {
  },
  "запустите": "http://localhost:7474/db/data/node/139",
  "свойство": "http://localhost:7474/db/data/relationship/30/properties/ {ключ}",
  "сам": "http://localhost:7474/db/data/relationship/30",
  "свойства": "http://localhost:7474/db/data/relationship/30/properties",
  "введите": "знайте",
  "конец": "http://localhost:7474/db/data/node/138",
  "данные": {
  }
}

19.8.2. Создайте отношение

После успешного создания отношения возвращено новое отношение.

Рисунок 19.20. Конечный График

Final-Graph-Create-relationship.svg


Запрос в качестве примера

  * POST http://localhost:7474/db/data/node/1/relationships
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "к": "http://localhost:7474/db/data/node/0",
  "введите": "ЛЮБИТ"
}

Реакция в качестве примера

  * 201: Создаваемый
  * Тип контента: application/json; charset=UTF-8
  * Расположение: http://localhost:7474/db/data/relationship/1

{
  "расширения": {
  },
  "запустите": "http://localhost:7474/db/data/node/1",
  "свойство": "http://localhost:7474/db/data/relationship/1/properties/ {ключ}",
  "сам": "http://localhost:7474/db/data/relationship/1",
  "свойства": "http://localhost:7474/db/data/relationship/1/properties",
  "введите": "ЛЮБИТ",
  "конец": "http://localhost:7474/db/data/node/0",
  "данные": {
  }
}

19.8.3. Создайте отношение со свойствами

После успешного создания отношения возвращено новое отношение.

Рисунок 19.21. Запуск Графика

Starting-Graph-Add-relationship-with-properties-before.svg


Рисунок 19.22. Конечный График

Final-Graph-Create-a-relationship-with-properties.svg


Запрос в качестве примера

  * POST http://localhost:7474/db/data/node/11/relationships
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "к": "http://localhost:7474/db/data/node/10",
  "введите": "ЛЮБИТ",
  "данные": {
    "foo": "бар"
  }
}

Реакция в качестве примера

  * 201: Создаваемый
  * Тип контента: application/json; charset=UTF-8
  * Расположение: http://localhost:7474/db/data/relationship/8

{
  "расширения": {
  },
  "запустите": "http://localhost:7474/db/data/node/11",
  "свойство": "http://localhost:7474/db/data/relationship/8/properties/ {ключ}",
  "сам": "http://localhost:7474/db/data/relationship/8",
  "свойства": "http://localhost:7474/db/data/relationship/8/properties",
  "введите": "ЛЮБИТ",
  "конец": "http://localhost:7474/db/data/node/10",
  "данные": {
    "foo": "бар"
  }
}

19.8.4. Сотрите отношение

Рисунок 19.23. Запуск Графика

Starting-Graph-Delete-relationship1.svg


Рисунок 19.24. Конечный График

Final-Graph-Delete-relationship.svg


Запрос в качестве примера

  * СТИРАЮТ http://localhost:7474/db/data/relationship/23
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 204: Никакой Контент

19.8.5. Получите все свойства на отношении

Рисунок 19.25. Конечный График

Final-Graph-get-all-properties-on-a-relationship.svg


Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/db/data/relationship/26/properties
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

{
  "стоимость": "высоко",
  "с тех пор": "1 день"
}

19.8.6. Установите все свойства на отношении

Рисунок 19.26. Запуск Графика

Starting-Graph-Set-relationship-property1.svg


Рисунок 19.27. Конечный График

Final-Graph-set-all-properties-on-a-relationship.svg


Запрос в качестве примера

  * ПОМЕЩЕННЫЙ http://localhost:7474/db/data/relationship/31/properties
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "счастливый": ложь
}

Реакция в качестве примера

  * 204: Никакой Контент

19.8.7. Получите единственное свойство на отношении

Рисунок 19.28. Конечный График

Final-Graph-get-single-property-on-a-relationship.svg


Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/db/data/relationship/27/properties/cost
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

"высоко"

19.8.8. Набор единственное свойство на отношении

Рисунок 19.29. Запуск Графика

Starting-Graph-Set-relationship-property1.svg


Рисунок 19.30. Конечный График

Final-Graph-set-single-property-on-a-relationship.svg


Запрос в качестве примера

  * ПОМЕЩЕННЫЙ http://localhost:7474/db/data/relationship/25/properties/cost
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

"смертельно"

Реакция в качестве примера

  * 204: Никакой Контент

19.8.9. Получите все отношения

Рисунок 19.31. Конечный График

Final-Graph-Get-all-relationships.svg


Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/db/data/node/299/relationships/all
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

[{
  "запустите": "http://localhost:7474/db/data/node/299",
  "данные": {
  },
  "сам": "http://localhost:7474/db/data/relationship/205",
  "свойство": "http://localhost:7474/db/data/relationship/205/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/relationship/205/properties",
  "введите": "ЛЮБИТ",
  "расширения": {
  },
  "конец": "http://localhost:7474/db/data/node/300"
}, {
  "запустите": "http://localhost:7474/db/data/node/301",
  "данные": {
  },
  "сам": "http://localhost:7474/db/data/relationship/206",
  "свойство": "http://localhost:7474/db/data/relationship/206/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/relationship/206/properties",
  "введите": "ЛЮБИТ",
  "расширения": {
  },
  "конец": "http://localhost:7474/db/data/node/299"
}, {
  "запустите": "http://localhost:7474/db/data/node/299",
  "данные": {
  },
  "сам": "http://localhost:7474/db/data/relationship/207",
  "свойство": "http://localhost:7474/db/data/relationship/207/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/relationship/207/properties",
  "введите": "НЕНАВИДИТ",
  "расширения": {
  },
  "конец": "http://localhost:7474/db/data/node/302"
} ]

19.8.10. Получите входящие отношения

Рисунок 19.32. Конечный График

Final-Graph-Get-incoming-relationships.svg


Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/db/data/node/318/relationships/in
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

[{
  "запустите": "http://localhost:7474/db/data/node/320",
  "данные": {
  },
  "сам": "http://localhost:7474/db/data/relationship/217",
  "свойство": "http://localhost:7474/db/data/relationship/217/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/relationship/217/properties",
  "введите": "ЛЮБИТ",
  "расширения": {
  },
  "конец": "http://localhost:7474/db/data/node/318"
} ]

19.8.11. Получите исходящие отношения

Рисунок 19.33. Конечный График

Final-Graph-Get-outgoing-relationships.svg


Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/db/data/node/343/relationships/out
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

[{
  "запустите": "http://localhost:7474/db/data/node/343",
  "данные": {
  },
  "сам": "http://localhost:7474/db/data/relationship/231",
  "свойство": "http://localhost:7474/db/data/relationship/231/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/relationship/231/properties",
  "введите": "ЛЮБИТ",
  "расширения": {
  },
  "конец": "http://localhost:7474/db/data/node/344"
}, {
  "запустите": "http://localhost:7474/db/data/node/343",
  "данные": {
  },
  "сам": "http://localhost:7474/db/data/relationship/233",
  "свойство": "http://localhost:7474/db/data/relationship/233/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/relationship/233/properties",
  "введите": "НЕНАВИДИТ",
  "расширения": {
  },
  "конец": "http://localhost:7474/db/data/node/346"
} ]

19.8.12. Получите введенные отношения

Заметьте, что "&" должен быть закодирован как "%26" например при использовании ЗАВИХРЕНИЯ
<http://curl.haxx.se/> от терминала.

Рисунок 19.34. Конечный График

Final-Graph-Get-typed-relationships.svg


Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/db/data/node/274/relationships/all/LIKES&HATES
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

[{
  "запустите": "http://localhost:7474/db/data/node/274",
  "данные": {
  },
  "сам": "http://localhost:7474/db/data/relationship/190",
  "свойство": "http://localhost:7474/db/data/relationship/190/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/relationship/190/properties",
  "введите": "ЛЮБИТ",
  "расширения": {
  },
  "конец": "http://localhost:7474/db/data/node/275"
}, {
  "запустите": "http://localhost:7474/db/data/node/276",
  "данные": {
  },
  "сам": "http://localhost:7474/db/data/relationship/191",
  "свойство": "http://localhost:7474/db/data/relationship/191/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/relationship/191/properties",
  "введите": "ЛЮБИТ",
  "расширения": {
  },
  "конец": "http://localhost:7474/db/data/node/274"
}, {
  "запустите": "http://localhost:7474/db/data/node/274",
  "данные": {
  },
  "сам": "http://localhost:7474/db/data/relationship/192",
  "свойство": "http://localhost:7474/db/data/relationship/192/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/relationship/192/properties",
  "введите": "НЕНАВИДИТ",
  "расширения": {
  },
  "конец": "http://localhost:7474/db/data/node/277"
} ]

19.8.13. Получите отношения на вершине без отношений

Рисунок 19.35. Конечный График

Final-Graph-Get-relationships-on-a-node-without-relationships.svg


Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/db/data/node/332/relationships/all
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

[]

19.9. Типы отношения

19.9.1. Получите типы отношения

19.9.1. Получите типы отношения

Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/db/data/relationship/types
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json

["знайте", "ЗНАЕТ", "ЛЮБИТ"]

19.10. Свойства вершины

19.10.1. Свойство набора на вершине
19.10.2. Свойства вершины обновления
19.10.3. Получите свойства для вершины
19.10.4. Значения свойств не могут быть нулем
19.10.5. Значения свойств не могут быть вложены
19.10.6. Сотрите все свойства из вершины
19.10.7. Сотрите именованное свойство из вершины

19.10.1. Свойство набора на вершине

Установка различных свойств сохранит существующие для этой вершины. Замечание
то, что единственное значение представлено не как карта, но так же, как значение (который является
допустимый ДЖСОН) как в примере ниже.

Рисунок 19.36. Конечный График

Final-Graph-Set-property-on-node.svg


Запрос в качестве примера

  * ПОМЕЩЕННЫЙ http://localhost:7474/db/data/node/11/properties/foo
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

"бар"

Реакция в качестве примера

  * 204: Никакой Контент

19.10.2. Свойства вершины обновления

Это заменит все существующие свойства на вершине с новым набором
атрибуты.

Рисунок 19.37. Конечный График

Final-Graph-Update-node-properties.svg


Запрос в качестве примера

  * ПОМЕЩЕННЫЙ http://localhost:7474/db/data/node/9/properties
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "возраст": "18"
}

Реакция в качестве примера

  * 204: Никакой Контент

19.10.3. Получите свойства для вершины

Рисунок 19.38. Конечный График

Final-Graph-Get-properties-for-node.svg


Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/db/data/node/36/properties
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

{
  "foo": "бар"
}

19.10.4. Значения свойств не могут быть нулем

Этот пример показывает реакцию, которую Вы получаете, пытаясь установить свойство в NULL.

Запрос в качестве примера

  * POST http://localhost:7474/db/data/node
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "foo": нуль
}

Реакция в качестве примера

  * 400: Плохой Запрос
  * Тип контента: application/json; charset=UTF-8

{
  "сообщение": "Не мог установить свойство \"foo \", незакрепленный тип: нуль",
  "исключение": "PropertyValueException",
  "fullname": "org.neo4j.server.rest.web.PropertyValueException",
  "stacktrace": [
    "org.neo4j.server.rest.domain.PropertySettingStrategy.setProperty (PropertySettingStrategy.java:141)",
    "org.neo4j.server.rest.domain.PropertySettingStrategy.setProperties (PropertySettingStrategy.java:88)",
    "org.neo4j.server.rest.web.DatabaseActions.createNode (DatabaseActions.java:214)",
    "org.neo4j.server.rest.web.RestfulGraphDatabase.createNode (RestfulGraphDatabase.java:239)",
    "java.lang.reflect. Method.invoke (Метод java:606)",
    "org.neo4j.server.rest.transactional.TransactionalRequestDispatcher.dispatch (TransactionalRequestDispatcher.java:132)",
    "org.neo4j.server.rest.security.SecurityFilter.doFilter (SecurityFilter.java:112)",
    "java.lang. Thread.run (Поток java:724)"
  ]
}

19.10.5. Значения свойств не могут быть вложены

Свойства вложения не поддерживаются. Вы могли например сохранить вложенный
ДЖСОН как строка вместо этого.

Запрос в качестве примера

  * POST http://localhost:7474/db/data/node/
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "foo": {
    "бар": "baz"
  }
}

Реакция в качестве примера

  * 400: Плохой Запрос
  * Тип контента: application/json; charset=UTF-8

{
  "сообщение": "Не мог установить свойство \"foo \", незакрепленный тип: {bar\u003dbaz}",
  "исключение": "PropertyValueException",
  "fullname": "org.neo4j.server.rest.web.PropertyValueException",
  "stacktrace": [
    "org.neo4j.server.rest.domain.PropertySettingStrategy.setProperty (PropertySettingStrategy.java:141)",
    "org.neo4j.server.rest.domain.PropertySettingStrategy.setProperties (PropertySettingStrategy.java:88)",
    "org.neo4j.server.rest.web.DatabaseActions.createNode (DatabaseActions.java:214)",
    "org.neo4j.server.rest.web.RestfulGraphDatabase.createNode (RestfulGraphDatabase.java:239)",
    "java.lang.reflect. Method.invoke (Метод java:606)",
    "org.neo4j.server.rest.transactional.TransactionalRequestDispatcher.dispatch (TransactionalRequestDispatcher.java:132)",
    "org.neo4j.server.rest.security.SecurityFilter.doFilter (SecurityFilter.java:112)",
    "java.lang. Thread.run (Поток java:724)"
  ]
}

19.10.6. Сотрите все свойства из вершины

Рисунок 19.39. Конечный График

Final-Graph-Delete-all-properties-from-node.svg


Запрос в качестве примера

  * СТИРАЮТ http://localhost:7474/db/data/node/251/properties
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 204: Никакой Контент

19.10.7. Сотрите именованное свойство из вершины

Чтобы стереть единственное свойство из вершины, см. пример ниже.

Рисунок 19.40. Запуск Графика

Starting-Graph-delete-named-property-start.svg


Рисунок 19.41. Конечный График

Final-Graph-delete-a-named-property-from-a-node.svg


Запрос в качестве примера

  * СТИРАЮТ http://localhost:7474/db/data/node/250/properties/name
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 204: Никакой Контент

19.11. Свойства отношения

19.11.1. Свойства отношения обновления
19.11.2. Свойства перемещения от отношения
19.11.3. Свойство перемещения от отношения
19.11.4. Переместите несуществующее свойство от отношения
19.11.5. Свойства перемещения от несуществующего отношения
19.11.6. Свойство перемещения от несуществующего отношения

19.11.1. Свойства отношения обновления

Рисунок 19.42. Конечный График

Final-Graph-Update-relationship-properties.svg


Запрос в качестве примера

  * ПОМЕЩЕННЫЙ http://localhost:7474/db/data/relationship/9/properties
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "jim": "tobias"
}

Реакция в качестве примера

  * 204: Никакой Контент

19.11.2. Свойства перемещения от отношения

Рисунок 19.43. Конечный График

Final-Graph-Remove-properties-from-a-relationship.svg


Запрос в качестве примера

  * СТИРАЮТ http://localhost:7474/db/data/relationship/21/properties
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 204: Никакой Контент

19.11.3. Свойство перемещения от отношения

См. запрос в качестве примера ниже.

Рисунок 19.44. Запуск Графика

Starting-Graph-Remove-property-from-a-relationship1.svg


Рисунок 19.45. Конечный График

Final-Graph-Remove-property-from-a-relationship.svg


Запрос в качестве примера

  * СТИРАЮТ http://localhost:7474/db/data/relationship/24/properties/cost
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 204: Никакой Контент

19.11.4. Переместите несуществующее свойство от отношения

Попытка переместить свойство, которое не существует результаты в погрешности.

Рисунок 19.46. Конечный График

Final-Graph-Remove-non-existent-property-from-a-relationship.svg


Запрос в качестве примера

  * СТИРАЮТ http://localhost:7474/db/data/relationship/22/properties/
    несуществующий
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 404: Не Найденный
  * Тип контента: application/json; charset=UTF-8

{
  "сообщение": "У отношения [22] нет свойства \"несуществующим \"",
  "исключение": "NoSuchPropertyException",
  "fullname": "org.neo4j.server.rest.web.NoSuchPropertyException",
  "stacktrace": [
    "org.neo4j.server.rest.web.DatabaseActions.removeRelationshipProperty (DatabaseActions.java:657)",
    "org.neo4j.server.rest.web.RestfulGraphDatabase.deleteRelationshipProperty (RestfulGraphDatabase.java:790)",
    "java.lang.reflect. Method.invoke (Метод java:606)",
    "org.neo4j.server.rest.transactional.TransactionalRequestDispatcher.dispatch (TransactionalRequestDispatcher.java:132)",
    "org.neo4j.server.rest.security.SecurityFilter.doFilter (SecurityFilter.java:112)",
    "java.lang. Thread.run (Поток java:724)"
  ]
}

19.11.5. Свойства перемещения от несуществующего отношения

Попытка переместить все свойства от отношения, которое не существует
результаты в погрешности.

Рисунок 19.47. Конечный График

Final-Graph-Remove-properties-from-a-non-existing-relationship.svg


Запрос в качестве примера

  * СТИРАЮТ http://localhost:7474/db/data/relationship/1234/properties
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 404: Не Найденный
  * Тип контента: application/json; charset=UTF-8

{
  "исключение": "RelationshipNotFoundException",
  "fullname": "org.neo4j.server.rest.web.RelationshipNotFoundException",
  "stacktrace": [
    "org.neo4j.server.rest.web.DatabaseActions.relationship (DatabaseActions.java:197)",
    "org.neo4j.server.rest.web.DatabaseActions.removeAllRelationshipProperties (DatabaseActions.java:647)",
    "org.neo4j.server.rest.web.RestfulGraphDatabase.deleteAllRelationshipProperties (RestfulGraphDatabase.java:769)",
    "java.lang.reflect. Method.invoke (Метод java:606)",
    "org.neo4j.server.rest.transactional.TransactionalRequestDispatcher.dispatch (TransactionalRequestDispatcher.java:132)",
    "org.neo4j.server.rest.security.SecurityFilter.doFilter (SecurityFilter.java:112)",
    "java.lang. Thread.run (Поток java:724)"
  ]
}

19.11.6. Свойство перемещения от несуществующего отношения

Попытка переместить свойство от отношения, которое не существует результаты
в погрешности.

Рисунок 19.48. Конечный График

Final-Graph-Remove-property-from-a-non-existing-relationship.svg


Запрос в качестве примера

  * СТИРАЮТ http://localhost:7474/db/data/relationship/1234/properties/cost
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 404: Не Найденный
  * Тип контента: application/json; charset=UTF-8

{
  "исключение": "RelationshipNotFoundException",
  "fullname": "org.neo4j.server.rest.web.RelationshipNotFoundException",
  "stacktrace": [
    "org.neo4j.server.rest.web.DatabaseActions.relationship (DatabaseActions.java:197)",
    "org.neo4j.server.rest.web.DatabaseActions.removeRelationshipProperty (DatabaseActions.java:653)",
    "org.neo4j.server.rest.web.RestfulGraphDatabase.deleteRelationshipProperty (RestfulGraphDatabase.java:790)",
    "java.lang.reflect. Method.invoke (Метод java:606)",
    "org.neo4j.server.rest.transactional.TransactionalRequestDispatcher.dispatch (TransactionalRequestDispatcher.java:132)",
    "org.neo4j.server.rest.security.SecurityFilter.doFilter (SecurityFilter.java:112)",
    "java.lang. Thread.run (Поток java:724)"
  ]
}

19.12. Метки вершины

19.12.1. Добавление метки к вершине
19.12.2. Добавление разнообразных меток к вершине
19.12.3. Добавление метки с недопустимым именем
19.12.4. Замена меток на вершине
19.12.5. Передвижение метки от вершины
19.12.6. Перечисление меток для вершины
19.12.7. Получите все вершины с меткой
19.12.8. Получите вершины меткой и свойством
19.12.9. Перечислите все метки

19.12.1. Добавление метки к вершине

Рисунок 19.49. Конечный График

Final-Graph-Adding-a-label-to-a-node.svg


Запрос в качестве примера

  * POST http://localhost:7474/db/data/node/101/labels
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

"Человек"

Реакция в качестве примера

  * 204: Никакой Контент

19.12.2. Добавление разнообразных меток к вершине

Рисунок 19.50. Конечный График

Final-Graph-Adding-multiple-labels-to-a-node.svg


Запрос в качестве примера

  * POST http://localhost:7474/db/data/node/112/labels
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

["Человек", "Агент"]

Реакция в качестве примера

  * 204: Никакой Контент

19.12.3. Добавление метки с недопустимым именем

Метки с пустыми названиями не позволены, однако, все другие допустимые строки
принятый как имена метки. Добавление недопустимой метки к вершине приведет к HTTP
400 реакций.

Рисунок 19.51. Конечный График

Final-Graph-Adding-a-label-with-an-invalid-name.svg


Запрос в качестве примера

  * POST http://localhost:7474/db/data/node/119/labels
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

""

Реакция в качестве примера

  * 400: Плохой Запрос
  * Тип контента: application/json; charset=UTF-8

{
  "сообщение": "Неспособный прибавить метку, см. вложенное исключение.",
  "исключение": "BadInputException",
  "fullname": "org.neo4j.server.rest.repr.BadInputException",
  "stacktrace": [
    "org.neo4j.server.rest.web.DatabaseActions.addLabelToNode (DatabaseActions.java:328)",
    "org.neo4j.server.rest.web.RestfulGraphDatabase.addNodeLabel (RestfulGraphDatabase.java:440)",
    "java.lang.reflect. Method.invoke (Метод java:606)",
    "org.neo4j.server.rest.transactional.TransactionalRequestDispatcher.dispatch (TransactionalRequestDispatcher.java:132)",
    "org.neo4j.server.rest.security.SecurityFilter.doFilter (SecurityFilter.java:112)",
    "java.lang. Thread.run (Поток java:724)"
  ],
  "причина": {
    "сообщение": "Недопустимое имя \u0027\u0027 метки.",
    "причина": {
      "сообщение": "\u0027\u0027 не допустимое маркерное имя. Только ненуль, непустые строки позволены.",
      "исключение": "IllegalTokenNameException",
      "stacktrace": [
        "org.neo4j.kernel.impl.api.DataIntegrityValidatingStatementOperations.checkValidTokenName (DataIntegrityValidatingStatementOperations.java:171)",
        "org.neo4j.kernel.impl.api.DataIntegrityValidatingStatementOperations.labelGetOrCreateForName (DataIntegrityValidatingStatementOperations.java:82)",
        "org.neo4j.kernel.impl.api.OperationsFacade.labelGetOrCreateForName (OperationsFacade.java:390)",
        "org.neo4j.kernel.impl.core.NodeProxy.addLabel (NodeProxy.java:472)",
        "org.neo4j.server.rest.web.DatabaseActions.addLabelToNode (DatabaseActions.java:323)",
        "org.neo4j.server.rest.web.RestfulGraphDatabase.addNodeLabel (RestfulGraphDatabase.java:440)",
        "java.lang.reflect. Method.invoke (Метод java:606)",
        "org.neo4j.server.rest.transactional.TransactionalRequestDispatcher.dispatch (TransactionalRequestDispatcher.java:132)",
        "org.neo4j.server.rest.security.SecurityFilter.doFilter (SecurityFilter.java:112)",
        "java.lang. Thread.run (Поток java:724)"
      ],
      "fullname": "org.neo4j.kernel.api.exceptions.schema.IllegalTokenNameException"
    },
    "исключение": "ConstraintViolationException",
    "stacktrace": [
      "org.neo4j.kernel.impl.core.NodeProxy.addLabel (NodeProxy.java:481)",
      "org.neo4j.server.rest.web.DatabaseActions.addLabelToNode (DatabaseActions.java:323)",
      "org.neo4j.server.rest.web.RestfulGraphDatabase.addNodeLabel (RestfulGraphDatabase.java:440)",
      "java.lang.reflect. Method.invoke (Метод java:606)",
      "org.neo4j.server.rest.transactional.TransactionalRequestDispatcher.dispatch (TransactionalRequestDispatcher.java:132)",
      "org.neo4j.server.rest.security.SecurityFilter.doFilter (SecurityFilter.java:112)",
      "java.lang. Thread.run (Поток java:724)"
    ],
    "fullname": "org.neo4j.graphdb.ConstraintViolationException"
  }
}

19.12.4. Замена меток на вершине

Это перемещает любые метки в настоящий момент на вершине, и заменяет их метками
переданный в как корпус запроса.

Рисунок 19.52. Конечный График

Final-Graph-Replacing-labels-on-a-node.svg


Запрос в качестве примера

  * ПОМЕЩЕННЫЙ http://localhost:7474/db/data/node/102/labels
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

["Агент", "Направляющее устройство"]

Реакция в качестве примера

  * 204: Никакой Контент

19.12.5. Передвижение метки от вершины

Рисунок 19.53. Конечный График

Final-Graph-Removing-a-label-from-a-node.svg


Запрос в качестве примера

  * СТИРАЮТ http://localhost:7474/db/data/node/103/labels/Person
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 204: Никакой Контент

19.12.6. Перечисление меток для вершины

Рисунок 19.54. Конечный График

Final-Graph-Listing-labels-for-a-node.svg


Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/db/data/node/108/labels
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

["Направляющее устройство", "Агент"]

19.12.7. Получите все вершины с меткой

Рисунок 19.55. Конечный График

Final-Graph-Get-all-nodes-with-a-label.svg


Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/db/data/label/Actor/nodes
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

[{
  "outgoing_relationships": "http://localhost:7474/db/data/node/114/relationships/out",
  "метки": "http://localhost:7474/db/data/node/114/labels",
  "данные": {
    "имя": "Клинт Иствуд"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/114/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/114/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/114",
  "свойство": "http://localhost:7474/db/data/node/114/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/114/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/114/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/114/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/114/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/114/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/114/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/114/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/115/relationships/out",
  "метки": "http://localhost:7474/db/data/node/115/labels",
  "данные": {
    "имя": "Дональд Сазерленд"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/115/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/115/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/115",
  "свойство": "http://localhost:7474/db/data/node/115/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/115/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/115/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/115/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/115/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/115/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/115/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/115/relationships/in/ {-list|&|types}"
} ]

19.12.8. Получите вершины меткой и свойством

Вы можете получить все вершины с данной меткой и свойством, передавая один
свойство как параметр запроса. Заметьте, что значение свойства JSON-закодировано
и затем закодированный URL.

Если есть индексирование доступного на комбинации метки/свойства, Вы передаетесь, это
индексируйте будет использоваться. Если не индексируют, доступно, все вершины с данной меткой
проникнется, чтобы обнаружить соответствие вершин.

В настоящий момент, не возможно искать использующие разнообразные свойства.

Рисунок 19.56. Конечный График

Final-Graph-Get-nodes-by-label-and-property.svg


Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/db/data/label/Person/nodes?name=
    %22Clint+Eastwood%22
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

[{
  "outgoing_relationships": "http://localhost:7474/db/data/node/117/relationships/out",
  "метки": "http://localhost:7474/db/data/node/117/labels",
  "данные": {
    "имя": "Клинт Иствуд"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/117/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/117/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/117",
  "свойство": "http://localhost:7474/db/data/node/117/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/117/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/117/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/117/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/117/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/117/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/117/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/117/relationships/in/ {-list|&|types}"
} ]

19.12.9. Перечислите все метки

Рисунок 19.57. Конечный График

Final-Graph-List-all-labels.svg


Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/db/data/labels
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

["Агент", "mylabel", "новичок", "эксперт", "человек", "SomeLabel", "кодер", "Человек", "пользователь", "повар", "Направляющее устройство"]

19.13. Индексация

19.13.1. Создайте индексируют
19.13.2. Список индексирует для метки
19.13.3. Отбрасывание индексирует

Замечание

Эта базируемая схема документов индексирует, функция, которая была представлена в Neo4j
2.0, см. Раздел 19.18, “Индексация наследства” для индексации наследства.

Для получения дополнительной информации об индексирует и дополнительная схема в Neo4j, см.
Раздел 3.7, "Схема".

19.13.1. Создайте индексируют

Это запустит низкоприоритетное задание в базе данных, которая создаст и заполнит
индексирование. Вы можете проверить состояние Вашего индексировать, перечисляя все индексирование
для соответствующей метки. Создаваемые индексируют, обнаружится, но иметь состояние
ЗАПОЛНЯЯ, пока индексирование не готово, где оно отмечено как ОНЛАЙНОВОЕ.

Запрос в качестве примера

  * POST http://localhost:7474/db/data/schema/index/person
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "property_keys": ["имя"]
}

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

{
  "метка": "человек",
  "property_keys": ["имя"]
}

19.13.2. Список индексирует для метки

Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/db/data/schema/index/user
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

[{
  "property_keys": ["имя"],
  "метка": "пользователь"
} ]

19.13.3. Отбрасывание индексирует

Отбрасывание индексирует

Запрос в качестве примера

  * СТИРАЮТ http://localhost:7474/db/data/schema/index/SomeLabel/name
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 204: Никакой Контент

19.14. Ограничения

19.14.1. Создайте ограничение уникальности
19.14.2. Получите определенное ограничение уникальности
19.14.3. Получите все ограничения уникальности для метки
19.14.4. Получите все ограничения для метки
19.14.5. Получите все ограничения
19.14.6. Ограничение отбрасывания

19.14.1. Создайте ограничение уникальности

Создайте ограничение уникальности на свойство.

Запрос в качестве примера

  * POST http://localhost:7474/db/data/schema/constraint/person/uniqueness/
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "property_keys": ["имя"]
}

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

{
  "метка": "человек",
  "введите": "УНИКАЛЬНОСТЬ",
  "property_keys": ["имя"]
}

19.14.2. Получите определенное ограничение уникальности

Получите определенное ограничение уникальности для метки и свойства.

Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/db/data/schema/constraint/user/uniqueness/name
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

[{
  "property_keys": ["имя"],
  "метка": "пользователь",
  "введите": "УНИКАЛЬНОСТЬ"
} ]

19.14.3. Получите все ограничения уникальности для метки

Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/db/data/schema/constraint/user/uniqueness/
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

[{
  "property_keys": ["name2"],
  "метка": "пользователь",
  "введите": "УНИКАЛЬНОСТЬ"
}, {
  "property_keys": ["name1"],
  "метка": "пользователь",
  "введите": "УНИКАЛЬНОСТЬ"
} ]

19.14.4. Получите все ограничения для метки

Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/db/data/schema/constraint/user
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

[{
  "property_keys": ["name2"],
  "метка": "пользователь",
  "введите": "УНИКАЛЬНОСТЬ"
}, {
  "property_keys": ["name1"],
  "метка": "пользователь",
  "введите": "УНИКАЛЬНОСТЬ"
} ]

19.14.5. Получите все ограничения

Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/db/data/schema/constraint/
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

[{
  "property_keys": ["name2"],
  "метка": "прогр",
  "введите": "УНИКАЛЬНОСТЬ"
}, {
  "property_keys": ["name1"],
  "метка": "пользователь",
  "введите": "УНИКАЛЬНОСТЬ"
} ]

19.14.6. Ограничение отбрасывания

Ограничение уникальности отбрасывания для метки и свойства.

Запрос в качестве примера

  * СТИРАЮТ http://localhost:7474/db/data/schema/constraint/SomeLabel/uniqueness
    / имя
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 204: Никакой Контент

19.15. Обходы

19.15.1. Обход используя фильтр возврата
19.15.2. Возвратите отношения из обхода
19.15.3. Обратные пути от обхода
19.15.4. Вершины возврата обхода ниже определенной глубины
19.15.5. Создание нумерованной страницу траверсы
19.15.6. Оповещение через результаты нумерованной страницу траверсы
19.15.7. Нумерованный страницу размер страницы траверсы
19.15.8. Нумерованный страницу тайм-аут траверсы

Предупреждение

Конечная точка REST Обхода выполняет произвольный код Javascript под кожухом
как часть определений средств анализа. В размещенных и открытых средах, этом
может составить угрозу безопасности. В них заключают в корпус, рассматривают использование описания
подходам нравится Часть III, “Язык Запроса Кода” или пишет Вашу собственную сторону сервера
плагин, выполняющий интересные обходы с API Java (см.
Раздел 31.1, “Плагины Сервера”) или безопасный Ваш сервер, видят Главу 25,
Безопасность.

Обходы выполняются от вершины запуска. Обходом управляют
URI и корпус передались с запросом.

returnType

    Вид объектов в реакции определен траверзом / {returnType}
    в URL. у returnType может быть одно из этих значений:

      * вершина
      * отношение
      * путь: содержит полные представления запуска и конечного узла, остальные
        URI.
      * fullpath: содержит полные представления всех вершин и отношений.

Чтобы решить, как график должен быть пересечен, Вы можете использовать эти параметры в
корпус запроса:

порядок

    Решает в который порядок посетить вершины. Возможные значения:

      * breadth_first: см. Поиск типа "сначала вширь" <http://en.wikipedia.org/wiki/
        Ширина-first_search>.
      * depth_first: см. поиск В глубину <http://en.wikipedia.org/wiki/
        Глубина-first_search>
отношения

    Решает, какие типы отношения и направления должны сопровождаться.
    направление может быть одним из:

      * все
      * в
      *
уникальность

    Решает, как уникальность должна быть вычислена. Для получения дополнительной информации на различном
    значения уникальности видят API Java на Уникальности <http://
    components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/kernel/Uniqueness.html>.
    Возможные значения:

      * node_global
      * ни один
      * relationship_global
      * node_path
      * relationship_path
prune_evaluator
    Решает, должна ли траверса продолжаться вниз что путь или если это
    должен быть подрезан так, чтобы траверса не продолжала вниз тот путь. Вы
    может записать Ваше собственное средство анализа сливы как (см. Раздел 19.15.1, “Обход
    использование возврата фильтрует” или использует встроенное, ни один не подрезает средство анализа.
return_filter

    Решает, должна ли текущая позиция быть включена в результат. Вы
    может обеспечить Ваш собственный код для этого (см. Раздел 19.15.1, “Обход, используя a
    возвратите фильтр”), или используйте один из встроенных фильтров:

      * все
      * all_but_start_node
max_depth
    Краткий способ определить средство анализа сливы, которое подрезает после a
    определенная глубина. Если не определенный максимальная глубина 1 используется и если a
    prune_evaluator определен вместо max_depth, никакой максимальный предел глубины не
    набор.

Объект позиции в корпусе return_filter и prune_evaluator - a
Путь <http://components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/graphdb/
Path.html> объект, представляющий путь от вершины запуска до тока
позиция обхода.

Из поля остальные API поддерживает код JavaScript в фильтрах и
средства анализа. Корпус сценария будет выполняться в контексте Java, у которого есть доступ
в полной мере API Java Neo4j <http://components.neo4j.org/neo4j/2.0.0/apidocs/>.
См. примеры для точного синтаксиса запроса.

19.15.1. Обход используя фильтр возврата

В этом примере используется средство анализа сливы ни одного, и фильтр возврата
предоставленный, чтобы возвратить все имена, делящиеся без остатка "t". Результат должен быть
возвращенный как вершины и максимальная глубина установлен в 3.

Рисунок 19.58. Конечный График

Final-Graph-Traversal-using-a-return-filter.svg


Запрос в качестве примера

  * POST http://localhost:7474/db/data/node/375/traverse/node
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "порядок": "breadth_first",
  "return_filter": {
    "корпус": "position.endNode ().getProperty ('имя').toLowerCase ().contains ('t')",
    "язык": "javascript"
  },
  "prune_evaluator": {
    "корпус": "position.length ()> 10",
    "язык": "javascript"
  },
  "уникальность": "node_global",
  "отношения": [{
    "направление": "все",
    "введите": "знает"
  }, {
    "направление": "все",
    "введите": "любит"
  } ],
  "max_depth": 3
}

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

[{
  "outgoing_relationships": "http://localhost:7474/db/data/node/375/relationships/out",
  "метки": "http://localhost:7474/db/data/node/375/labels",
  "данные": {
    "имя": "Корень"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/375/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/375/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/375",
  "свойство": "http://localhost:7474/db/data/node/375/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/375/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/375/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/375/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/375/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/375/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/375/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/375/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/378/relationships/out",
  "метки": "http://localhost:7474/db/data/node/378/labels",
  "данные": {
    "имя": "Маттиас"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/378/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/378/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/378",
  "свойство": "http://localhost:7474/db/data/node/378/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/378/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/378/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/378/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/378/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/378/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/378/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/378/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/377/relationships/out",
  "метки": "http://localhost:7474/db/data/node/377/labels",
  "данные": {
    "имя": "Питер"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/377/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/377/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/377",
  "свойство": "http://localhost:7474/db/data/node/377/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/377/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/377/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/377/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/377/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/377/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/377/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/377/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/376/relationships/out",
  "метки": "http://localhost:7474/db/data/node/376/labels",
  "данные": {
    "имя": "Тобиас"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/376/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/376/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/376",
  "свойство": "http://localhost:7474/db/data/node/376/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/376/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/376/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/376/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/376/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/376/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/376/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/376/relationships/in/ {-list|&|types}"
} ]

19.15.2. Возвратите отношения из обхода

Рисунок 19.59. Конечный График

Final-Graph-return-relationships-from-a-traversal.svg


Запрос в качестве примера

  * POST http://localhost:7474/db/data/node/369/traverse/relationship
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "порядок": "breadth_first",
  "уникальность": "ни один",
  "return_filter": {
    "язык": "встроенный",
    "имя": "все"
  }
}

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

[{
  "запустите": "http://localhost:7474/db/data/node/369",
  "данные": {
  },
  "сам": "http://localhost:7474/db/data/relationship/250",
  "свойство": "http://localhost:7474/db/data/relationship/250/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/relationship/250/properties",
  "введите": "знайте",
  "расширения": {
  },
  "конец": "http://localhost:7474/db/data/node/368"
}, {
  "запустите": "http://localhost:7474/db/data/node/369",
  "данные": {
  },
  "сам": "http://localhost:7474/db/data/relationship/251",
  "свойство": "http://localhost:7474/db/data/relationship/251/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/relationship/251/properties",
  "введите": "собственный",
  "расширения": {
  },
  "конец": "http://localhost:7474/db/data/node/367"
} ]

19.15.3. Обратные пути от обхода

Рисунок 19.60. Конечный График

Final-Graph-return-paths-from-a-traversal.svg


Запрос в качестве примера

  * POST http://localhost:7474/db/data/node/359/traverse/path
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "порядок": "breadth_first",
  "уникальность": "ни один",
  "return_filter": {
    "язык": "встроенный",
    "имя": "все"
  }
}

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

[{
  "запустите": "http://localhost:7474/db/data/node/359",
  "вершины": ["http://localhost:7474/db/data/node/359"],
  "длина": 0,
  "отношения": [],
  "конец": "http://localhost:7474/db/data/node/359"
}, {
  "запустите": "http://localhost:7474/db/data/node/359",
  "вершины": ["http://localhost:7474/db/data/node/359", "http://localhost:7474/db/data/node/358"],
  "длина": 1,
  "отношения": ["http://localhost:7474/db/data/relationship/242"],
  "конец": "http://localhost:7474/db/data/node/358"
}, {
  "запустите": "http://localhost:7474/db/data/node/359",
  "вершины": ["http://localhost:7474/db/data/node/359", "http://localhost:7474/db/data/node/357"],
  "длина": 1,
  "отношения": ["http://localhost:7474/db/data/relationship/243"],
  "конец": "http://localhost:7474/db/data/node/357"
} ]

19.15.4. Вершины возврата обхода ниже определенной глубины

Здесь, все вершины в глубине обхода ниже 3 возвращены.

Рисунок 19.61. Конечный График

Final-Graph-Traversal-returning-nodes-below-a-certain-depth.svg


Запрос в качестве примера

  * POST http://localhost:7474/db/data/node/363/traverse/node
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "return_filter": {
    "корпус": "position.length () <3;",
    "язык": "javascript"
  },
  "prune_evaluator": {
    "имя": "ни один",
    "язык": "встроенный"
  }
}

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

[{
  "outgoing_relationships": "http://localhost:7474/db/data/node/363/relationships/out",
  "метки": "http://localhost:7474/db/data/node/363/labels",
  "данные": {
    "имя": "Корень"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/363/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/363/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/363",
  "свойство": "http://localhost:7474/db/data/node/363/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/363/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/363/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/363/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/363/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/363/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/363/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/363/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/366/relationships/out",
  "метки": "http://localhost:7474/db/data/node/366/labels",
  "данные": {
    "имя": "Маттиас"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/366/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/366/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/366",
  "свойство": "http://localhost:7474/db/data/node/366/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/366/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/366/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/366/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/366/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/366/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/366/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/366/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/361/relationships/out",
  "метки": "http://localhost:7474/db/data/node/361/labels",
  "данные": {
    "имя": "Йохан"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/361/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/361/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/361",
  "свойство": "http://localhost:7474/db/data/node/361/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/361/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/361/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/361/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/361/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/361/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/361/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/361/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/362/relationships/out",
  "метки": "http://localhost:7474/db/data/node/362/labels",
  "данные": {
    "имя": "Эмиль"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/362/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/362/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/362",
  "свойство": "http://localhost:7474/db/data/node/362/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/362/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/362/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/362/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/362/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/362/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/362/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/362/relationships/in/ {-list|&|types}"
} ]

19.15.5. Создание нумерованной страницу траверсы

Нумерованные страницу траверсы создаются, ОТПРАВЛЯЯ описание обхода на ссылку
идентифицированный paged_traverser вводят представление вершины. Создавая a
нумерованная страницу траверса, те же самые опции применяются что касается регулярной траверсы, означая
та вершина, путь, или fullpath, может быть предназначена.

Запрос в качестве примера

  * POST http://localhost:7474/db/data/node/297/paged/traverse/node
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "prune_evaluator": {
    "язык": "встроенный",
    "имя": "ни один"
  },
  "return_filter": {
    "язык": "javascript",
    "корпус": "position.endNode ().getProperty ('имя').contains ('1');"
  },
  "порядок": "depth_first",
  "отношения": {
    "введите": "NEXT",
    "направление":
  }
}

Реакция в качестве примера

  * 201: Создаваемый
  * Тип контента: application/json; charset=UTF-8
  * Расположение: http://localhost:7474/db/data/node/297/paged/traverse/node/
    ab3224c783f24e1fb77789e0c89ba641

[{
  "outgoing_relationships": "http://localhost:7474/db/data/node/298/relationships/out",
  "метки": "http://localhost:7474/db/data/node/298/labels",
  "данные": {
    "имя": "1"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/298/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/298/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/298",
  "свойство": "http://localhost:7474/db/data/node/298/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/298/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/298/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/298/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/298/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/298/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/298/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/298/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/307/relationships/out",
  "метки": "http://localhost:7474/db/data/node/307/labels",
  "данные": {
    "имя": "10"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/307/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/307/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/307",
  "свойство": "http://localhost:7474/db/data/node/307/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/307/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/307/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/307/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/307/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/307/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/307/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/307/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/308/relationships/out",
  "метки": "http://localhost:7474/db/data/node/308/labels",
  "данные": {
    "имя": "11"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/308/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/308/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/308",
  "свойство": "http://localhost:7474/db/data/node/308/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/308/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/308/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/308/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/308/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/308/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/308/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/308/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/309/relationships/out",
  "метки": "http://localhost:7474/db/data/node/309/labels",
  "данные": {
    "имя": "12"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/309/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/309/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/309",
  "свойство": "http://localhost:7474/db/data/node/309/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/309/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/309/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/309/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/309/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/309/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/309/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/309/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/310/relationships/out",
  "метки": "http://localhost:7474/db/data/node/310/labels",
  "данные": {
    "имя": "13"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/310/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/310/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/310",
  "свойство": "http://localhost:7474/db/data/node/310/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/310/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/310/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/310/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/310/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/310/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/310/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/310/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/311/relationships/out",
  "метки": "http://localhost:7474/db/data/node/311/labels",
  "данные": {
    "имя": "14"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/311/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/311/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/311",
  "свойство": "http://localhost:7474/db/data/node/311/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/311/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/311/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/311/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/311/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/311/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/311/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/311/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/312/relationships/out",
  "метки": "http://localhost:7474/db/data/node/312/labels",
  "данные": {
    "имя": "15"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/312/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/312/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/312",
  "свойство": "http://localhost:7474/db/data/node/312/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/312/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/312/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/312/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/312/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/312/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/312/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/312/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/313/relationships/out",
  "метки": "http://localhost:7474/db/data/node/313/labels",
  "данные": {
    "имя": "16"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/313/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/313/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/313",
  "свойство": "http://localhost:7474/db/data/node/313/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/313/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/313/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/313/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/313/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/313/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/313/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/313/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/314/relationships/out",
  "метки": "http://localhost:7474/db/data/node/314/labels",
  "данные": {
    "имя": "17"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/314/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/314/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/314",
  "свойство": "http://localhost:7474/db/data/node/314/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/314/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/314/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/314/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/314/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/314/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/314/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/314/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/315/relationships/out",
  "метки": "http://localhost:7474/db/data/node/315/labels",
  "данные": {
    "имя": "18"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/315/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/315/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/315",
  "свойство": "http://localhost:7474/db/data/node/315/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/315/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/315/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/315/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/315/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/315/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/315/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/315/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/316/relationships/out",
  "метки": "http://localhost:7474/db/data/node/316/labels",
  "данные": {
    "имя": "19"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/316/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/316/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/316",
  "свойство": "http://localhost:7474/db/data/node/316/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/316/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/316/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/316/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/316/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/316/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/316/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/316/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/318/relationships/out",
  "метки": "http://localhost:7474/db/data/node/318/labels",
  "данные": {
    "имя": "21"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/318/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/318/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/318",
  "свойство": "http://localhost:7474/db/data/node/318/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/318/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/318/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/318/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/318/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/318/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/318/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/318/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/328/relationships/out",
  "метки": "http://localhost:7474/db/data/node/328/labels",
  "данные": {
    "имя": "31"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/328/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/328/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/328",
  "свойство": "http://localhost:7474/db/data/node/328/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/328/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/328/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/328/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/328/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/328/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/328/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/328/relationships/in/ {-list|&|types}"
} ]

19.15.6. Оповещение через результаты нумерованной страницу траверсы

Нумерованные страницу траверсы содержат состояние на сервере, и позволяют клиентам нумеровать страницу через
результаты обхода. Прогрессировать до следующей страницы результатов обхода,
клиент выпускает HTTP-запрос GET на нумерованном страницу URI обхода, который вызывает
обход, чтобы заполнить следующую страницу (или частично заполнить это если недостаточный
результаты доступны).

Заметьте, что, если траверса истекает через неактивность, это вызовет 404
реакция на следующем ПОЛУЧАЕТ запрос. Нитеразделители траверс восстановлены на каждом
успешный доступ для того же самого количества времени как первоначально определено.

Когда нумерованная страницу траверса достигнет конца своих результатов, клиент может ожидать
404 реакции как траверса расположены сервером.

Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/db/data/node/330/paged/traverse/node/
    7ab37c0064654259ab2a1212ddb41c7f
  * Примите: application/json

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

[{
  "outgoing_relationships": "http://localhost:7474/db/data/node/661/relationships/out",
  "метки": "http://localhost:7474/db/data/node/661/labels",
  "данные": {
    "имя": "331"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/661/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/661/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/661",
  "свойство": "http://localhost:7474/db/data/node/661/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/661/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/661/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/661/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/661/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/661/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/661/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/661/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/671/relationships/out",
  "метки": "http://localhost:7474/db/data/node/671/labels",
  "данные": {
    "имя": "341"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/671/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/671/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/671",
  "свойство": "http://localhost:7474/db/data/node/671/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/671/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/671/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/671/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/671/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/671/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/671/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/671/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/681/relationships/out",
  "метки": "http://localhost:7474/db/data/node/681/labels",
  "данные": {
    "имя": "351"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/681/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/681/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/681",
  "свойство": "http://localhost:7474/db/data/node/681/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/681/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/681/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/681/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/681/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/681/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/681/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/681/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/691/relationships/out",
  "метки": "http://localhost:7474/db/data/node/691/labels",
  "данные": {
    "имя": "361"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/691/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/691/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/691",
  "свойство": "http://localhost:7474/db/data/node/691/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/691/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/691/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/691/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/691/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/691/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/691/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/691/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/701/relationships/out",
  "метки": "http://localhost:7474/db/data/node/701/labels",
  "данные": {
    "имя": "371"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/701/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/701/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/701",
  "свойство": "http://localhost:7474/db/data/node/701/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/701/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/701/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/701/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/701/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/701/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/701/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/701/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/711/relationships/out",
  "метки": "http://localhost:7474/db/data/node/711/labels",
  "данные": {
    "имя": "381"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/711/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/711/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/711",
  "свойство": "http://localhost:7474/db/data/node/711/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/711/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/711/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/711/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/711/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/711/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/711/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/711/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/721/relationships/out",
  "метки": "http://localhost:7474/db/data/node/721/labels",
  "данные": {
    "имя": "391"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/721/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/721/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/721",
  "свойство": "http://localhost:7474/db/data/node/721/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/721/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/721/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/721/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/721/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/721/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/721/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/721/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/731/relationships/out",
  "метки": "http://localhost:7474/db/data/node/731/labels",
  "данные": {
    "имя": "401"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/731/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/731/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/731",
  "свойство": "http://localhost:7474/db/data/node/731/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/731/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/731/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/731/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/731/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/731/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/731/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/731/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/740/relationships/out",
  "метки": "http://localhost:7474/db/data/node/740/labels",
  "данные": {
    "имя": "410"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/740/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/740/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/740",
  "свойство": "http://localhost:7474/db/data/node/740/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/740/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/740/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/740/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/740/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/740/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/740/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/740/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/741/relationships/out",
  "метки": "http://localhost:7474/db/data/node/741/labels",
  "данные": {
    "имя": "411"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/741/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/741/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/741",
  "свойство": "http://localhost:7474/db/data/node/741/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/741/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/741/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/741/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/741/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/741/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/741/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/741/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/742/relationships/out",
  "метки": "http://localhost:7474/db/data/node/742/labels",
  "данные": {
    "имя": "412"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/742/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/742/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/742",
  "свойство": "http://localhost:7474/db/data/node/742/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/742/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/742/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/742/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/742/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/742/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/742/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/742/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/743/relationships/out",
  "метки": "http://localhost:7474/db/data/node/743/labels",
  "данные": {
    "имя": "413"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/743/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/743/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/743",
  "свойство": "http://localhost:7474/db/data/node/743/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/743/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/743/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/743/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/743/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/743/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/743/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/743/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/744/relationships/out",
  "метки": "http://localhost:7474/db/data/node/744/labels",
  "данные": {
    "имя": "414"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/744/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/744/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/744",
  "свойство": "http://localhost:7474/db/data/node/744/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/744/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/744/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/744/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/744/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/744/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/744/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/744/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/745/relationships/out",
  "метки": "http://localhost:7474/db/data/node/745/labels",
  "данные": {
    "имя": "415"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/745/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/745/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/745",
  "свойство": "http://localhost:7474/db/data/node/745/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/745/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/745/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/745/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/745/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/745/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/745/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/745/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/746/relationships/out",
  "метки": "http://localhost:7474/db/data/node/746/labels",
  "данные": {
    "имя": "416"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/746/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/746/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/746",
  "свойство": "http://localhost:7474/db/data/node/746/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/746/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/746/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/746/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/746/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/746/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/746/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/746/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/747/relationships/out",
  "метки": "http://localhost:7474/db/data/node/747/labels",
  "данные": {
    "имя": "417"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/747/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/747/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/747",
  "свойство": "http://localhost:7474/db/data/node/747/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/747/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/747/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/747/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/747/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/747/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/747/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/747/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/748/relationships/out",
  "метки": "http://localhost:7474/db/data/node/748/labels",
  "данные": {
    "имя": "418"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/748/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/748/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/748",
  "свойство": "http://localhost:7474/db/data/node/748/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/748/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/748/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/748/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/748/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/748/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/748/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/748/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/749/relationships/out",
  "метки": "http://localhost:7474/db/data/node/749/labels",
  "данные": {
    "имя": "419"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/749/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/749/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/749",
  "свойство": "http://localhost:7474/db/data/node/749/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/749/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/749/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/749/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/749/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/749/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/749/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/749/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/751/relationships/out",
  "метки": "http://localhost:7474/db/data/node/751/labels",
  "данные": {
    "имя": "421"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/751/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/751/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/751",
  "свойство": "http://localhost:7474/db/data/node/751/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/751/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/751/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/751/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/751/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/751/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/751/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/751/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/761/relationships/out",
  "метки": "http://localhost:7474/db/data/node/761/labels",
  "данные": {
    "имя": "431"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/761/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/761/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/761",
  "свойство": "http://localhost:7474/db/data/node/761/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/761/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/761/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/761/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/761/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/761/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/761/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/761/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/771/relationships/out",
  "метки": "http://localhost:7474/db/data/node/771/labels",
  "данные": {
    "имя": "441"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/771/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/771/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/771",
  "свойство": "http://localhost:7474/db/data/node/771/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/771/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/771/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/771/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/771/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/771/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/771/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/771/relationships/in/ {-list|&|types}"
} ]

19.15.7. Нумерованный страницу размер страницы траверсы

Размер страницы значения по умолчанию - 50 элементов, но в зависимости от больше приложения или
более малый нумерует страницу, размеры могли бы быть соответствующими. Это может быть установлено, прибавляя размер страницы
параметр запроса.

Запрос в качестве примера

  * POST http://localhost:7474/db/data/node/33/paged/traverse/node?pageSize=1
  * Примите: application/json
  * Тип контента: application/json

{
  "prune_evaluator": {
    "язык": "встроенный",
    "имя": "ни один"
  },
  "return_filter": {
    "язык": "javascript",
    "корпус": "position.endNode ().getProperty ('имя').contains ('1');"
  },
  "порядок": "depth_first",
  "отношения": {
    "введите": "NEXT",
    "направление":
  }
}

Реакция в качестве примера

  * 201: Создаваемый
  * Тип контента: application/json; charset=UTF-8
  * Расположение: http://localhost:7474/db/data/node/33/paged/traverse/node/
    cccb89c7d1f04ca5a021b5ecbaf2075b

[{
  "outgoing_relationships": "http://localhost:7474/db/data/node/34/relationships/out",
  "метки": "http://localhost:7474/db/data/node/34/labels",
  "данные": {
    "имя": "1"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/34/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/34/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/34",
  "свойство": "http://localhost:7474/db/data/node/34/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/34/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/34/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/34/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/34/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/34/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/34/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/34/relationships/in/ {-list|&|types}"
} ]

19.15.8. Нумерованный страницу тайм-аут траверсы

Тайм-аут значения по умолчанию для нумерованной страницу траверсы составляет 60 секунд, но в зависимости от
приложение большие или более малые тайм-ауты могло бы быть соответствующим. Это может быть установлено
добавление leaseTime запрашивает параметр с номером секунд нумерованный страницу
траверса должна продлиться.

Запрос в качестве примера

  * POST http://localhost:7474/db/data/node/807/paged/traverse/node?leaseTime=
    10
  * Примите: application/json
  * Тип контента: application/json

{
  "prune_evaluator": {
    "язык": "встроенный",
    "имя": "ни один"
  },
  "return_filter": {
    "язык": "javascript",
    "корпус": "position.endNode ().getProperty ('имя').contains ('1');"
  },
  "порядок": "depth_first",
  "отношения": {
    "введите": "NEXT",
    "направление":
  }
}

Реакция в качестве примера

  * 201: Создаваемый
  * Тип контента: application/json; charset=UTF-8
  * Расположение: http://localhost:7474/db/data/node/807/paged/traverse/node/
    e05ab52b5e1b4e7ca3d794cf06fadce2

[{
  "outgoing_relationships": "http://localhost:7474/db/data/node/808/relationships/out",
  "метки": "http://localhost:7474/db/data/node/808/labels",
  "данные": {
    "имя": "1"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/808/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/808/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/808",
  "свойство": "http://localhost:7474/db/data/node/808/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/808/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/808/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/808/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/808/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/808/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/808/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/808/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/817/relationships/out",
  "метки": "http://localhost:7474/db/data/node/817/labels",
  "данные": {
    "имя": "10"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/817/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/817/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/817",
  "свойство": "http://localhost:7474/db/data/node/817/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/817/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/817/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/817/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/817/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/817/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/817/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/817/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/818/relationships/out",
  "метки": "http://localhost:7474/db/data/node/818/labels",
  "данные": {
    "имя": "11"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/818/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/818/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/818",
  "свойство": "http://localhost:7474/db/data/node/818/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/818/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/818/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/818/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/818/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/818/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/818/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/818/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/819/relationships/out",
  "метки": "http://localhost:7474/db/data/node/819/labels",
  "данные": {
    "имя": "12"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/819/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/819/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/819",
  "свойство": "http://localhost:7474/db/data/node/819/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/819/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/819/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/819/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/819/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/819/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/819/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/819/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/820/relationships/out",
  "метки": "http://localhost:7474/db/data/node/820/labels",
  "данные": {
    "имя": "13"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/820/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/820/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/820",
  "свойство": "http://localhost:7474/db/data/node/820/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/820/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/820/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/820/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/820/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/820/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/820/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/820/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/821/relationships/out",
  "метки": "http://localhost:7474/db/data/node/821/labels",
  "данные": {
    "имя": "14"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/821/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/821/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/821",
  "свойство": "http://localhost:7474/db/data/node/821/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/821/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/821/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/821/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/821/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/821/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/821/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/821/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/822/relationships/out",
  "метки": "http://localhost:7474/db/data/node/822/labels",
  "данные": {
    "имя": "15"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/822/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/822/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/822",
  "свойство": "http://localhost:7474/db/data/node/822/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/822/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/822/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/822/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/822/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/822/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/822/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/822/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/823/relationships/out",
  "метки": "http://localhost:7474/db/data/node/823/labels",
  "данные": {
    "имя": "16"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/823/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/823/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/823",
  "свойство": "http://localhost:7474/db/data/node/823/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/823/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/823/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/823/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/823/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/823/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/823/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/823/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/824/relationships/out",
  "метки": "http://localhost:7474/db/data/node/824/labels",
  "данные": {
    "имя": "17"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/824/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/824/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/824",
  "свойство": "http://localhost:7474/db/data/node/824/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/824/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/824/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/824/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/824/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/824/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/824/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/824/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/825/relationships/out",
  "метки": "http://localhost:7474/db/data/node/825/labels",
  "данные": {
    "имя": "18"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/825/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/825/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/825",
  "свойство": "http://localhost:7474/db/data/node/825/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/825/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/825/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/825/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/825/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/825/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/825/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/825/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/826/relationships/out",
  "метки": "http://localhost:7474/db/data/node/826/labels",
  "данные": {
    "имя": "19"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/826/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/826/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/826",
  "свойство": "http://localhost:7474/db/data/node/826/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/826/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/826/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/826/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/826/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/826/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/826/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/826/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/828/relationships/out",
  "метки": "http://localhost:7474/db/data/node/828/labels",
  "данные": {
    "имя": "21"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/828/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/828/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/828",
  "свойство": "http://localhost:7474/db/data/node/828/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/828/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/828/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/828/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/828/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/828/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/828/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/828/relationships/in/ {-list|&|types}"
}, {
  "outgoing_relationships": "http://localhost:7474/db/data/node/838/relationships/out",
  "метки": "http://localhost:7474/db/data/node/838/labels",
  "данные": {
    "имя": "31"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/838/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/838/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/838",
  "свойство": "http://localhost:7474/db/data/node/838/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/838/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/838/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/838/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/838/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/838/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/838/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/838/relationships/in/ {-list|&|types}"
} ]

19.16. Алгоритмы графика

19.16.1. Обнаружьте все кратчайшие пути
19.16.2. Обнаружьте один из кратчайших путей
19.16.3. Выполните алгоритм Dijkstra и получите единственный путь
19.16.4. Выполните алгоритм Dijkstra с равными весами на отношениях
19.16.5. Выполните алгоритм Dijkstra и получите разнообразные пути

Neo4j идет со многими встроенными алгоритмами графика. Они выполняются от
вершина запуска. Обходом управляют URI и корпус, отправленный с
запрос. Они - параметры, которые могут использоваться:

алгоритм

    Алгоритм, чтобы выбрать. Если не набор, значение по умолчанию - shortestPath. алгоритм, может
    имейте одно из этих значений:

      * shortestPath
      * allSimplePaths
      * allPaths
      * dijkstra (дополнительно с cost_property и default_cost параметрами)
max_depth
    Максимальная глубина как целое число для алгоритмов как shortestPath, где
    применимый. Значение по умолчанию 1.

19.16.1. Обнаружьте все кратчайшие пути

shortestPath алгоритм может обнаружить разнообразные пути между теми же самыми вершинами, как
в этом примере.

Рисунок 19.62. Конечный График

Final-Graph-Find-all-shortest-paths.svg


Запрос в качестве примера

  * POST http://localhost:7474/db/data/node/202/paths
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "к": "http://localhost:7474/db/data/node/197",
  "max_depth": 3,
  "отношения": {
    "введите": "к",
    "направление":
  },
  "алгоритм": "shortestPath"
}

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

[{
  "запустите": "http://localhost:7474/db/data/node/202",
  "вершины": ["http://localhost:7474/db/data/node/202", "http://localhost:7474/db/data/node/201", "http://localhost:7474/db/data/node/197"],
  "длина": 2,
  "отношения": ["http://localhost:7474/db/data/relationship/138", "http://localhost:7474/db/data/relationship/147"],
  "конец": "http://localhost:7474/db/data/node/197"
}, {
  "запустите": "http://localhost:7474/db/data/node/202",
  "вершины": ["http://localhost:7474/db/data/node/202", "http://localhost:7474/db/data/node/198", "http://localhost:7474/db/data/node/197"],
  "длина": 2,
  "отношения": ["http://localhost:7474/db/data/relationship/139", "http://localhost:7474/db/data/relationship/145"],
  "конец": "http://localhost:7474/db/data/node/197"
} ]

19.16.2. Обнаружьте один из кратчайших путей

Если никакой алгоритм пути не определен, shortestPath алгоритм с максимальной глубиной
1 будет выбран. В этом примере max_depth установлен в 3, чтобы обнаружить
кратчайший путь между максимумом 3 соединенных вершин.

Рисунок 19.63. Конечный График

Final-Graph-Find-one-of-the-shortest-paths.svg


Запрос в качестве примера

  * POST http://localhost:7474/db/data/node/195/path
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "к": "http://localhost:7474/db/data/node/190",
  "max_depth": 3,
  "отношения": {
    "введите": "к",
    "направление":
  },
  "алгоритм": "shortestPath"
}

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

{
  "запустите": "http://localhost:7474/db/data/node/195",
  "вершины": ["http://localhost:7474/db/data/node/195", "http://localhost:7474/db/data/node/191", "http://localhost:7474/db/data/node/190"],
  "длина": 2,
  "отношения": ["http://localhost:7474/db/data/relationship/129", "http://localhost:7474/db/data/relationship/135"],
  "конец": "http://localhost:7474/db/data/node/190"
}

19.16.3. Выполните алгоритм Dijkstra и получите единственный путь

Этот пример выполняет алгоритм Dijkstra по графику с различной стоимостью
свойства на различных отношениях. Заметьте, что URI запроса заканчивается /
путь, что означает единственный путь, - то, что мы хотим здесь.

Рисунок 19.64. Конечный График

Final-Graph-Execute-a-Dijkstra-algorithm-and-get-a-single-path.svg


Запрос в качестве примера

  * POST http://localhost:7474/db/data/node/208/path
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "к": "http://localhost:7474/db/data/node/205",
  "cost_property": "стоимость",
  "отношения": {
    "введите": "к",
    "направление":
  },
  "алгоритм": "dijkstra"
}

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

{
  "вес": 1.5,
  "запустите": "http://localhost:7474/db/data/node/208",
  "вершины": ["http://localhost:7474/db/data/node/208", "http://localhost:7474/db/data/node/207", "http://localhost:7474/db/data/node/204", "http://localhost:7474/db/data/node/205"],
  "длина": 3,
  "отношения": ["http://localhost:7474/db/data/relationship/149", "http://localhost:7474/db/data/relationship/151", "http://localhost:7474/db/data/relationship/152"],
  "конец": "http://localhost:7474/db/data/node/205"
}

19.16.4. Выполните алгоритм Dijkstra с равными весами на отношениях

Следующее выполняет поиск Dijkstra на графике с равными весами на
все отношения. Этот пример включен, чтобы показать разность когда
то же самое строение графика используется, но вес пути равен номеру
транзитные участки.

Рисунок 19.65. Конечный График

Final-Graph-Execute-a-Dijkstra-algorithm-with-equal-weights-on-relationships.svg


Запрос в качестве примера

  * POST http://localhost:7474/db/data/node/214/path
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "к": "http://localhost:7474/db/data/node/211",
  "cost_property": "стоимость",
  "отношения": {
    "введите": "к",
    "направление":
  },
  "алгоритм": "dijkstra"
}

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

{
  "вес": 2.0,
  "запустите": "http://localhost:7474/db/data/node/214",
  "вершины": ["http://localhost:7474/db/data/node/214", "http://localhost:7474/db/data/node/212", "http://localhost:7474/db/data/node/211"],
  "длина": 2,
  "отношения": ["http://localhost:7474/db/data/relationship/155", "http://localhost:7474/db/data/relationship/160"],
  "конец": "http://localhost:7474/db/data/node/211"
}

19.16.5. Выполните алгоритм Dijkstra и получите разнообразные пути

Этот пример выполняет алгоритм Dijkstra по графику с различной стоимостью
свойства на различных отношениях. Заметьте, что URI запроса заканчивается /
пути, что означает, что мы хотим разнообразные пути, возвратились, в случае, если они существуют.

Рисунок 19.66. Конечный График

Final-Graph-Execute-a-Dijkstra-algorithm-and-get-multiple-paths.svg


Запрос в качестве примера

  * POST http://localhost:7474/db/data/node/188/paths
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "к": "http://localhost:7474/db/data/node/185",
  "cost_property": "стоимость",
  "отношения": {
    "введите": "к",
    "направление":
  },
  "алгоритм": "dijkstra"
}

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

[{
  "вес": 1.5,
  "запустите": "http://localhost:7474/db/data/node/188",
  "вершины": ["http://localhost:7474/db/data/node/188", "http://localhost:7474/db/data/node/187", "http://localhost:7474/db/data/node/184", "http://localhost:7474/db/data/node/185"],
  "длина": 3,
  "отношения": ["http://localhost:7474/db/data/relationship/122", "http://localhost:7474/db/data/relationship/124", "http://localhost:7474/db/data/relationship/125"],
  "конец": "http://localhost:7474/db/data/node/185"
}, {
  "вес": 1.5,
  "запустите": "http://localhost:7474/db/data/node/188",
  "вершины": ["http://localhost:7474/db/data/node/188", "http://localhost:7474/db/data/node/183", "http://localhost:7474/db/data/node/185"],
  "длина": 2,
  "отношения": ["http://localhost:7474/db/data/relationship/123", "http://localhost:7474/db/data/relationship/127"],
  "конец": "http://localhost:7474/db/data/node/185"
} ]

19.17. Групповые процессы

19.17.1. Выполните разнообразные операции в пакете
19.17.2. Обратитесь к элементам, создаваемым ранее в том же самом пакетном задании
19.17.3. Выполните разнообразные операции в пакетной потоковой передаче

19.17.1. Выполните разнообразные операции в пакете

Это пускает Вам выполнять разнообразные вызовы API через единственный HTTP-вызов,
значительно улучшая производительность для большой вставки и операций обновления.

Пакетная служба ожидает массив должностных инструкций как входной, каждого задания
описание, описывающее действие, которое будет выполнено через нормальный API сервера.

Эта служба является транзакционной. Если какая-либо из операций выполняла сбои
(возвращает non-2xx код состояния HTTP), транзакция будет откатываться и
все изменения будут отменены.

Каждая должностная инструкция должна делиться без остатка, чтобы приписать, со значением относительно
корень API данных (так http://localhost:7474/db/data/node <http://localhost:7474
/db/data/node> становится только / вершиной), и атрибут метода, содержащий глагол HTTP
использовать.

Дополнительно Вы можете обеспечить атрибут корпуса, и атрибут идентификатора, чтобы помочь Вам
отследите реакции, хотя реакции, как гарантируют, будут возвращены в
тот же самый порядок должностные инструкции получен.

Следующая фигура выделяет различные части должностных инструкций:

batch-request-api.png

Рисунок 19.67. Конечный График

Final-Graph-Execute-multiple-operations-in-batch.svg


Запрос в качестве примера

  * POST http://localhost:7474/db/data/batch
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

[{
  "метод": "ПОМЕЩЕННЫЙ",
  "к": "/node/31/properties",
  "корпус": {
    "возраст": 1
  },
  "идентификатор": 0
}, {
  "метод": "ДОБЕРИТЕСЬ",
  "к": "/node/31",
  "идентификатор": 1
}, {
  "метод": "POST",
  "к": "/вершина",
  "корпус": {
    "возраст": 1
  },
  "идентификатор": 2
}, {
  "метод": "POST",
  "к": "/вершина",
  "корпус": {
    "возраст": 1
  },
  "идентификатор": 3
} ]

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

[{
  "идентификатор": 0,
  "от": "/node/31/properties"
}, {
  "идентификатор": 1,
  "корпус": {
    "расширения": {
    },
    "outgoing_relationships": "http://localhost:7474/db/data/node/31/relationships/out",
    "метки": "http://localhost:7474/db/data/node/31/labels",
    "all_typed_relationships": "http://localhost:7474/db/data/node/31/relationships/all/ {-list|&|types}",
    "траверз": "http://localhost:7474/db/data/node/31/traverse/ {returnType}",
    "сам": "http://localhost:7474/db/data/node/31",
    "свойство": "http://localhost:7474/db/data/node/31/properties/ {ключ}",
    "свойства": "http://localhost:7474/db/data/node/31/properties",
    "outgoing_typed_relationships": "http://localhost:7474/db/data/node/31/relationships/out/ {-list|&|types}",
    "incoming_relationships": "http://localhost:7474/db/data/node/31/relationships/in",
    "create_relationship": "http://localhost:7474/db/data/node/31/relationships",
    "paged_traverse": "http://localhost:7474/db/data/node/31/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
    "all_relationships": "http://localhost:7474/db/data/node/31/relationships/all",
    "incoming_typed_relationships": "http://localhost:7474/db/data/node/31/relationships/in/ {-list|&|types}",
    "данные": {
      "возраст": 1
    }
  },
  "от": "/node/31"
}, {
  "идентификатор": 2,
  "расположение": "http://localhost:7474/db/data/node/32",
  "корпус": {
    "расширения": {
    },
    "outgoing_relationships": "http://localhost:7474/db/data/node/32/relationships/out",
    "метки": "http://localhost:7474/db/data/node/32/labels",
    "all_typed_relationships": "http://localhost:7474/db/data/node/32/relationships/all/ {-list|&|types}",
    "траверз": "http://localhost:7474/db/data/node/32/traverse/ {returnType}",
    "сам": "http://localhost:7474/db/data/node/32",
    "свойство": "http://localhost:7474/db/data/node/32/properties/ {ключ}",
    "свойства": "http://localhost:7474/db/data/node/32/properties",
    "outgoing_typed_relationships": "http://localhost:7474/db/data/node/32/relationships/out/ {-list|&|types}",
    "incoming_relationships": "http://localhost:7474/db/data/node/32/relationships/in",
    "create_relationship": "http://localhost:7474/db/data/node/32/relationships",
    "paged_traverse": "http://localhost:7474/db/data/node/32/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
    "all_relationships": "http://localhost:7474/db/data/node/32/relationships/all",
    "incoming_typed_relationships": "http://localhost:7474/db/data/node/32/relationships/in/ {-list|&|types}",
    "данные": {
      "возраст": 1
    }
  },
  "от": "/вершина"
}, {
  "идентификатор": 3,
  "расположение": "http://localhost:7474/db/data/node/33",
  "корпус": {
    "расширения": {
    },
    "outgoing_relationships": "http://localhost:7474/db/data/node/33/relationships/out",
    "метки": "http://localhost:7474/db/data/node/33/labels",
    "all_typed_relationships": "http://localhost:7474/db/data/node/33/relationships/all/ {-list|&|types}",
    "траверз": "http://localhost:7474/db/data/node/33/traverse/ {returnType}",
    "сам": "http://localhost:7474/db/data/node/33",
    "свойство": "http://localhost:7474/db/data/node/33/properties/ {ключ}",
    "свойства": "http://localhost:7474/db/data/node/33/properties",
    "outgoing_typed_relationships": "http://localhost:7474/db/data/node/33/relationships/out/ {-list|&|types}",
    "incoming_relationships": "http://localhost:7474/db/data/node/33/relationships/in",
    "create_relationship": "http://localhost:7474/db/data/node/33/relationships",
    "paged_traverse": "http://localhost:7474/db/data/node/33/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
    "all_relationships": "http://localhost:7474/db/data/node/33/relationships/all",
    "incoming_typed_relationships": "http://localhost:7474/db/data/node/33/relationships/in/ {-list|&|types}",
    "данные": {
      "возраст": 1
    }
  },
  "от": "/вершина"
} ]

19.17.2. Обратитесь к элементам, создаваемым ранее в том же самом пакетном задании

API группового процесса позволяет, Вы, чтобы обратиться к URI возвратились из создаваемого
ресурс в последовательных должностных инструкциях, в пределах того же самого пакетного вызова.

Используйте {[ID JOB]} специальный синтаксис, чтобы ввести URI от создаваемых ресурсов в
ДЖСОН представляет в виде строки в последовательных должностных инструкциях.

Рисунок 19.68. Конечный График

Final-Graph-Refer-to-items-created-earlier-in-the-same-batch-job.svg


Запрос в качестве примера

  * POST http://localhost:7474/db/data/batch
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

[{
  "метод": "POST",
  "к": "/вершина",
  "идентификатор": 0,
  "корпус": {
    "имя": "отвес"
  }
}, {
  "метод": "POST",
  "к": "/вершина",
  "идентификатор": 1,
  "корпус": {
    "возраст": 12
  }
}, {
  "метод": "POST",
  "к": "{0} / отношения",
  "идентификатор": 3,
  "корпус": {
    "к": "{1}",
    "данные": {
      "с тех пор": "2010"
    },
    "введите": "ЗНАЕТ"
  }
}, {
  "метод": "POST",
  "к": "/index/relationship/my_rels",
  "идентификатор": 4,
  "корпус": {
    "ключ": "с тех пор",
    "значение": "2010",
    "туры": "{3}"
  }
} ]

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

[{
  "идентификатор": 0,
  "расположение": "http://localhost:7474/db/data/node/23",
  "корпус": {
    "расширения": {
    },
    "outgoing_relationships": "http://localhost:7474/db/data/node/23/relationships/out",
    "метки": "http://localhost:7474/db/data/node/23/labels",
    "all_typed_relationships": "http://localhost:7474/db/data/node/23/relationships/all/ {-list|&|types}",
    "траверз": "http://localhost:7474/db/data/node/23/traverse/ {returnType}",
    "сам": "http://localhost:7474/db/data/node/23",
    "свойство": "http://localhost:7474/db/data/node/23/properties/ {ключ}",
    "свойства": "http://localhost:7474/db/data/node/23/properties",
    "outgoing_typed_relationships": "http://localhost:7474/db/data/node/23/relationships/out/ {-list|&|types}",
    "incoming_relationships": "http://localhost:7474/db/data/node/23/relationships/in",
    "create_relationship": "http://localhost:7474/db/data/node/23/relationships",
    "paged_traverse": "http://localhost:7474/db/data/node/23/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
    "all_relationships": "http://localhost:7474/db/data/node/23/relationships/all",
    "incoming_typed_relationships": "http://localhost:7474/db/data/node/23/relationships/in/ {-list|&|types}",
    "данные": {
      "имя": "отвес"
    }
  },
  "от": "/вершина"
}, {
  "идентификатор": 1,
  "расположение": "http://localhost:7474/db/data/node/24",
  "корпус": {
    "расширения": {
    },
    "outgoing_relationships": "http://localhost:7474/db/data/node/24/relationships/out",
    "метки": "http://localhost:7474/db/data/node/24/labels",
    "all_typed_relationships": "http://localhost:7474/db/data/node/24/relationships/all/ {-list|&|types}",
    "траверз": "http://localhost:7474/db/data/node/24/traverse/ {returnType}",
    "сам": "http://localhost:7474/db/data/node/24",
    "свойство": "http://localhost:7474/db/data/node/24/properties/ {ключ}",
    "свойства": "http://localhost:7474/db/data/node/24/properties",
    "outgoing_typed_relationships": "http://localhost:7474/db/data/node/24/relationships/out/ {-list|&|types}",
    "incoming_relationships": "http://localhost:7474/db/data/node/24/relationships/in",
    "create_relationship": "http://localhost:7474/db/data/node/24/relationships",
    "paged_traverse": "http://localhost:7474/db/data/node/24/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
    "all_relationships": "http://localhost:7474/db/data/node/24/relationships/all",
    "incoming_typed_relationships": "http://localhost:7474/db/data/node/24/relationships/in/ {-list|&|types}",
    "данные": {
      "возраст": 12
    }
  },
  "от": "/вершина"
}, {
  "идентификатор": 3,
  "расположение": "http://localhost:7474/db/data/relationship/3",
  "корпус": {
    "расширения": {
    },
    "запустите": "http://localhost:7474/db/data/node/23",
    "свойство": "http://localhost:7474/db/data/relationship/3/properties/ {ключ}",
    "сам": "http://localhost:7474/db/data/relationship/3",
    "свойства": "http://localhost:7474/db/data/relationship/3/properties",
    "введите": "ЗНАЕТ",
    "конец": "http://localhost:7474/db/data/node/24",
    "данные": {
      "с тех пор": "2010"
    }
  },
  "от": "http://localhost:7474/db/data/node/23/relationships"
}, {
  "идентификатор": 4,
  "расположение": "http://localhost:7474/db/data/index/relationship/my_rels/since/2010/3",
  "корпус": {
    "расширения": {
    },
    "запустите": "http://localhost:7474/db/data/node/23",
    "свойство": "http://localhost:7474/db/data/relationship/3/properties/ {ключ}",
    "сам": "http://localhost:7474/db/data/relationship/3",
    "свойства": "http://localhost:7474/db/data/relationship/3/properties",
    "введите": "ЗНАЕТ",
    "конец": "http://localhost:7474/db/data/node/24",
    "данные": {
      "с тех пор": "2010"
    },
    "индексированный": "http://localhost:7474/db/data/index/relationship/my_rels/since/2010/3"
  },
  "от": "/index/relationship/my_rels"
} ]

19.17.3. Выполните разнообразные операции в пакетной потоковой передаче

Рисунок 19.69. Конечный График

Final-Graph-execute-multiple-operations-in-batch-streaming.svg


Запрос в качестве примера

  * POST http://localhost:7474/db/data/batch
  * Примите: application/json
  * Тип контента: application/json
  * X-поток: истина

[{
  "метод": "ПОМЕЩЕННЫЙ",
  "к": "/node/101/properties",
  "корпус": {
    "возраст": 1
  },
  "идентификатор": 0
}, {
  "метод": "ДОБЕРИТЕСЬ",
  "к": "/node/101",
  "идентификатор": 1
}, {
  "метод": "POST",
  "к": "/вершина",
  "корпус": {
    "возраст": 1
  },
  "идентификатор": 2
}, {
  "метод": "POST",
  "к": "/вершина",
  "корпус": {
    "возраст": 1
  },
  "идентификатор": 3
} ]

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

[{
  "идентификатор": 0,
  "от": "/node/101/properties",
  "корпус": нуль,
  "состояние": 204
}, {
  "идентификатор": 1,
  "от": "/node/101",
  "корпус": {
    "расширения": {
    },
    "outgoing_relationships": "http://localhost:7474/db/data/node/101/relationships/out",
    "метки": "http://localhost:7474/db/data/node/101/labels",
    "all_typed_relationships": "http://localhost:7474/db/data/node/101/relationships/all/ {-list|&|types}",
    "траверз": "http://localhost:7474/db/data/node/101/traverse/ {returnType}",
    "сам": "http://localhost:7474/db/data/node/101",
    "свойство": "http://localhost:7474/db/data/node/101/properties/ {ключ}",
    "свойства": "http://localhost:7474/db/data/node/101/properties",
    "outgoing_typed_relationships": "http://localhost:7474/db/data/node/101/relationships/out/ {-list|&|types}",
    "incoming_relationships": "http://localhost:7474/db/data/node/101/relationships/in",
    "create_relationship": "http://localhost:7474/db/data/node/101/relationships",
    "paged_traverse": "http://localhost:7474/db/data/node/101/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
    "all_relationships": "http://localhost:7474/db/data/node/101/relationships/all",
    "incoming_typed_relationships": "http://localhost:7474/db/data/node/101/relationships/in/ {-list|&|types}",
    "данные": {
      "возраст": 1
    }
  },
  "состояние": 200
}, {
  "идентификатор": 2,
  "от": "/вершина",
  "корпус": {
    "расширения": {
    },
    "outgoing_relationships": "http://localhost:7474/db/data/node/102/relationships/out",
    "метки": "http://localhost:7474/db/data/node/102/labels",
    "all_typed_relationships": "http://localhost:7474/db/data/node/102/relationships/all/ {-list|&|types}",
    "траверз": "http://localhost:7474/db/data/node/102/traverse/ {returnType}",
    "сам": "http://localhost:7474/db/data/node/102",
    "свойство": "http://localhost:7474/db/data/node/102/properties/ {ключ}",
    "свойства": "http://localhost:7474/db/data/node/102/properties",
    "outgoing_typed_relationships": "http://localhost:7474/db/data/node/102/relationships/out/ {-list|&|types}",
    "incoming_relationships": "http://localhost:7474/db/data/node/102/relationships/in",
    "create_relationship": "http://localhost:7474/db/data/node/102/relationships",
    "paged_traverse": "http://localhost:7474/db/data/node/102/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
    "all_relationships": "http://localhost:7474/db/data/node/102/relationships/all",
    "incoming_typed_relationships": "http://localhost:7474/db/data/node/102/relationships/in/ {-list|&|types}",
    "данные": {
      "возраст": 1
    }
  },
  "расположение": "http://localhost:7474/db/data/node/102",
  "состояние": 201
}, {
  "идентификатор": 3,
  "от": "/вершина",
  "корпус": {
    "расширения": {
    },
    "outgoing_relationships": "http://localhost:7474/db/data/node/103/relationships/out",
    "метки": "http://localhost:7474/db/data/node/103/labels",
    "all_typed_relationships": "http://localhost:7474/db/data/node/103/relationships/all/ {-list|&|types}",
    "траверз": "http://localhost:7474/db/data/node/103/traverse/ {returnType}",
    "сам": "http://localhost:7474/db/data/node/103",
    "свойство": "http://localhost:7474/db/data/node/103/properties/ {ключ}",
    "свойства": "http://localhost:7474/db/data/node/103/properties",
    "outgoing_typed_relationships": "http://localhost:7474/db/data/node/103/relationships/out/ {-list|&|types}",
    "incoming_relationships": "http://localhost:7474/db/data/node/103/relationships/in",
    "create_relationship": "http://localhost:7474/db/data/node/103/relationships",
    "paged_traverse": "http://localhost:7474/db/data/node/103/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
    "all_relationships": "http://localhost:7474/db/data/node/103/relationships/all",
    "incoming_typed_relationships": "http://localhost:7474/db/data/node/103/relationships/in/ {-list|&|types}",
    "данные": {
      "возраст": 1
    }
  },
  "расположение": "http://localhost:7474/db/data/node/103",
  "состояние": 201
} ]

19.18. Индексация наследства

19.18.1. Создайте вершину, индексируют
19.18.2. Создайте вершину, индексируют с конфигурацией
19.18.3. Сотрите вершину, индексируют
19.18.4. Вершина списка индексирует
19.18.5. Прибавьте вершину, чтобы индексировать
19.18.6. Переместите все записи с данной вершиной от индексирования
19.18.7. Переместите все записи с данной вершиной и ключом от индексирования
19.18.8. Переместите все записи с данной вершиной, ключом и оцените от индексирования
19.18.9. Вершина нового месторождения точным совпадением
19.18.10. Вершина нового месторождения запросом

Замечание

Это документирует индексацию наследства в Neo4j, который больше не является привилегированным
способ обработать индексирует. Рассмотрите смотрение на Раздел 19.13, "Индексацию".

Индексирование может содержать или вершины или отношения.

Замечание

Чтобы создать индексирование с конфигурацией значения по умолчанию, просто начните использовать это, добавляясь
вершины/отношения к этому. Это будет тогда автоматически создаваться для Вас.

Какое средство конфигурации значения по умолчанию зависит от того, как Вы сконфигурировали Ваш
база данных. Если Вы не изменили конфигурации индексации, это означает
индексирует будет использовать Lucene-на-основе бэкэнд.

Все примеры ниже показывают Вам, как сделать, операции на вершине индексируют, но все
из них столь применимы к отношению, индексирует. Простое изменение
часть "вершины" URL к "отношению".

Если Вы хотите настроить индексировать настройки, см. Раздел 19.18.2, “Создайте вершина
индексируйте с конфигурацией”.

19.18.1. Создайте вершину, индексируют

Замечание

Вместо того, чтобы создать индексирование этого пути, Вы можете просто начать использовать это, и это
будет создаваться автоматически с конфигурацией значения по умолчанию.

Запрос в качестве примера

  * POST http://localhost:7474/db/data/index/node/
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "имя": "избранное"
}

Реакция в качестве примера

  * 201: Создаваемый
  * Тип контента: application/json; charset=UTF-8
  * Расположение: http://localhost:7474/db/data/index/node/favorites/

{
  "шаблон": "http://localhost:7474/db/data/index/node/favorites/ {ключ} / {значение}"
}

19.18.2. Создайте вершину, индексируют с конфигурацией

Этот запрос только необходим, если Вы хотите настроить индексировать настройки. Если
Вы довольны значениями по умолчанию, Вы можете только начать индексировать вершины /
отношения, столь же несуществующие, индексирует, будет автоматически создаваться, как Вы делаете.
См. Раздел 34.10, “Конфигурация и fulltext индексируют” для получения дополнительной информации о
индексируйте конфигурацию.

Запрос в качестве примера

  * POST http://localhost:7474/db/data/index/node/
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "имя": "fulltext",
  "конфигурация": {
    "введите": "fulltext",
    "провайдер": "lucene"
  }
}

Реакция в качестве примера

  * 201: Создаваемый
  * Тип контента: application/json; charset=UTF-8
  * Расположение: http://localhost:7474/db/data/index/node/fulltext/

{
  "шаблон": "http://localhost:7474/db/data/index/node/fulltext/ {ключ} / {значение}",
  "введите": "fulltext",
  "провайдер": "lucene"
}

19.18.3. Сотрите вершину, индексируют

Запрос в качестве примера

  * СТИРАЮТ http://localhost:7474/db/data/index/node/kvnode
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 204: Никакой Контент

19.18.4. Вершина списка индексирует

Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/db/data/index/node/
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

{
  "node_auto_index": {
    "шаблон": "http://localhost:7474/db/data/index/node/node_auto_index/ {ключ} / {значение}",
    "провайдер": "lucene",
    "введите": "точный"
  },
  "избранное": {
    "шаблон": "http://localhost:7474/db/data/index/node/favorites/ {ключ} / {значение}",
    "провайдер": "lucene",
    "введите": "точный"
  }
}

19.18.5. Прибавьте вершину, чтобы индексировать

Связывается вершина с данной парой ключа/значения в данном индексируют.

Замечание

Пробелы в URI должны быть закодированы как %20.

Предостережение

Это не перезаписывает предыдущие записи. Если Вы индексируете тот же самый ключ/значение/элемент
комбинация дважды, два индексируют записи, создаются. Сделать операции типа обновления,
Вы должны стереть старую запись прежде, чем прибавить новый.

Запрос в качестве примера

  * POST http://localhost:7474/db/data/index/node/favorites
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "значение": "некоторое значение",
  "туры": "http://localhost:7474/db/data/node/83",
  "ключ": "некоторые - ключ"
}

Реакция в качестве примера

  * 201: Создаваемый
  * Тип контента: application/json; charset=UTF-8
  * Расположение: http://localhost:7474/db/data/index/node/favorites/some-key/
    some%20value/83

{
  "расширения": {
  },
  "outgoing_relationships": "http://localhost:7474/db/data/node/83/relationships/out",
  "метки": "http://localhost:7474/db/data/node/83/labels",
  "all_typed_relationships": "http://localhost:7474/db/data/node/83/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/83/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/83",
  "свойство": "http://localhost:7474/db/data/node/83/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/83/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/83/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/83/relationships/in",
  "create_relationship": "http://localhost:7474/db/data/node/83/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/83/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/83/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/83/relationships/in/ {-list|&|types}",
  "данные": {
  },
  "индексированный": "http://localhost:7474/db/data/index/node/favorites/some-key/some%20value/83"
}

19.18.6. Переместите все записи с данной вершиной от индексирования

Запрос в качестве примера

  * СТИРАЮТ http://localhost:7474/db/data/index/node/kvnode/89
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 204: Никакой Контент

19.18.7. Переместите все записи с данной вершиной и ключом от индексирования

Запрос в качестве примера

  * СТИРАЮТ http://localhost:7474/db/data/index/node/kvnode/kvkey2/91
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 204: Никакой Контент

19.18.8. Переместите все записи с данной вершиной, ключом и оцените от индексирования

Запрос в качестве примера

  * СТИРАЮТ http://localhost:7474/db/data/index/node/kvnode/kvkey1/value1/84
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 204: Никакой Контент

19.18.9. Вершина нового месторождения точным совпадением

Замечание

Пробелы в URI должны быть закодированы как %20.

Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/db/data/index/node/favorites/key/the%2520value
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

[{
  "индексированный": "http://localhost:7474/db/data/index/node/favorites/key/the%2520value/100",
  "outgoing_relationships": "http://localhost:7474/db/data/node/100/relationships/out",
  "метки": "http://localhost:7474/db/data/node/100/labels",
  "данные": {
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/100/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/100/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/100",
  "свойство": "http://localhost:7474/db/data/node/100/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/100/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/100/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/100/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/100/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/100/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/100/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/100/relationships/in/ {-list|&|types}"
} ]

19.18.10. Вершина нового месторождения запросом

Язык запроса, используемый здесь, зависит от того, какой индексируют Вас, запрашивают.
Значение по умолчанию индексирует тип, Lucene, когда Вы должны использовать запрос Lucene
язык здесь. Ниже примера нечеткого поиска по разнообразным ключам.

См.: http://lucene.apache.org/core/3_6_2/queryparsersyntax.html <http://
lucene.apache.org/core/3_6_2/queryparsersyntax.html>

Получение результатов с предопределенным упорядочиванием требует добавления параметра

order=ordering

где упорядочивание - один из, индексируют, уместность или метка. В этом случае дополнительное
поле будет прибавлено к каждому результату, названному меткой, которая содержит значение плавающее
это - метка, о которой сообщает результат запроса.

Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/db/data/index/node/bobTheIndex?query=
    Name:Build~0.1%20AND%20Gender:Male
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

[{
  "outgoing_relationships": "http://localhost:7474/db/data/node/99/relationships/out",
  "метки": "http://localhost:7474/db/data/node/99/labels",
  "данные": {
    "Имя": "Разработчик"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/99/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/99/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/99",
  "свойство": "http://localhost:7474/db/data/node/99/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/99/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/99/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/99/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/99/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/99/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/99/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/99/relationships/in/ {-list|&|types}"
} ]

19.19. Уникальная Индексация

19.19.1. Получите или создайте уникальную вершину (создают)
19.19.2. Получите или создайте уникальную (существующую) вершину
19.19.3. Создайте уникальную вершину, или сбой возврата (создают)
19.19.4. Создайте уникальную вершину или сбой возврата (сбой)
19.19.5. Прибавьте, что существующая вершина к уникальному индексирует (не индексированный)
19.19.6. Прибавьте, что существующая вершина к уникальному индексирует (уже индексированный)
19.19.7. Получите или создайте уникальное отношение (создают)
19.19.8. Получите или создайте уникальное (существующее) отношение
19.19.9. Создайте уникальное отношение, или сбой возврата (создают)
19.19.10. Создайте уникальное отношение или сбой возврата (сбой)
19.19.11. Прибавьте, что существующее отношение к уникальному индексирует (не индексированный)
19.19.12. Прибавьте, что существующее отношение к уникальному индексирует (уже индексированный)

Замечание

С Neo4j 2.0, были прибавлены уникальные ограничения. Они заставляют Neo4j осуществить
уникальность, гарантируя, что уникальность сохраняется. См. Раздел 3.7.2,
"Ограничения" для деталей об этом. Для большинства случаев, уникальных ограничений
должен использоваться, а не функции описаны ниже.

Для осуществлений уникальности есть два режима:

  * Параметр URL uniqueness=get_or_create: Создайте новую вершину/отношение и
    индексируйте это, если не существующий может быть найден. Если существующая вершина/отношение
    найден, отбросьте отправленные данные и возвратите существующую вершину/отношение.
  * Параметр URL uniqueness=create_or_fail: Создайте новую вершину/отношение если
    нет существующий не может быть найден в индексировании. Если существующая вершина/отношение
    найден, возвратите погрешность конфликта.

Для получения дополнительной информации, см. Раздел 16.6, “Создавая уникальные вершины”.

19.19.1. Получите или создайте уникальную вершину (создают)

Вершина создается, если она не существует в уникальном уже, индексируют.

Запрос в качестве примера

  * POST http://localhost:7474/db/data/index/node/people?uniqueness=
    get_or_create
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "ключ": "имя",
  "значение": "Тобиас",
  "свойства": {
    "имя": "Тобиас",
    "последовательность": 1
  }
}

Реакция в качестве примера

  * 201: Создаваемый
  * Тип контента: application/json; charset=UTF-8
  * Расположение: http://localhost:7474/db/data/index/node/people/name/Tobias/98

{
  "расширения": {
  },
  "outgoing_relationships": "http://localhost:7474/db/data/node/98/relationships/out",
  "метки": "http://localhost:7474/db/data/node/98/labels",
  "all_typed_relationships": "http://localhost:7474/db/data/node/98/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/98/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/98",
  "свойство": "http://localhost:7474/db/data/node/98/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/98/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/98/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/98/relationships/in",
  "create_relationship": "http://localhost:7474/db/data/node/98/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/98/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/98/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/98/relationships/in/ {-list|&|types}",
  "данные": {
    "последовательность": 1,
    "имя": "Тобиас"
  },
  "индексированный": "http://localhost:7474/db/data/index/node/people/name/Tobias/98"
}

19.19.2. Получите или создайте уникальную (существующую) вершину

Здесь, вершина не создается, но существующая уникальная вершина возвратилась, с тех пор
другая вершина уже индексирована с теми же самыми данными. Данные вершины возвратились,
тогда это уже существующей вершины.

Запрос в качестве примера

  * POST http://localhost:7474/db/data/index/node/people?uniqueness=
    get_or_create
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "ключ": "имя",
  "значение": "Питер",
  "свойства": {
    "имя": "Питер",
    "последовательность": 2
  }
}

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8
  * Расположение: http://localhost:7474/db/data/index/node/people/name/Peter/88

{
  "расширения": {
  },
  "outgoing_relationships": "http://localhost:7474/db/data/node/88/relationships/out",
  "метки": "http://localhost:7474/db/data/node/88/labels",
  "all_typed_relationships": "http://localhost:7474/db/data/node/88/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/88/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/88",
  "свойство": "http://localhost:7474/db/data/node/88/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/88/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/88/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/88/relationships/in",
  "create_relationship": "http://localhost:7474/db/data/node/88/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/88/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/88/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/88/relationships/in/ {-list|&|types}",
  "данные": {
    "последовательность": 1,
    "имя": "Питер"
  },
  "индексированный": "http://localhost:7474/db/data/index/node/people/name/Peter/88"
}

19.19.3. Создайте уникальную вершину, или сбой возврата (создают)

Здесь, в случае уже существующей вершины, погрешность должна быть возвращена. В этом
пример, никакая существующая индексированная вершина не найдена, и новая вершина создается.

Запрос в качестве примера

  * POST http://localhost:7474/db/data/index/node/people?uniqueness=
    create_or_fail
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "ключ": "имя",
  "значение": "Тобиас",
  "свойства": {
    "имя": "Тобиас",
    "последовательность": 1
  }
}

Реакция в качестве примера

  * 201: Создаваемый
  * Тип контента: application/json; charset=UTF-8
  * Расположение: http://localhost:7474/db/data/index/node/people/name/Tobias/97

{
  "расширения": {
  },
  "outgoing_relationships": "http://localhost:7474/db/data/node/97/relationships/out",
  "метки": "http://localhost:7474/db/data/node/97/labels",
  "all_typed_relationships": "http://localhost:7474/db/data/node/97/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/97/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/97",
  "свойство": "http://localhost:7474/db/data/node/97/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/97/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/97/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/97/relationships/in",
  "create_relationship": "http://localhost:7474/db/data/node/97/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/97/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/97/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/97/relationships/in/ {-list|&|types}",
  "данные": {
    "последовательность": 1,
    "имя": "Тобиас"
  },
  "индексированный": "http://localhost:7474/db/data/index/node/people/name/Tobias/97"
}

19.19.4. Создайте уникальную вершину или сбой возврата (сбой)

Здесь, в случае уже существующей вершины, погрешность должна быть возвращена. В этом
пример, существующая вершина, индексированная с теми же самыми данными, найден, и погрешность
возвращенный.

Запрос в качестве примера

  * POST http://localhost:7474/db/data/index/node/people?uniqueness=
    create_or_fail
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "ключ": "имя",
  "значение": "Питер",
  "свойства": {
    "имя": "Питер",
    "последовательность": 2
  }
}

Реакция в качестве примера

  * 409: Конфликт
  * Тип контента: application/json; charset=UTF-8

{
  "расширения": {
  },
  "outgoing_relationships": "http://localhost:7474/db/data/node/81/relationships/out",
  "метки": "http://localhost:7474/db/data/node/81/labels",
  "all_typed_relationships": "http://localhost:7474/db/data/node/81/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/81/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/81",
  "свойство": "http://localhost:7474/db/data/node/81/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/81/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/81/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/81/relationships/in",
  "create_relationship": "http://localhost:7474/db/data/node/81/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/81/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/81/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/81/relationships/in/ {-list|&|types}",
  "данные": {
    "последовательность": 1,
    "имя": "Питер"
  },
  "индексированный": "http://localhost:7474/db/data/index/node/people/name/Peter/81"
}

19.19.5. Прибавьте, что существующая вершина к уникальному индексирует (не индексированный)

Связывается вершина с данной парой ключа/значения в данном уникальном индексируют.

В этом примере мы используем create_or_fail уникальность.

Запрос в качестве примера

  * POST http://localhost:7474/db/data/index/node/favorites?uniqueness=
    create_or_fail
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "значение": "некоторое значение",
  "туры": "http://localhost:7474/db/data/node/92",
  "ключ": "некоторые - ключ"
}

Реакция в качестве примера

  * 201: Создаваемый
  * Тип контента: application/json; charset=UTF-8
  * Расположение: http://localhost:7474/db/data/index/node/favorites/some-key/
    some%20value/93

{
  "расширения": {
  },
  "outgoing_relationships": "http://localhost:7474/db/data/node/93/relationships/out",
  "метки": "http://localhost:7474/db/data/node/93/labels",
  "all_typed_relationships": "http://localhost:7474/db/data/node/93/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/93/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/93",
  "свойство": "http://localhost:7474/db/data/node/93/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/93/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/93/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/93/relationships/in",
  "create_relationship": "http://localhost:7474/db/data/node/93/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/93/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/93/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/93/relationships/in/ {-list|&|types}",
  "данные": {
    "некоторые - ключ": "некоторое значение"
  },
  "индексированный": "http://localhost:7474/db/data/index/node/favorites/some-key/some%20value/93"
}

19.19.6. Прибавьте, что существующая вершина к уникальному индексирует (уже индексированный)

В этом случае, вершина уже существует в индексировании, и таким образом мы получаем HTTP 409
реакция состояния, поскольку мы установили уникальность в create_or_fail.

Запрос в качестве примера

  * POST http://localhost:7474/db/data/index/node/favorites?uniqueness=
    create_or_fail
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "значение": "некоторое значение",
  "туры": "http://localhost:7474/db/data/node/95",
  "ключ": "некоторые - ключ"
}

Реакция в качестве примера

  * 409: Конфликт
  * Тип контента: application/json; charset=UTF-8

{
  "расширения": {
  },
  "outgoing_relationships": "http://localhost:7474/db/data/node/96/relationships/out",
  "метки": "http://localhost:7474/db/data/node/96/labels",
  "all_typed_relationships": "http://localhost:7474/db/data/node/96/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/96/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/96",
  "свойство": "http://localhost:7474/db/data/node/96/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/96/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/96/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/96/relationships/in",
  "create_relationship": "http://localhost:7474/db/data/node/96/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/96/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/96/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/96/relationships/in/ {-list|&|types}",
  "данные": {
    "некоторые - ключ": "некоторое значение"
  },
  "индексированный": "http://localhost:7474/db/data/index/node/favorites/some-key/some%20value/96"
}

19.19.7. Получите или создайте уникальное отношение (создают)

Создайте уникальное отношение в индексировании. Если отношение, соответствующее данный
ключ и значение уже существуют в индексировании, это будет возвращено. В противном случае новое
отношение будет создаваться.

Замечание

Тип и направление отношения не расценены, определяя
уникальность.

Запрос в качестве примера

  * POST http://localhost:7474/db/data/index/relationship/MyIndex/?uniqueness=
    get_or_create
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "ключ": "имя",
  "значение": "Тобиас",
  "запустите": "http://localhost:7474/db/data/node/231",
  "конец": "http://localhost:7474/db/data/node/232",
  "введите": "знание"
}

Реакция в качестве примера

  * 201: Создаваемый
  * Тип контента: application/json; charset=UTF-8
  * Расположение: http://localhost:7474/db/data/index/relationship/MyIndex/name/
    Tobias/170

{
  "расширения": {
  },
  "запустите": "http://localhost:7474/db/data/node/231",
  "свойство": "http://localhost:7474/db/data/relationship/170/properties/ {ключ}",
  "сам": "http://localhost:7474/db/data/relationship/170",
  "свойства": "http://localhost:7474/db/data/relationship/170/properties",
  "введите": "знание",
  "конец": "http://localhost:7474/db/data/node/232",
  "данные": {
    "имя": "Тобиас"
  },
  "индексированный": "http://localhost:7474/db/data/index/relationship/MyIndex/name/Tobias/170"
}

19.19.8. Получите или создайте уникальное (существующее) отношение

Здесь, в случае уже существующего отношения, отправленные данные игнорируются и
существующее отношение возвратилось.

Запрос в качестве примера

  * POST http://localhost:7474/db/data/index/relationship/rels?uniqueness=
    get_or_create
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "ключ": "имя",
  "значение": "Питер",
  "запустите": "http://localhost:7474/db/data/node/235",
  "конец": "http://localhost:7474/db/data/node/236",
  "введите": "ЗНАЕТ"
}

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

{
  "расширения": {
  },
  "запустите": "http://localhost:7474/db/data/node/233",
  "свойство": "http://localhost:7474/db/data/relationship/171/properties/ {ключ}",
  "сам": "http://localhost:7474/db/data/relationship/171",
  "свойства": "http://localhost:7474/db/data/relationship/171/properties",
  "введите": "ЗНАЕТ",
  "конец": "http://localhost:7474/db/data/node/234",
  "данные": {
  },
  "индексированный": "http://localhost:7474/db/data/index/relationship/rels/name/Peter/171"
}

19.19.9. Создайте уникальное отношение, или сбой возврата (создают)

Здесь, в случае уже существующего отношения, погрешность должна быть возвращена.
В этом примере не найдено никакое существующее отношение, и новое отношение
создаваемый.

Запрос в качестве примера

  * POST http://localhost:7474/db/data/index/relationship/rels?uniqueness=
    create_or_fail
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "ключ": "имя",
  "значение": "Тобиас",
  "запустите": "http://localhost:7474/db/data/node/243",
  "конец": "http://localhost:7474/db/data/node/244",
  "введите": "ЗНАЕТ"
}

Реакция в качестве примера

  * 201: Создаваемый
  * Тип контента: application/json; charset=UTF-8
  * Расположение: http://localhost:7474/db/data/index/relationship/rels/name/Tobias
    /174

{
  "расширения": {
  },
  "запустите": "http://localhost:7474/db/data/node/243",
  "свойство": "http://localhost:7474/db/data/relationship/174/properties/ {ключ}",
  "сам": "http://localhost:7474/db/data/relationship/174",
  "свойства": "http://localhost:7474/db/data/relationship/174/properties",
  "введите": "ЗНАЕТ",
  "конец": "http://localhost:7474/db/data/node/244",
  "данные": {
    "имя": "Тобиас"
  },
  "индексированный": "http://localhost:7474/db/data/index/relationship/rels/name/Tobias/174"
}

19.19.10. Создайте уникальное отношение или сбой возврата (сбой)

Здесь, в случае уже существующего отношения, погрешность должна быть возвращена.
В этом примере найдено существующее отношение, и погрешность возвращена.

Запрос в качестве примера

  * POST http://localhost:7474/db/data/index/relationship/rels?uniqueness=
    create_or_fail
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "ключ": "имя",
  "значение": "Питер",
  "запустите": "http://localhost:7474/db/data/node/223",
  "конец": "http://localhost:7474/db/data/node/224",
  "введите": "ЗНАЕТ"
}

Реакция в качестве примера

  * 409: Конфликт
  * Тип контента: application/json; charset=UTF-8

{
  "расширения": {
  },
  "запустите": "http://localhost:7474/db/data/node/221",
  "свойство": "http://localhost:7474/db/data/relationship/166/properties/ {ключ}",
  "сам": "http://localhost:7474/db/data/relationship/166",
  "свойства": "http://localhost:7474/db/data/relationship/166/properties",
  "введите": "ЗНАЕТ",
  "конец": "http://localhost:7474/db/data/node/222",
  "данные": {
  },
  "индексированный": "http://localhost:7474/db/data/index/relationship/rels/name/Peter/166"
}

19.19.11. Прибавьте, что существующее отношение к уникальному индексирует (не индексированный)

Если отношение, соответствующее данный ключ и значение уже, существует в индексировании,
это будет возвращено. В противном случае HTTP 409 (конфликт) состояние будет возвращен в
этот случай, поскольку мы используем create_or_fail.

Возможно использовать get_or_create уникальность также.

Замечание

Тип и направление отношения не расценены, определяя
уникальность.

Запрос в качестве примера

  * POST http://localhost:7474/db/data/index/relationship/rels?uniqueness=
    create_or_fail
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "ключ": "имя",
  "значение": "Питер",
  "туры": "http://localhost:7474/db/data/relationship/164"
}

Реакция в качестве примера

  * 201: Создаваемый
  * Тип контента: application/json; charset=UTF-8
  * Расположение: http://localhost:7474/db/data/index/relationship/rels/name/Peter/
    165

{
  "расширения": {
  },
  "запустите": "http://localhost:7474/db/data/node/219",
  "свойство": "http://localhost:7474/db/data/relationship/165/properties/ {ключ}",
  "сам": "http://localhost:7474/db/data/relationship/165",
  "свойства": "http://localhost:7474/db/data/relationship/165/properties",
  "введите": "ЗНАЕТ",
  "конец": "http://localhost:7474/db/data/node/220",
  "данные": {
    "имя": "Питер"
  },
  "индексированный": "http://localhost:7474/db/data/index/relationship/rels/name/Peter/165"
}

19.19.12. Прибавьте, что существующее отношение к уникальному индексирует (уже индексированный)

Запрос в качестве примера

  * POST http://localhost:7474/db/data/index/relationship/rels?uniqueness=
    create_or_fail
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "ключ": "имя",
  "значение": "Питер",
  "туры": "http://localhost:7474/db/data/relationship/168"
}

Реакция в качестве примера

  * 409: Конфликт
  * Тип контента: application/json; charset=UTF-8

{
  "расширения": {
  },
  "запустите": "http://localhost:7474/db/data/node/225",
  "свойство": "http://localhost:7474/db/data/relationship/167/properties/ {ключ}",
  "сам": "http://localhost:7474/db/data/relationship/167",
  "свойства": "http://localhost:7474/db/data/relationship/167/properties",
  "введите": "ЗНАЕТ",
  "конец": "http://localhost:7474/db/data/node/226",
  "данные": {
  },
  "индексированный": "http://localhost:7474/db/data/index/relationship/rels/name/Peter/167"
}

19.20. Автоматическое наследство Индексирует

19.20.1. Вершина нового месторождения точным совпадением от автоматического индексирует
19.20.2. Вершина нового месторождения запросом от автоматического индексирует

Включать автоматический индексирует, установите базу данных для этого, см. Раздел 34.12.1,
"Конфигурация". С этой активированной опцией Вы можете тогда индексировать и запросить вершины
в них индексирует.

19.20.1. Вершина нового месторождения точным совпадением от автоматического индексирует

Автоматический индексируют вершины, может быть найден через точные поиски с нормалью, Индексируют REST
синтаксис.

Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/db/data/index/auto/node/name/I
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

[{
  "outgoing_relationships": "http://localhost:7474/db/data/node/9/relationships/out",
  "метки": "http://localhost:7474/db/data/node/9/labels",
  "данные": {
    "имя": "I"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/9/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/9/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/9",
  "свойство": "http://localhost:7474/db/data/node/9/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/9/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/9/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/9/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/9/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/9/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/9/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/9/relationships/in/ {-list|&|types}"
} ]

19.20.2. Вершина нового месторождения запросом от автоматического индексирует

См. вершину Нового месторождения запросом для фактического синтаксиса запроса.

Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/db/data/index/auto/node/?query=name:I
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

[{
  "outgoing_relationships": "http://localhost:7474/db/data/node/0/relationships/out",
  "метки": "http://localhost:7474/db/data/node/0/labels",
  "данные": {
    "имя": "I"
  },
  "all_typed_relationships": "http://localhost:7474/db/data/node/0/relationships/all/ {-list|&|types}",
  "траверз": "http://localhost:7474/db/data/node/0/traverse/ {returnType}",
  "сам": "http://localhost:7474/db/data/node/0",
  "свойство": "http://localhost:7474/db/data/node/0/properties/ {ключ}",
  "свойства": "http://localhost:7474/db/data/node/0/properties",
  "outgoing_typed_relationships": "http://localhost:7474/db/data/node/0/relationships/out/ {-list|&|types}",
  "incoming_relationships": "http://localhost:7474/db/data/node/0/relationships/in",
  "расширения": {
  },
  "create_relationship": "http://localhost:7474/db/data/node/0/relationships",
  "paged_traverse": "http://localhost:7474/db/data/node/0/paged/traverse/ {returnType} {? размер страницы, leaseTime}",
  "all_relationships": "http://localhost:7474/db/data/node/0/relationships/all",
  "incoming_typed_relationships": "http://localhost:7474/db/data/node/0/relationships/in/ {-list|&|types}"
} ]

19.21. Конфигурируемое Наследство Автоматическая Индексация

19.21.1. Создайте автоматическое, индексируют для вершин с определенной конфигурацией
19.21.2. Создайте автоматическое, индексируют для отношений с определенной конфигурацией
19.21.3. Получите текущий статус для того, чтобы автоиндексировать на вершинах
19.21.4. Включите автоиндексации вершины
19.21.5. Список поиска автоиндексируемых свойств
19.21.6. Прибавьте свойство для того, чтобы автоиндексировать на вершинах
19.21.7. Переместите свойство для того, чтобы автоиндексировать на вершинах

Из поля автоиндексация поддерживает точные совпадения, так как они создаются с
конфигурация значения по умолчанию (см. Раздел 34.12, “Автоматическая Индексация”), первое
время Вы получаете доступ к ним. Однако возможно вмешаться в жизненный цикл
сервер прежде, чем любой автоматический индексирует, создается, чтобы изменить их конфигурацию.

Предупреждение

Этот подход не может использоваться на базах данных, которые уже имеют, автоиндексирует
установленный. Изменить автоиндексировать существующую конфигурацию индексирует, имел бы
быть стертым сначала, так быть осторожным!

Предостережение

Этот метод работает, но это не особенно приятно. Будущие версии
Neo4j может переместить эту лазейку в пользу лучшей структурированной функции
управление конфигурациями автоиндексации.

Автоиндексация должна быть включена через конфигурацию прежде, чем мы сможем создать или
сконфигурируйте их. Во-первых гарантируйте, что Вы прибавили некоторую конфигурацию как это в
neo4j.properties файл Вашего сервера:

node_auto_indexing=true
relationship_auto_indexing=true
node_keys_indexable=name, телефон
relationship_keys_indexable=since

node_auto_indexing и relationship_auto_indexing поворот настроек
автоиндексация на для вершин и отношений соответственно.
ключ node_keys_indexable позволяет Вам определять список разделенных запятой значений вершины
ключи свойства, которые будут индексированы. relationship_keys_indexable делает то же самое для
ключи свойства отношения.

Затем запустите сервер как обычно, вызывая сценарий запуска как описано в
Раздел 21.2, “Установка Сервера”.

Затем мы должны покупать право на создание автоиндексирования, говоря сервер
чтобы создать очевидно, справочник индексирует, у которого есть то же самое имя как вершина (или
отношение), автоиндексируют. Например, в этом случае мы создадим автоматическую вершину
индексируйте, чье имя - node_auto_index, как так:

19.21.1. Создайте автоматическое, индексируют для вершин с определенной конфигурацией

Запрос в качестве примера

  * POST http://localhost:7474/db/data/index/node/
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "имя": "node_auto_index",
  "конфигурация": {
    "введите": "fulltext",
    "провайдер": "lucene"
  }
}

Реакция в качестве примера

  * 201: Создаваемый
  * Тип контента: application/json; charset=UTF-8
  * Расположение: http://localhost:7474/db/data/index/node/node_auto_index/

{
  "шаблон": "http://localhost:7474/db/data/index/node/node_auto_index/ {ключ} / {значение}",
  "введите": "fulltext",
  "провайдер": "lucene"
}

Если Вы требуете сконфигурированный, автоиндексирует для отношений, подход
подобный:

19.21.2. Создайте автоматическое, индексируют для отношений с определенной конфигурацией

Запрос в качестве примера

  * POST http://localhost:7474/db/data/index/relationship/
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

{
  "имя": "relationship_auto_index",
  "конфигурация": {
    "введите": "fulltext",
    "провайдер": "lucene"
  }
}

Реакция в качестве примера

  * 201: Создаваемый
  * Тип контента: application/json; charset=UTF-8
  * Расположение: http://localhost:7474/db/data/index/relationship/
    relationship_auto_index/

{
  "шаблон": "http://localhost:7474/db/data/index/relationship/relationship_auto_index/ {ключ} / {значение}",
  "введите": "fulltext",
  "провайдер": "lucene"
}

В случае, если Вам любопытно, как это работает, на стороне сервера, она инициировала
создание индексирования, у которого, оказывается, есть то же самое имя как автоматическое, индексирует это
база данных создала бы для себя. Теперь, когда мы взаимодействуем с базой данных,
индексирование думает, что индексирование уже создается так, конечный автомат перескакивает
тот шаг и только продолжает нормальную ежедневную автоиндексацию.

Предостережение

Вы должны сделать это рано в Вашем жизненном цикле сервера, перед любой автоматической нормалью
индексирует создаются.

Есть несколько вызовов REST, предоставляющих интерфейс REST AutoIndexer <http:
//components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/graphdb/index/
AutoIndexer.html> компонент. Следующий REST вызывает работу оба, для вершины и
отношение, просто изменяя соответствующую часть URL.

19.21.3. Получите текущий статус для того, чтобы автоиндексировать на вершинах

Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/db/data/index/auto/node/status
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

ложь

19.21.4. Включите автоиндексации вершины

Запрос в качестве примера

  * ПОМЕЩЕННЫЙ http://localhost:7474/db/data/index/auto/node/status
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

истина

Реакция в качестве примера

  * 204: Никакой Контент

19.21.5. Список поиска автоиндексируемых свойств

Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/db/data/index/auto/node/properties
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 200: OK
  * Тип контента: application/json; charset=UTF-8

["некоторое-свойство"]

19.21.6. Прибавьте свойство для того, чтобы автоиндексировать на вершинах

Запрос в качестве примера

  * POST http://localhost:7474/db/data/index/auto/node/properties
  * Примите: application/json; charset=UTF-8
  * Тип контента: application/json

myProperty1

Реакция в качестве примера

  * 204: Никакой Контент

19.21.7. Переместите свойство для того, чтобы автоиндексировать на вершинах

Запрос в качестве примера

  * СТИРАЮТ http://localhost:7474/db/data/index/auto/node/properties/myProperty1
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 204: Никакой Контент

19.22. Поддержка WADL

API REST Neo4j - ДЕЙСТВИТЕЛЬНО УСПОКОИТЕЛЬНЫЙ интерфейс, полагающийся на средства управления гиперсредой
(ссылки), чтобы рекламировать допустимые действия пользователям. Гиперсреда - динамический громкоговоритель
соедините интерфейсом со стилем, где описание создает (семантическая разметка) привыкли к
сообщите клиентам об их следующих юридических вариантах как раз вовремя.

Предостережение

УСПОКОИТЕЛЬНЫЕ API не могут быть смоделированы статическими языками описания интерфейса как
WSDL или WADL.

Однако для некоторых вариантов использования, разработчики могут хотеть представить описания WADL
API REST Neo4j, особенно при использовании набора инструментов, который ожидает такой.

В тех случаях генерация WADL может быть включена, добавляясь к Вашему серверу
файл neo4j.properties:

unsupported_wadl_generation_enabled=true

Предостережение

WADL не официально поддерживаемая часть API сервера Neo4j потому что WADL
недостаточно выразительно, чтобы получить набор потенциальных взаимодействий a
клиент может управлять с сервером Neo4j. Ожидайте, что описание WADL будет
неполный, и в некоторых случаях противоречащий к реальному API. В любых случаях, где
описание WADL не соглашается с остальными API, остальные, API должен быть
рассмотренный авторитетным. Генерация WADL может быть забрана в любой точке в
Neo4j выпускают цикл.

Глава 20. Осуждения

Этот раздел выделяет осуждения в Neo4j 2.0 или ранее чтобы помочь Вам
обнаружьте путь перехода сглаживающего контура к будущим выпускам.

Соответствие графика
    Соответствующий компонент графика будет удален в будущих выпусках.

Часть V. Операции

Эта часть описывает, как установить и поддержать установку Neo4j. Это
включает темы, такие как поддержка базы данных и контроль здоровья
база данных так же как диагностирующие проблемы.

Оглавление

21. Установка & Развертывание

    21.1. Системные требования
    21.2. Установка сервера
    21.3. Установка сервера в Облаке
    21.4. Обновление
    21.5. Установка для удаленной отладки
    21.6. Коллектор Данных использования

22. Конфигурация & Производительность

    22.1. Введение
    22.2. Конфигурация сервера
    22.3. Настраивающаяся Производительность сервера
    22.4. Руководство по производительности
    22.5. Конфигурация ядра
    22.6. Кэши в Neo4j
    22.7. Логические журналы
    22.8. Настройки JVM
    22.9. Сжатое хранение коротких строк
    22.10. Сжатое хранение коротких массивов
    22.11. Настройки IO с отображенной памятью
    22.12. Руководство по Производительности Linux

23. Высокая доступность

    23.1. Архитектура
    23.2. Установка и конфигурация
    23.3. Как HA Neo4j работает
    23.4. Экземпляры арбитра
    23.5. Обновление Кластера HA Neo4j
    23.6. Высоконадежное учебное руководство по установке
    23.7. Конечная точка REST для информации о статусе HA
    23.8. Установка HAProxy как балансир загрузки

24. Резервное копирование

    24.1. Представление Резервного копирования
    24.2. Сервер и Встроенный
    24.3. Онлайновое Резервное копирование от Java
    24.4. Высокая доступность
    24.5. Восстановление Ваших Данных

25. Безопасность

    25.1. Обеспечение доступа к Серверу Neo4j

26. Контроль

    26.1. Наладка удаленный доступ JMX к Серверу Neo4j
    26.2. Как соединиться с экземпляром Neo4j, используя JMX и JConsole
    26.3. Как соединиться с JMX, контролирующим программно
    26.4. Ссылка поддерживаемого JMX MBeans

Глава 21. Установка & Развертывание

К Neo4j получают доступ как автономный сервер, любой прямо через REST
взаимодействуйте через интерфейс или через специфичный для языка драйвер.

Neo4j может быть установлен как сервер, работая или как бездисплейное приложение или
системная служба. Для получения информации об установке Сервера Neo4j, см.
Раздел 21.2, “Установка Сервера”.

Для того, чтобы выполнить Neo4j в высоконадежном режиме, см. Главу 23, Высокую доступность.

21.1. Системные требования

21.1.1. ЦП
21.1.2. Память
21.1.3. Диск
21.1.4. Файловая система
21.1.5. Программное обеспечение

Память ограничивает размер графика, ввод-вывод диска ограничивает производительность чтения-записи, как
всегда.

21.1.1. ЦП

Производительность - обычно память или ввод-вывод, направляющийся в большие графики, и вычислить
направляющийся в графики, которые умещаются в памяти.

Минимум
    Ядро Intel i3
Рекомендуемый
    Core i7 Intel

21.1.2. Память

Больше памяти позволяет еще большие графики, но рискует вызывать больше
Операции Набора мусора.

Минимум
    2 ГБАЙТ
Рекомендуемый
    16-32GB или больше

21.1.3. Диск

Кроме емкости, показатели производительности диска наиболее
важный, выбирая хранение.

Минимум
    SATA НА 10 ГБАЙТ
Рекомендуемый
    SSD w/SATA

21.1.4. Файловая система

Для присущего поведения ACID файловая система должна поддерживать сброс (fsync, fdatasync).

Минимум
    ext4 (или подобный)
Рекомендуемый
    ext4, ZFS

21.1.5. Программное обеспечение

Neo4j основан на Java.

Java
    Java Oracle 7 <http://www.oracle.com/technetwork/java/javase/downloads/
    index.html>
Операционные системы
    Linux, HP UX, Windows 2008 для производства; дополнительно Windows XP, Mac OS
    X для разработки.

21.2. Установка сервера

21.2.1. Сценарии развертывания
21.2.2. Предпосылки
21.2.3. Windows
21.2.4. Linux
21.2.5. Mac OSX
21.2.6. Разнообразные экземпляры Сервера на одной машине

21.2.1. Сценарии развертывания

Как разработчик, Вы можете хотеть загрузить Neo4j и выполнить его локально на Вашем
настольный компьютер. Мы рекомендуем это как легкий способ обнаружить Neo4j.

  Windows * For, см. Раздел 21.2.3, “Windows”.
  * Для Unix/Linux, см. Раздел 21.2.4, “Linux”.
  * Для OSX, см. Раздел 21.2.5, “Mac OSX”.

Как системный администратор, Вы можете хотеть установить Neo4j, используя упаковку
система, таким образом, Вы можете гарантировать, что у кластера машин есть идентичные установки.
См. Раздел 21.2.4.1, “Пакеты Linux” для получения дополнительной информации об этом.

Для получения информации о Высокой доступности, пожалуйста, сошлитесь на Главу 23, Высоко
Доступность.

21.2.2. Предпосылки

За исключением нашего установщика Windows, Вы будете нуждаться в Виртуальной машине Java
установленный на Вашем компьютере. Мы рекомендуем, чтобы Вы установили Java JDK 7 от
Веб-сайт Oracle <http://www.oracle.com/technetwork/java/javase/downloads/
index.html>.

21.2.3. Windows

21.2.3.1. Установщик Windows

 1. Загрузите версию, от которой Вы хотите http://neo4j.org/download <http://
    neo4j.org/download>.

      * Выбирают соответствующую версию и архитектуру для Вашей платформы.
 2. Двойной щелчок загруженный файл установщика.
 3. Следуйте за подсказками.

Замечание

Установщик запросит, чтобы быть предоставленным полномочия Администратора. Более новый
версии Windows идут с функцией SmartScreen, которая может предотвратить
установщик от выполнения  -  Вы может сделать выполненным так или иначе, щелкая "По большему количеству информации" о
экран "Windows protected your PC".

21.2.3.2. Консольное Приложение Windows

 1. Загрузите самый последний выпуск с http://neo4j.org/download <http://
    neo4j.org/download>.

      * Выбирают соответствующее распределение Zip.
 2. Щелчок правой кнопкой загруженный файл, щелкните по Extract All.

      * Ссылаются на извлеченный каталог верхнего уровня как: NEO4J_HOME
 3. Двойной щелчок по %NEO4J_HOME %\bin\Neo4j.bat
 4. Остановите сервер, вводя Ctrl-C в консоли, которая получила открытой.

21.2.3.3. Как служба Windows

 1. Загрузите самый последний выпуск с http://neo4j.org/download <http://
    neo4j.org/download>.

      * Выбирают соответствующее распределение Zip.
 2. Щелчок правой кнопкой загруженный файл, щелкните по Extract All.

      * Ссылаются на извлеченный каталог верхнего уровня как: NEO4J_HOME

С административными правами Neo4j может быть установлен как служба Windows.

 1. Щелкните по Start → Все Программы → Аксессуары.
 2. Щелкните правой кнопкой по Command Prompt → Выполнение как Администратор.
 3. Обеспечьте авторизацию и/или пароль Администратора.
 4. Переместитесь к: % %NEO4J_HOME
 5. Выполненный: установка bin\Neo4jInstaller.bat

Чтобы удалить, выполните перемещение bin\Neo4jInstaller.bat как Администратора.

Чтобы запросить состояние службы, работайте: состояние bin\Neo4jInstaller.bat

Чтобы запустить службу с командной строки, работайте: кв/см запускает Neo4j-сервер

Чтобы остановить службу от командной строки, работайте: Neo4j-сервер остановки кв/см

Вы можете также запустить и остановить Neo4j от менеджера по службе Windows.

Замечание

Некоторые пользователи сообщили о проблемах на Windows при использовании противопожарной перегородки ZoneAlarm.
Если у Вас есть проблемы, получая большие реакции от сервера, или если
веб-интерфейс не работает, пытается отключить ZoneAlarm. Войдите в контакт с поддержкой ZoneAlarm
получить информацию о том, как разрешить это.

21.2.4. Linux

21.2.4.1. Пакеты Linux

Для пакетов Debian, см. инструкции в http://debian.neo4j.org <http://
debian.neo4j.org>.

21.2.4.2. Консольное Приложение Unix

 1. Загрузите самый последний выпуск с http://neo4j.org/download <http://
    neo4j.org/download>.

      * Выбирают соответствующее tar.gz распределение для Вашей платформы.
 2. Извлеките содержание архива, используя: tar-cf <имя файла>

      * Ссылаются на извлеченный каталог верхнего уровня как: NEO4J_HOME
 3. Каталог изменения к: $NEO4J_HOME

      * Выполнение: консоль./bin/neo4j
 4. Остановите сервер, вводя Ctrl-C в консоли.

21.2.4.3. Служба Linux

Neo4j может участвовать в запуске нормальной системы и процессе завершения работы.
следующая процедура должна работать над большинством популярных дистрибутивов Linux:

 1. $NEO4J_HOME cd
 2. sudo./bin/neo4j-installer устанавливают

    Если спрошено, введите свой пароль, чтобы получить полномочия суперпользователя.

 3. состояние neo4j-службы службы sudo

    Это должно указать, что сервер не работает.

 4. neo4j-служба службы sudo запускается

    Это запустит сервер.

 5. остановка neo4j-службы службы sudo

    Это остановит сервер.

Во время установки Вам дадут, опция, чтобы выбрать пользователя Нео4дж будет
выполненный как. Вас попросят предоставить имя пользователя (принимающий значение по умолчанию к neo4j) и если
тот пользователь не присутствует на системе, она будет создаваться как системная учетная запись
и каталог $NEO4J_HOME/data будет chown'ed тому пользователю.

Вы поощрены создать выделенного пользователя для обеспечения движения и для
та причина предложено, чтобы Вы распаковали пакет распределения под/, выбирает
или Ваш сайт определенный дополнительный каталог пакетов.

После установки Вам, вероятно, придется сделать некоторую платформу определенная конфигурация и
настраивающаяся производительность. Для этого, обратитесь к Разделу 22.12, “Руководство по Производительности Linux”
.

Чтобы переместить сервер от набора служб запуска, присущие команды:

 1. $NEO4J_HOME cd
 2. sudo./bin/neo4j-installer перемещают

Это остановит сервер, работая, и переместит его.

Заметьте, что, если Вы хотели создавать новую учетную запись пользователя, на, удаляют Вас, будет
запрошенный переместить это от системы.

Замечание

Этот подход к выполнению Neo4j как сервер осуждается. Мы строго советуем
Вы, чтобы выполнить Neo4j от пакета где выполнимый.

Вы можете альтернативно создать свой собственный init.d сценарий. См. например Linux
Стандартная Основная спецификация на системной инициализации <http://
refspecs.linuxfoundation.org/LSB_3.1.0/LSB-Core-generic/LSB-Core-generic/
tocsysinit.html>, или одна из многих выборок <https://gist.github.com/chrisvest
/7673244> и учебные руководства <http://www.linux.com/learn/tutorials/
442412-managing-linux-daemons-with-init-scripts>.

21.2.5. Mac OSX

21.2.5.1. OSX через Домашнее пиво

Используя Домашнее пиво (см. http://brew.sh/ <http://brew.sh/>), чтобы установить самое последнее
устойчивая версия Сервера Neo4j, дайте следующую команду:

приготовьте устанавливают neo4j && neo4j, запускаются

Это наденет экземпляр Neo4j, работающий http://localhost:7474 <http://
localhost:7474>. Файлы установки будут находиться в ls/usr/local/Cellar/
neo4j/community-{NEO4J_VERSION}/libexec /  - , чтобы настроить настройки и символьную ссылку
каталог базы данных при желании.

После установки Neo4j может работать или как сервис или от терминала.

21.2.5.2. Выполнение Neo4j от Терминала

Сервер может быть запущен на заднем плане с терминала с командой
neo4j запускаются, и затем остановились снова с остановкой neo4j. Сервер может также быть
запущенный на переднем плане с neo4j консолью  -  тогда это - вывод журнала, будет
печатаемый к терминалу.

Команда neo4j-оболочки может использоваться, чтобы взаимодействовать с Neo4j от команды
строка используя Код. Это автоматически соединится с любым сервером, который работает
на localhost с портом значения по умолчанию иначе это покажет сообщение справки. Вы
может альтернативно запустить оболочку со встроенного экземпляра Neo4j, при использовании
- параметр пути/к/данных пути  -  замечает, что только единственный экземпляр Neo4j может
получите доступ к файлам базы данных за один раз.

21.2.5.3. Служба OSX

Neo4j может быть установлен как Mac launchd задание:

 1. $NEO4J_HOME cd
 2../bin/neo4j-installer установка
 3. launchctl перечисляют | grep нео

    Это должно открыть launchd "org.neo4j.server.7474" задание для того, чтобы работать
    Сервер Neo4j.

 4. launchctl перечисляют | grep neo4j

    Это должно указать, что сервер работает.

 5. launchctl останавливают org.neo4j.server

    Это должно остановить сервер.

 6. launchctl запускают org.neo4j.server

    Это должно запустить сервер снова.

Чтобы переместить launchctl службу, дайте следующую команду:

./bin/neo4j-installer перемещение

21.2.5.4. Замечание на Java на Индивидуалистах OS X

В отличие от предыдущих версий, Индивидуалисты OS X не идут с предварительно установленным Java.
Вы могли бы встретиться с этим в первый раз, когда Вы выполняете Neo4j, где OS X инициирует
раскрывающееся предложение Вам, чтобы установить Java SE 6.

SE Java 6 является несовместимым с Neo4j 2.0, таким образом, мы строго советуем Вам пропускать
установка Java SE 6, если у Вас нет никакого другого использования для этого. Вместо этого для Neo4j 2.0
мы рекомендуем, чтобы Вы установили Java SE 7 от Oracle (http://www.oracle.com/
technetwork/java/javase/downloads/index.html <http://www.oracle.com/technetwork
/java/javase/downloads/index.html>) как, именно это мы поддерживаем для производства
использовать.

21.2.6. Разнообразные экземпляры Сервера на одной машине

Neo4j может быть установлен, чтобы работать как несколько экземпляров на одной машине, предусматривая
экземпляр несколько баз данных для разработки.

Для того, как установить это, см. Раздел 23.6.3, “Вариант устанавливает: Создание a
локальный кластер для того, чтобы протестировать”. Только используйте выпуск Neo4j своего выбора, следуйте
руководство и не забывает не устанавливать серверы, чтобы приработать режим HA.

21.3. Установка сервера в Облаке

Neo4j может быть размещен на различных "облачных" службах. См. http://www.neo4j.org/develop
/ облако <http://www.neo4j.org/develop/cloud> для получения дополнительной информации.

21.4. Обновление

21.4.1. Автоматическое Обновление
21.4.2. Явное Обновление
21.4.3. Обновите 1.9 → 2.0
21.4.4. Обновите 1.8 → 1.9
21.4.5. Обновите 1.7 → 1.8
21.4.6. Обновите 1.6 → 1.7
21.4.7. Обновите 1.5 → 1.6
21.4.8. Обновите 1.4 → 1.5

База данных может быть обновлена от вспомогательной версии до следующего, например, 1.1 → 1.2,
и 1.2 → 1.3, но Вы не можете перейти прямо от 1.1 → 1.3. Для версии 1.8 в
определенный, возможно обновить прямо от версии 1.5.3 и позже, как
явное обновление. Процесс обновления - один путь шаг; базы данных не могут быть
пониженный.

Для большинства обновлений только небольшие изменения обязаны хранилище базы данных, и
эти изменения продолжаются автоматически, когда Вы запускаете базу данных, используя
более новая версия Neo4j.

Однако, некоторые обновления требуют более существенных изменений к хранилищу базы данных.
В этих случаях Neo4j откажется запускаться без явной конфигурации к
позвольте обновление.

Таблица ниже приводит свежие версии Neo4j, и тип требуемого обновления.

Таблица 21.1. Процесс обновления для версии Neo4j

От Версии До Типа Обновления Версии
1.3 1.4 Автоматический

1.4 1.5 Явный

1.5 1.6 Явный

1.6 1.7 Автоматический

1.7 1.8 Автоматический

1.8 1.9 Автоматический

1.9 2.0 Явный


Замечание

Спуск поддерживается только между версиями, которые не имеют несовместимым
разметки хранилища. Это означает что, если Вы сделали обновление, где Вы не имели к
явно установите флаг allow_store_upgrade в ложь тогда, Вы можете понизить
без любых проблем к предыдущей используемой версии. Иначе понижение не
поддерживаемый. В любом случае, понижение в настоящий момент не может быть сделано в прокрутке
вид, даже в развертывании HA. Вместо этого целый кластер должен быть завершением работы
и каждая машина, пониженная индивидуально и затем служба, может быть возобновлена.

21.4.1. Автоматическое Обновление

Выполнять нормальное обновление (для незначительных изменений к хранилищу базы данных):

 1. Загрузите более новую версию Neo4j.
 2. Чисто выключение база данных, чтобы обновить, если это работает.
 3. Запустите базу данных с более новой версией Neo4j.
 4. Обновление произойдет во время запуска, и процесс сделан когда
    база данных была успешно запущена.

21.4.2. Явное Обновление

Выполнять специальное обновление (для существенных изменений к хранилищу базы данных):

 1. Загрузите более новую версию Neo4j.
 2. Чисто выключение база данных, чтобы обновить, если это работает.
 3. Установите параметры конфигурации Neo4j allow_store_upgrade=true в Вашем
    neo4j.properties или встроенная конфигурация.
 4. Запустите базу данных с более новой версией Neo4j.
 5. Обновление произойдет во время запуска, и процесс сделан когда
    база данных была успешно запущена.
 6. allow_store_upgrade параметры конфигурации должны быть удалены, установлены к
    ложь или прокомментированный.
 7. Информация об обновлении и индикаторе хода выполнения печатается в
    messages.log.

21.4.3. Обновите 1.9 → 2.0

Этот выпуск прибавляет новое хранилище для меток и один для схемы, индексирования для
метки, и также формат хранилища вершины изменились. Заметьте, что мы не делаем
в настоящий момент прокрутка поддержки обновляет между 1.9.x и 2.0.

Для Neo4j 2.0, требуется Java 7. Мы рекомендуем, чтобы Вы установили Java JDK 7
от Веб-сайта Oracle <http://www.oracle.com/technetwork/java/javase/
downloads/index.html>.

Обновляя, следующее произойдет и и займет время, и
будет требовать дополнительного дискового пространства:

 1. Будет создаваться новое, пустое хранилище схемы.
 2. Будет создаваться новое, пустое хранилище метки.
 3. Новое, пустое сканирование метки индексирует, будет создаваться.
 4. Хранилище вершины будет преобразовано, мы должны увеличить каждую запись, чтобы сделать
    пространство для меток  -  это займет время в зависимости от размера Вашего
    база данных.

21.4.3.1. Совместимость кода

Если Вы не устанавливаете операторы, чтобы все еще использовать Код 1.9, они должны быть обновлены
для следующих изменений:

Синтаксис модели
    Круглые скобки требуются вокруг моделей вершины, когда метки используются. Это
    средства, что, прибавляя метки к модели как-> b Вы должен использовать
    что-то как (a:Person)-> (b:Company). Это - хорошая практика, чтобы использовать
    круглые скобки в вершине копируют даже там, где они строго не требуются, к
    улучшите четкость.
Дополнительные отношения
    Синтаксис (a)-[?]-> (x) для дополнительных отношений был удален. Использовать
    ДОПОЛНИТЕЛЬНОЕ СООТВЕТСТВИЕ вместо этого (см. соответствующую главу в Справочнике Neo4j).
! и? операторы свойства
    Выражения как node.property = "значение" не перестанут работать когда вершина без
    со свойством встречаются, и вместо этого возвратит НУЛЬ. Это - то же самое
    поведение как node.property! = "оценивают" в Коде 1.9.! оператор свойства
    был удален в 2.0. Поддержка выражений, используя? свойство
    оператор, такой как node.property? = "значение", были также удалены. Вы можете
    используйте не (имеет (node.property)), ИЛИ node.property = "значение" вместо этого, которое является
    совместимый и с 1.9 и с 2.0.

СОЗДАЙТЕ синтаксис
    СОЗДАВАНИЕ = {foo:’bar’} синтаксис было удалено. Вместо этого использование СОЗДАЮТ (a
    {foo:’bar’}).
Используя СТИРАЮТ, чтобы переместить свойства
    СТИРАНИЕ a.prop синтаксис было удалено. Вместо этого используйте ПЕРЕМЕЩЕНИЕ a.prop.
Используя параметры для индексируют ключи
    Параметры не могут использоваться, поскольку ключ ЗАПУСКАЕТСЯ, использование пунктов индексирует (для
    пример ЗАПУСКАЕТ n=node:index ({ключ} = 'значение')). Используйте литеральные ключевые имена
    вместо этого.
Используя параметры, чтобы идентифицировать вершины в моделях
    Параметры не могут использоваться, чтобы идентифицировать вершины в модели (то есть Соответствие
    ({вершина})-> (другой))). Заметьте, что эта форма была только возможна, смешиваясь
    встроенный API Java и Код, и таким образом не влияют на пользователей Neo4j
    Сервер.
Итеративный синтаксис в FOREACH, ВЫТЯЖКЕ, и т.д.
    Функции итерации используют | вместо a: разделить компоненты
    из оператора. Например, ВЫТЯЖКА (n в нс: n.prop), заменен
    ВЫТЯЖКА (n в нс | n.prop). Функции итерации включают FOREACH,
    ИЗВЛЕКИТЕ, ПОНИЗЬТЕ, ЛЮБОЙ, ВСЕ, ЕДИНСТВЕННЫЕ и НИ ОДИН.
Вариант С синтаксисом
    Вариант С синтаксисом, === <идентификаторы> ===, был удален. Использовать
    С ключевым словом вместо этого.
Ссылочная Вершина
    С введением Меток в Neo4j 2.0 Ссылочная Вершина стала
    атрофированный и был удален. Вместо этого маркированные вершины стал
    известные начальные точки в Вашем графике. Вы можете использовать модель как это
    получить доступ к ссылочной вершине: СООТВЕТСТВИЕ (ref:MyReference) ВОЗВРАЩАЕТСЯ касательно. Просто используйте
    одна метка на такую начальную точку Вы хотите использовать. Заметьте, что это должно быть
    выполняемый однажды во время инициализации приложения, чтобы гарантировать это только a
    единственная ссылочная вершина создается на метку. Перемещая базу данных с
    существующая ссылочная вершина, прибавьте метку к этому во время миграции, и затем
    используйте это согласно предыдущей модели. Это - то, как прибавить метку: ЗАПУСТИТЕ касательно
    =node (0) НАБОР ref:MyReference. В случае, если Вы изменили базу данных так a
    различная вершина - ссылочная вершина, подставьте идентификатор вершины в
    оператор.

21.4.3.2. Другие существенные изменения

Плагины
    Плагины больше не распределены с Neo4j. Пожалуйста, см. единичного
    специалисты по обслуживанию о доступности. Например, источник для Гремлина
    плагин будет доступен в: https://github.com/neo4j-contrib/
    плагин гремлина <https://github.com/neo4j-contrib/gremlin-plugin>

21.4.4. Обновите 1.8 → 1.9

Нет никаких изменений формата хранилища между этими версиями, настолько обновляющими
автономные экземпляры просто составы запуска базы данных с более новым
версия. В случае Высокой доступности (HA) установки, передача
протокол и основной алгоритм выборов изменились и новая "прокрутка
обновление" функция было прибавлено, устраняя потребность к выключению все
кластер. Для получения дополнительной информации, обратитесь к "Обновлению Кластера HA Neo4j"
глава раздела HA справочника Neo4j.

21.4.5. Обновите 1.7 → 1.8

Нет никаких изменений формата хранилища между этими версиями, настолько обновляющими
автономные экземпляры просто составы запуска базы данных с более новым
версия. В случае Высокой доступности (HA) установки, передача
протокол и основной алгоритм выборов изменились и новая "прокрутка
обновление" функция было прибавлено, устраняя потребность к выключению все
кластер. Для получения дополнительной информации, обратитесь к "Обновлению Кластера HA Neo4j"
глава раздела HA справочника Neo4j.

21.4.6. Обновите 1.6 → 1.7

Между этими версиями нет никаких изменений формата хранилища, что означает, что есть
никакая определенная процедура Вы должны обновить единственный экземпляр.

В среде HA должны быть выполнены эти шаги:

 1. выключение все базы данных в кластере
 2. выключение кластер ZooKeeper и четкий каталоги версии 2 на всех
    экземпляры ZooKeeper
 3. запустите кластер ZooKeeper снова
 4. переместите базы данных кроме ведущего устройства и запустите основную базу данных с
    1.7
 5. запустите другие базы данных так, чтобы они получили копию от ведущего устройства

21.4.7. Обновите 1.5 → 1.6

Это обновление изменяет lucene версию от 3.1 до 3.5. Само обновление сделано
Lucene, загружая индексирование.

В среде HA должны быть выполнены эти шаги:

 1. выключение все базы данных в кластере
 2. выключение кластер ZooKeeper и четкий каталоги версии 2 на всех
    экземпляры ZooKeeper
 3. запустите кластер ZooKeeper снова
 4. запустите другие базы данных так, чтобы они получили копию от ведущего устройства

21.4.8. Обновите 1.4 → 1.5

Это обновление включает существенное изменение в расположение хранилища свойства
файлы, который понижает их размер на диске, и улучшает производительность IO. К
достигните этого изменения расположения, процесс обновления занимает время, чтобы обработать
вся существующая база данных. Вы должны планировать для нескольких минут на
гигабайт данных как часть Вашего планирующего обновления.

Предупреждение

Процесс обновления для этого обновления временно требует дополнительного диска
пространство, в течение периода, в то время как обновление происходит. Прежде, чем запуститься
обновите до Neo4j 1.5, Вы должны гарантировать что машина, выполняющая обновление
имеет свободное пространство, равное текущему размеру базы данных на диске. Вы можете
обнаружьте текущее пространство занятым базой данных, осматривая файл хранилища
каталог (data/graph.db расположение значения по умолчанию в сервере Neo4j). Однажды
обновление полно, это дополнительное пространство больше не требуется.

21.5. Установка для удаленной отладки

Чтобы сконфигурировать сервер Neo4j для удаленных сеансов отладки, Java
отладку параметров нужно передать к процессу Java через
конфигурация. Они живут в conf/neo4j-wrapper.properties файл.

Чтобы определить параметры, прибавьте строку для дополнительного Java
параметры как это:

# Java Дополнительные Параметры
wrapper.java.additional.1=-Dorg.neo4j.server.properties=conf/neo4j-server.properties
wrapper.java.additional.2=-Dlog4j.configuration=file:conf/log4j.properties
wrapper.java.additional.3=-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 \
   -Xdebug-Xnoagent-Djava.compiler=NONE\
   -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=5005

Эта конфигурация запустит сервер Neo4j, готовый к удаленной отладке
attachement в localhost и порту 5005. Используйте эти параметры, чтобы присоединить к
процесс от Eclipse, IntelliJ или Вашего удаленного предпочтительного отладчика после запуска
сервер.

21.6. Коллектор Данных использования

21.6.1. Техническая информация
21.6.2. Как отключить UDC

Коллектор Данных Использования Neo4j - подсистема, которая собирает данные использования,
создание отчетов об этом к UDC-серверу в udc.neo4j.org. Легко отключить, и
не собирает данных, которые являются конфиденциальными. Для получения дополнительной информации, о какой
отправляется, см. ниже.

Команда Neo4j использует эту информацию в качестве формы автоматических, легких
обратная связь от сообщества Neo4j. Мы хотим проверить, что мы делаем
правильная вещь, соответствуя статистику загрузки со статистикой использования. После каждого
выпуск, мы можем видеть, есть ли больший пролет задержания программного обеспечения сервера.

Собранные данные ясно утверждены здесь. Если любые будущие версии этого
система собирает дополнительные данные, мы ясно объявим о тех изменениях.

Команда Neo4j очень озабочена Вашей конфиденциальностью. Мы не раскрываем никого
идентифицирующая персональная информация.

21.6.1. Техническая информация

Чтобы собрать хорошую статистику об использовании Neo4j, UDC собирает эту информацию:

  * версия Ядра: номер сборки, и если есть какие-либо изменения к
    ядро.
  * идентификатор Хранилища: рандомизированный глобально уникальный идентификатор, создаваемый одновременно a
    база данных создается.
  * количество Ping: UDC содержит внутренний счетчик, который постепенно увеличен для каждого
    ping, и сброшенный для каждого запускать снова ядра.
  * Источник: Это - или "neo4j" или "знаток". Если Вы загружали Neo4j с
    Веб-сайт Neo4j, это - "neo4j", если Вы будете использовать Знатока, чтобы получить Neo4j, то это будет
    будьте "знатоком".
  * версия Java: referrer представляют в виде строки шоу, которые версия Java
    используемый.
  * Мак адрес, чтобы однозначно определить экземпляры позади противопожарных перегородок.
  * Регистрационный идентификатор: Для зарегистрированных экземпляров сервера.
  * Теги о контексте выполнения (например, тест, язык, веб-контейнер,
    контейнер приложения, пружина, ejb).
  * Выпуск Neo4j (сообщество, предприятие).
  * хеш текущего имени кластера (если любой).
  * информация о Распределении для Linux (об/мин, dpkg, неизвестное).
  * головная часть Пользовательского агента для того, чтобы отследить использование клиентских драйверов REST

После запуска UDC ожидает десяти минут прежде, чем отправить первый ping. Это делает
это по двум причинам; во-первых, мы не хотим, чтобы запуск был медленнее из-за
UDC, и во-вторых, мы хотим сохранить ping от автоматических тестов до минимума.
ping к серверам UDC сделан с HTTP, ДОБИРАЮТСЯ.

21.6.2. Как отключить UDC

Мы попытались сделать чрезвычайно легким отключить UDC. Фактически, код для UDC
даже не включен в толчок ядра, но как абсолютно отдельный компонент.

Есть три способа, которыми Вы можете отключить UDC:

 1. Самый легкий путь состоит в том, чтобы только переместить neo4j-udc-*.jar файл. Делая это,
    ядро не будет загружать UDC, и никакие ping не будут отправлены.
 2. Если Вы используете Знатока, и хотите удостовериться, что UDC никогда не устанавливается
    в Вашей системе элемент зависимости как это сделает это:

     <зависимость>
       <groupId> org.neo4j </groupId>
       <artifactId> neo4j </artifactId>
       <версия> $ {neo4j-версия} </версия>
       <исключения>
         <исключение>
           <groupId> org.neo4j </groupId>
           <artifactId> neo4j-udc </artifactId>
         </исключение>
       </исключения>
     </зависимость>

    Где $ {neo4j-версия} является версией Neo4j в использовании.

 3. Наконец, если Вы используете упакованную версию Neo4j, и не хотите к
    произведите любое изменение в толчках, системное свойство, устанавливающее как это, будет также
    удостоверьтесь, что UDC никогда не активируется:-Dneo4j.ext.udc.disable=true.

Глава 22. Конфигурация & Производительность

Чтобы вытащить оптимальную производительность из Neo4j для Вашего приложения есть
несколько параметров, которые можно настроить. Два основных компонента, которые могут быть
сконфигурированный кэши Neo4j и JVM, которую прирабатывает Neo4j. Следующий
разделы описывают, как настроить их.

22.1. Введение

22.1.1. Как прибавить настройки конфигурации

Чтобы получить хорошую производительность, они - вещи изучить сначала:

  * Удостоверяются, что JVM не тратит мусор выполнения слишком большого количества времени
    набор. Контроль использования "кучи" на приложении, которое использует Neo4j, может быть
    немного запутывающий, так как Neo4j увеличит размер кэшей, если будет
    доступная память и уменьшение, если "куча" получает полной. Цель к
    имейте достаточно большую "кучу", чтобы удостовериться, что тяжелая / максимальная нагрузка не будет следовать
    в так называемом повреждении GC (производительность может отбросить целых два заказов
    величина, когда повреждение GC происходит).
  * Запускают JVM с - флаг сервера и хорошая размерная "куча" (см.
    Раздел 22.8, “Настройки JVM”). Наличие слишком большой "кучи" может также причинить боль
    производительность, таким образом, Вам, вероятно, придется попробовать некоторые различные размеры "кучи".
  * Использование параллельный/параллельный сборщик мусора (мы нашли это
    -XX: + UseConcMarkSweepGC работает хорошо в большинстве примеров использования),

22.1.1. Как прибавить настройки конфигурации

Создавая встроенный экземпляр Neo4j возможно передать в параметрах
содержавший в карте, где ключи и значения - строки, см. Раздел 32.1.4.1,
“Запуская встроенную базу данных с настроек конфигурации” для примера.

Если никакая конфигурация не будет обеспечена, то Ядро Базы данных попытается определить
соответствующие настройки от информации, доступной через настройки JVM и
базовая операционная система.

JVM сконфигурирована, передавая флаги командной строки, запуская JVM.
большинство важных параметров конфигурации для Neo4j - те, которые управляют
память и сборщик мусора, но некоторые из параметров для того, чтобы сконфигурировать
Как раз вовремя компилятор является также интересующим.

Это - пример запуска Ваших приложений основной класс, использующий 64-разрядный
сервер режим VM и пространство "кучи" 1 Гбайт:

java-d64 - сервер-Xmx1024m - CP /path/to/neo4j-kernel.jar:/path/to/jta.jar:/path/to/your-application.jar com.example.yourapp. MainClass

Смотрение на пример выше Вас также заметит одну из самой основной команды
параметры строки: тот для того, чтобы определить путь к классу. Путь к классу
путь, в котором JVM ищет Ваши классы. Это обычно - список
файлы толчка. Определение пути к классу сделано, определяя флаг - CP (или
- путь к классу) и затем значение пути к классу. Для приложений Neo4j это
должен, по крайней мере, включать путь к Neo4j neo4j-kernel.jar и Java
API транзакции (jta.jar) так же как путь, где классы для Вашего
приложение расположено.

Подсказка

На Linux, Unix и Mac OS X каждый элемент в списке пути разделены a
символ двоеточия (:), на Windows элементы пути разделены точкой с запятой
(;).

При использовании сервера REST Neo4j, см. Раздел 22.2, “Конфигурация Сервера” для
как прибавить настройки конфигурации для базы данных к серверу.

22.2. Конфигурация сервера

22.2.1. Важные параметры конфигураций сервера
22.2.2. Конфигурация производительности Базы данных Neo4j
22.2.3. Конфигурация журналирования сервера
22.2.4. Конфигурация журналирования HTTP
22.2.5. Используя X-Forwarded-Proto и X-Forwarded-Host, чтобы параметризовать основу
    URI для реакций REST
22.2.6. Другие параметры конфигурации

Быстрая информация

  * основной конфигурационный файл сервера найден под conf/
    neo4j-server.properties
  * conf/log4j.properties файл содержит журналирование сервера значения по умолчанию
    конфигурация
  * параметры настраивающегося производительности Низкого уровня найдены в conf/neo4j.properties
  * Configuraion deamonizing обертки найдены в conf/
    neo4j-wrapper.properties
  * конфигурация журналирования HTTP найдена в conf/neo4j-http-logging.xml

22.2.1. Важные параметры конфигураций сервера

Основной конфигурационный файл для сервера может быть найден в conf/
neo4j-server.properties. Этот файл содержит несколько важных настроек, и
хотя значения по умолчанию - разумные администраторы, мог бы хотеть производить изменения
(особенно к настройкам порта).

Установите расположение на диске каталога базы данных как это:

org.neo4j.server.database.location=data/graph.db

Замечание

На системах Windows абсолютные расположения включая имена диска должны читать "c:
/data/db".

Определите иллюстрирующий материал порта сервера HTTP, административный, и доступ UI:

org.neo4j.server.webserver.port=7474

Определите, что клиент принимает модель для веб-сервера (значение по умолчанию 127.0.0.1,
localhost только):

#allow любой клиент, чтобы соединиться
org.neo4j.server.webserver.address=0.0.0.0

Для того, чтобы защитить Сервер Neo4j, см. также Главу 25, Безопасность

Установите расположение кругового каталога базы данных, который собирает метрики на
рабочий экземпляр сервера:

org.neo4j.server.webadmin.rrdb.location=data/graph.db/../rrd

Установите путь URI для остальных API данных, через который получают доступ к базе данных.
Это должно быть относительным путем.

org.neo4j.server.webadmin.data.uri=/db/data/

Установка URI управления для API администрирования, который обрабатывают инструментом Webadmin
использование. Это должно быть относительным путем.

org.neo4j.server.webadmin.management.uri=/db/manage

Вынудите сервер, чтобы использовать адреса сети IPv4, в conf/neo4j-wrapper.conf
под Java раздела Дополнительные Параметры прибавляют новый paramter:

wrapper.java.additional.3=-Djava.net.preferIPv4Stack=true

Определите номер потоков, используемых веб-сервером Neo4j, чтобы управлять уровнем
из параллельных запросов HTTP, что сервер обслужит.

org.neo4j.server.webserver.maxthreads=200

Замечание

Значение по умолчанию - 10 раз номер ЦП, сообщил доступный JVM.

Сервер принимает меры против осиротевших транзакций при использовании тайм-аута. Если там
не запросы на данную транзакцию в пределах периода тайм-аута, сервера
будет откатывать это. Вы можете сконфигурировать период тайм-аута, устанавливая
следующее свойство к номеру секунд перед тайм-аутом. Тайм-аут значения по умолчанию
60 секунд.

org.neo4j.server.transaction.timeout=60

Параметры настраивающегося производительности низкого уровня могут быть явно установлены, обращаясь к
следующее свойство:

org.neo4j.server.db.tuning.properties=neo4j.properties

Если это свойство не будет установлено, то сервер будет искать вызванный файл
neo4j.properties в том же самом каталоге как neo4j-server.properties файл.

Если это свойство не установлено, и есть файл № neo4j.properties в
каталог конфигурации значения по умолчанию, тогда сервер зарегистрирует предупреждение.
Впоследствии во времени выполнения механизм базы данных будет делать попытку мелодии, непосредственно основанной на
преобладающие условия.

22.2.2. Конфигурация производительности Базы данных Neo4j

Подстройка механизма базы данных графика Neo4j низкого уровня определена в a
отдельный файл свойств, conf/neo4j.properties.

У механизма базы данных графика есть диапазон опций настраивающегося производительности, которые являются
перечисленный в Разделе 22.3, “Производительность Сервера, Настраивающаяся”. Заметьте что другой
факторы чем настраивающийся Neo4j нужно рассмотреть когда производительность, настраивающаяся a
сервер, включая общую загрузку сервера, память и конкуренцию файла, и даже
штрафы набора мусора на JVM, хотя такие соображения вне
контекст этого документа конфигурации.

22.2.3. Конфигурация журналирования сервера

События приложения в пределах сервера Neo4j обработаны с java.util.logging
<http://download.oracle.com/javase/6/docs/technotes/guides/logging/
overview.html> и сконфигурированный в файле conf/logging.properties.

По умолчанию это - установка, чтобы печатать сообщения уровня ИНФОРМАЦИИ и на экране и в a
прокрутка файла в данных/журнале. Большинство развертывания будет хотеть использовать свое собственное
конфигурация здесь, чтобы встретить локальные стандарты. Во время разработки, очень полезной
информация может быть найдена в журналах, таким образом, некоторая форма журналирования, чтобы обработать почву дисковым культиватором хороша
стоящее хранение. С другой стороны, если Вы хотите полностью заглушить консоль
вывод, набор:

java.util.logging.ConsoleHandler.level=OFF

Значением по умолчанию файлы системного журнала повернуты приблизительно в 10 МБ и названы последовательно
neo4j. <идентификатор>. <последовательность вращения #>.log, Чтобы изменить схему именования, вращение
частотный и неудовлетворенный размер модифицирует

java.util.logging. FileHandler.pattern
java.util.logging. FileHandler.limit
java.util.logging. FileHandler.count

соответственно к Вашим потребностям. Детали доступны в Javadoc для
java.util.logging. FileHandler <http://download.oracle.com/javase/6/docs/api/
java/util/logging/FileHandler.html>.

Кроме операторов журнала, происходящих из сервера Neo4j, других библиотек
сообщите об их сообщениях через различные платформы.

22.2.4. Конфигурация журналирования HTTP

Так же как регистрируя события, происходящие в пределах сервера Neo4j, это возможно к
зарегистрируйте запросы HTTP и реакции, которые сервер использует и производит.
Конфигурирование журналирования HTTP требует, чтобы операторы включили и сконфигурировали регистратор
и где это зарегистрирует; и затем дополнительно сконфигурировать формат журнала.

Предупреждение

По умолчанию регистратор HTTP использует Общий Формат Журнала <http://en.wikipedia.org/wiki
/Common_Log_Format> подразумевать, что большинство набора инструментов веб-сервера может automtically
используйте такие журналы. В общих пользователях должен только включить журналированию HTTP, выбрать
выходной каталог, и в случае необходимости изменяет политики задержания и трансформация.

Чтобы включить журналированию HTTP, отредактируйте conf/neo4j-server.properties файл, чтобы напомнить
следующее:

org.neo4j.server.http.log.enabled=true
org.neo4j.server.http.log.config=conf/neo4j-http-logging.xml

org.neo4j.server.http.log.enabled=true говорит серверу, что журналирование HTTP
включенный. Журналирование HTTP может быть полностью отключено, устанавливая это свойство в ложь
. org.neo4j.server.http.log.config=conf/neo4j-http-logging.xml определяет
журналирование формата и динамического файла политики, который управляет, как вывод журнала HTTP
представленный и заархивированный. Значения по умолчанию, предоставленные сервер Neo4j, используют почасовое
вращение журнала и Общий Формат Журнала <http://en.wikipedia.org/wiki/
Common_Log_Format>.

Если журналирование будет установлено, чтобы использовать файлы системного журнала тогда, то сервер проверит что журнал
каталог файла существует и перезаписываем. Если эта проверка перестала работать, то сервер
не будет запускаться и wil сообщают об отказе другой доступный канал как
стандарт.

22.2.5. Используя X-Forwarded-Proto и X-Forwarded-Host, чтобы параметризовать основу
URI для реакций REST

Есть случаи, например когда Вы хотите разместить сервер Neo4j позади a
прокси (например, тот, который обрабатывает трафик HTTPS), и все еще испытывает уважение Neo4j
основной URI того внешним образом видимого прокси.

Обычно Neo4j использует головную часть УЗЛА запроса HTTP, чтобы создать URI в
его реакции. Где прокси включен однако, это часто - нежелательный.
Вместо этого Neo4j, использует X-Forwarded-Host и обеспеченные головные части X-Forwarded-Proto
прокси, чтобы параметризовать URI в реакциях от REST баз данных
API. От снаружи смотрит, как будто прокси генерировал ту полезную нагрузку. Если
Значение головной части X-Forwarded-Host содержит больше чем один адрес (X-Forwarded-Host
позволяет разделенные списки запятой-и-пространства адресов), Neo4j выбирает первое,
который представляет клиентский запрос.

Чтобы использовать в своих интересах эту функциональность, Ваш сервер прокси должен быть
сконфигурированный, чтобы передать эти головные части к серверу Neo4j. Отказ передать
и X-Forwarded-Host и головные части X-Forwarded-Proto будут следовать оригиналом
основной используемый URI.

22.2.6. Другие параметры конфигурации

22.2.6.1. Включение журналированию от сборщика мусора

Чтобы получить журналирование набора мусора выводит Вас, должны передать соответствие
опция к исполнимой программе JVM сервера, приводя в движение conf/neo4j-wrapper.conf
значение

wrapper.java.additional.3=-Xloggc:data/log/neo4j-gc.log

Эта строка уже присутствует и некомментарий потребностей. Заметьте также, что журналирование
не направленный к консоли; Вы обнаружите операторы журналирования в data/log/
ne4j-gc.log или безотносительно каталога Вы устанавливаете в опции.

22.2.6.2. Отключение консоли вводит Webadmin

Вы, для соображений безопасности, можете хотеть отключить Shell Neo4j в Webadmin.
Оболочки позволяют произвольное выполнение кода, и таким образом, они могли составить безопасность
рискните, если Вы не доверяете всем пользователям своего Сервера Neo4j.

В conf/neo4j-server.properties файле:

#, Чтобы отключить все оболочки:
org.neo4j.server.manage.console_engines =

#, Чтобы включить только Shell Neo4j:
org.neo4j.server.manage.console_engines=shell

22.3. Настраивающаяся Производительность сервера

22.3.1. Определение характеристики настройки Neo4j
22.3.2. Определение характеристик настройки JVM

В основе сервера Neo4j регулярный экземпляр механизма хранения Neo4j.
Тот механизм может быть настроен таким же образом как другие встроенные конфигурации,
использование того же самого формата файла. Единственная разница - то, что сервер должен быть сказан
где обнаружить конфигурацию подстройки.

Быстрая информация

  * neo4j.properties файл - стандартный конфигурационный файл это базы данных
    загрузитесь, чтобы настроить их использование памяти и кэширующиеся стратегии.
  * См. Раздел 22.6, “Кэши в Neo4j” для получения дополнительной информации.

22.3.1. Определение характеристики настройки Neo4j

conf/neo4j-server.properties файл в распределении сервера, основное
конфигурационный файл для сервера. В этом файле мы можем определить секунду
файл свойств, который содержит настройки настраивающегося базы данных (то есть,
файл neo4j.properties). Это сделано, устанавливая единственное свойство, чтобы указать на a
допустимый neo4j.properties файл:

org.neo4j.server.db.tuning.properties = {neo4j.properties файл}

При запускании повторно сервера настраивающиеся улучшения, определенные в
файл neo4j.properties будет загружен и сконфигурирован в базовое
механизм базы данных.

22.3.2. Определение характеристик настройки JVM

Настраивание автономного сервера достигнуто, редактируя neo4j-wrapper.conf файл
в conf каталоге NEO4J_HOME.

Отредактируйте следующие свойства:

Табличные 22.1. neo4j-wrapper.conf характеристики настройки JVM

Значение Имени свойства
размер "кучи" начальной буквы wrapper.java.initmemory (в Мбайте)

размер "кучи" максимума wrapper.java.maxmemory (в Мбайте)

wrapper.java.additional. N дополнительный литеральный параметр JVM, где N - номер
                          для каждого


Для получения дополнительной информации по характеристикам настройки, см. Раздел 22.8, “Настройки JVM”
.

22.4. Руководство по производительности

22.4.1. Попробуйте это сначала
22.4.2. Жизненный цикл примитивов Neo4j
22.4.3. Конфигурирование Neo4j

Это - руководство по производительности Neo4j. Это попытается дать Вам указания на
как использовать Neo4j, чтобы достигнуть максимальной производительности.

22.4.1. Попробуйте это сначала

Первая вещь состоит в том, чтобы удостовериться, что JVM работает хорошо и не тратит также
много времени в наборе мусора. Контроль использования "кучи" приложения это
использование Neo4j может немного сбить с толку начиная с Neo4j, увеличит размер кэшей
если есть доступная память и уменьшение, если "куча" получает полной. Цель
должен иметь достаточно большую "кучу", столь тяжелая / максимальная нагрузка не будет следовать так называемым
Повреждение GC (производительность может отбросить целых два заказов величины когда
это происходит).

Запустите JVM с - флаг сервера и-Xmx <хорошая размерная "куча"> (f.ex.-Xmx512M для
Память 512 МБ или-Xmx3G для памяти на 3 Гбита). Наличие слишком большой "кучи" может также причинить боль
производительность, таким образом, Вам, вероятно, придется испытать некоторые различные размеры "кучи". Удостоверьтесь a
параллельный/параллельный сборщик мусора работает (-XX: + работы UseConcMarkSweepGC
хорошо в большинстве примеров использования).

Наконец удостоверьтесь, что ОС имеет некоторую память в запасе, чтобы управлять присущей файловой системой
кэши. Это означает, если у Вашего сервера есть 8 Гбайт RAM, не используют всю ту RAM для
"куча" (если Вы не выключили буферы с отображенной памятью), но оставляет хорошую часть
из этого к ОС. Для получения дополнительной информации по этому см. Главу 22, Конфигурацию &
Производительность.

Для Linux определенные тонкие настройки, см. Раздел 22.12, “Руководство по Производительности Linux”.

22.4.2. Жизненный цикл примитивов Neo4j

Neo4j управляет своими примитивами (вершины, отношения и свойства) отличающийся
в зависимости от того, как Вы используете Neo4j. Например, если Вы никогда не получаете свойство от a
определенная вершина или отношение, что у вершины или отношения не будет
свойства загружались в память. В первый раз, после загрузки вершины или
отношение, что к любому свойству получают доступ все свойства, загружено для
тот объект. Если какое-либо из тех свойств содержит массив, более многочисленный чем некоторые
элементы или длинная строка такие значения загружены по требованию, запрашивая их
индивидуально. Точно так же отношения вершины будут только загружены первое
время их требуют на ту вершину.

Вершины и отношения кэшируются, используя кэши LRU. Если Вы (для некоторых странных
причина), только работают с вершинами, кэш отношения станет более малым и
более малый, в то время как кэшу вершины позволяют вырасти (если нужно). Работа со многими
отношения и немного вершин следуют большим кэшем отношения и более малый
кэш вершины.

Спецификация API Neo4j ничего не говорит о порядке относительно
отношения настолько вызывающий Node.getRelationships () могут возвратить отношения
в различном порядке чем предыдущий вызов. Это позволяет нам делать даже
более тяжелая оптимизация, возвращая отношения, которые являются обычно
пересеченный.

В целом Neo4j был разработан, чтобы быть очень адаптивным в зависимости от того, как это
используемый. (Недостижимая) полная цель состоит в том, чтобы быть в состоянии обработать любое поступление
работа, не имея необходимость терять работоспособность и работать с уровнем ввода-вывода файла/диска.

22.4.3. Конфигурирование Neo4j

В Главе 22 Конфигурации & Производительности страница там - информация о как к
сконфигурируйте Neo4j и JVM. Эти настройки оказывают много влияния на
производительность.

22.4.3.1. Диски, RAM и другие подсказки

Так всегда, как с любым решением для персистентности, производительность зависит много от
носители персистентности используются. Лучшие диски приравнивают лучшую производительность.

Если у Вас есть разнообразные диски или носители персистентности, доступные, это может быть хорошая идея
разделять файлы хранилища и журналы транзакций через те диски. Наличие
файлы хранилища, работающие на дисках с низким, ищут, время может сделать чудеса для некэшируемого
считайте операции. Сегодня у типичного механического диска есть среднее число, ищут время
приблизительно 5 мс, это может заставить запрос или обход быть очень медленным когда
доступное количество RAM слишком мало или конфигурация для кэшей и памяти
отображение плохо. У включенного SSD нового хорошего SATA есть среднее число, ищут время <100
микросекунды, означающие те сценарии, выполнятся по крайней мере в 50 раз быстрее.

Чтобы избежать поражать диск, Вы нуждаетесь в большем количестве RAM. На стандартном механическом диске Вы можете
графики дескриптора с несколькими десятками миллионов примитивов с 1-2GB из RAM.
4-8GB из RAM может обработать графики с сотнями миллионов примитивов в то время как
Вы нуждаетесь в хорошем сервере с 16-32GB, чтобы обработать миллиарды примитивов. Однако,
если Вы вложите капитал в хороший SSD, то Вы будете в состоянии обработать намного большие графики на
меньше RAM.

Используйте инструменты как vmstat или эквивалентный, чтобы собрать информацию когда Ваше приложение
работает. Если у Вас есть высокий ввод-вывод, ожидает и не что много блоков, идущих/в в
диски, когда рабочие транзакции записи-чтения это - знак, что Вы должны настроить
Ваша "куча" Java, кэш Neo4j и настройки отображения памяти (возможно даже добираются больше
RAM или лучшие диски).

22.4.3.2. Запишите производительность

Если Вы испытываете плохую производительность записи после записи некоторых данных
(первоначально причал, тогда массивное замедление) это может быть операционная система, которая является
выписывание грязного нумерует страницу от областей с отображенной памятью файлов хранилища.
Эти области не должны быть выписаны, чтобы поддержать непротиворечивость так к
достигните максимально возможной скорости записи, что типа поведения нужно избежать.

Другой источник записывает замедление, может быть размер транзакции. Многие малая величина
результат транзакций в большом количестве ввода-вывода пишет в диск и должен избежаться. Также
большие транзакции могут следовать погрешностями OutOfMemory, начиная с незафиксированного
данные транзакции сохранены на "Куче" Java в памяти. Для получения дополнительной информации о
управление транзакцией в Neo4j, пожалуйста, см. Главу 16, управление Транзакцией.

Ядро Neo4j использует несколько файлов хранилища и логический файл системного журнала к
сохраните график на диске. Файлы хранилища содержат фактический график и журнал
содержит операции изменения. Все записи к логическому журналу только добавлены
и когда транзакция передана, изменения к логическому журналу будут вынуждены
(fdatasync) вниз, чтобы обработать почву дисковым культиватором. Файлы хранилища однако не сброшены, чтобы обработать почву дисковым культиватором и
записи им не только добавлены также. Они будут записаны в больше или
менее хаотичная картина (в зависимости от расположения графика) и записи не будет вынуждена
чтобы обработать почву дисковым культиватором до, журнал повернут, или ядро Neo4j - выключение.

Так как случайные записи к областям с отображенной памятью для файлов хранилища могут произойти это
очень важно, который данные не получают выписанными, чтобы дисковать если не необходимый.
У некоторых операционных систем есть очень агрессивные настройки относительно того, когда записать
они грязные нумеруют страницу, чтобы обработать почву дисковым культиватором. Если ОС решает начать грязную запись
нумерует страницу этих областей с отображенной памятью, запишите, что доступ к диску прекратит быть
последовательный и становятся случайными. Это повреждает производительность много, так получить максимальным
запишите, что производительность при использовании Neo4j удостоверяется, что ОС сконфигурирован, чтобы не записать
любой из грязных нумерует страницу вызванный записями к областям с отображенной памятью
храните файлы. Как пример, если у машины есть 8 Гбайт RAM и полный размер
файлы хранилища составляют 4 Гбайт (полностью с отображенной памятью), ОС должен быть сконфигурирован к
примите грязных по крайней мере 50 %, нумерует страницу в виртуальной памяти, чтобы удостовериться, что мы не добираемся
случайные записи диска.

Замечание

Удостоверьтесь, что считали Раздел 22.12, “Руководство по Производительности Linux” также для больше
определенная информация.

22.4.3.3. Второе кэширование уровня

В то время как обычно создавание приложений и “всегда предполагает, что график находится в
память”, иногда необходимо оптимизировать определенную критическую производительность
разделы. Neo4j прибавляет малые издержки даже если вершина, отношение или
рассматриваемое свойство кэшируется по сравнению со структурами данных в памяти. Если это
становится проблемой, используйте копировально-фрезерный станок, чтобы обнаружить эти места сильной ликвации и затем прибавить Ваше собственное
кэширование второго уровня. Мы полагаем, что к кэшированию второго уровня нужно избежать
самая большая степень, возможная, так как это вынудит Вас, чтобы заботиться об аннулировании
который иногда может быть твердым. Но когда все остальное перестало работать, Вы должны использовать это
таким образом, вот пример того, как он может быть сделан.

У нас есть некоторый POJO что wrapps вершина, содержащая ее состояние. В этом определенном POJO
мы переопределили, приравнивает реализацию.

   булева общественность приравнивает (Возразите obj),
   {
       возвратите underlyingNode.getProperty ("some_property").equals (obj);
   }

   общедоступный интервал hashCode ()
   {
       возвратите underlyingNode.getProperty ("some_property").hashCode ();
   }

Это хорошо работает в большинстве сценариев, но в этом определенном сценарии многие
экземпляры того POJO работаются с во вложенных циклах adding/removing/
получение/обнаружение к классам набора. Профилирование приложений покажет
то, что приравнивает реализацию, вызывают много раз и может быть просмотрен как
место сильной ликвации. Добавление кэширования второго уровня для приравнивает переопределение, будет в этом
определенная производительность увеличения сценария.

    частный Объект cachedProperty = нуль;

    булева общественность приравнивает (Возразите obj),
    {
       если (cachedProperty == нуль)
       {
           cachedProperty = underlyingNode.getProperty ("some_property");
       }
       возвратите cachedProperty.equals (obj);
    }

    общедоступный интервал hashCode ()
    {
       если (cachedPropety == нуль)
       {
           cachedProperty = underlyingNode.getProperty ("some_property");
       }
       возвратите cachedProperty.hashCode ();
    }

Проблема с этим состоит в том, что теперь мы должны лишить законной силы кэшируемое свойство
всякий раз, когда some_property изменен (возможно, не проблема в этом сценарии с тех пор
состояние, выбранное для, приравнивает, и вычисление кода хеша часто не будет изменяться).

Подсказка

Чтобы подвести итог, избегите кэширования второго уровня, если возможный и только прибавляют это когда Вы
действительно нуждаюсь в этом.

22.5. Конфигурация ядра

Они - параметры конфигурации, которые Вы можете передать к neo4j ядру. Они могут
или быть переданным как карта при использовании встроенной базы данных, или в
файл neo4j.properties при использовании Сервера Neo4j.

Таблица 22.2. Все хранилища подсчитывают размер расширенной памяти

+-----------------------------------------------------------------------------+
Значение |Default: 524288000 |
|-----------------------------------------------------------------------------|
|all_stores_total_mapped_memory_size |
|                                                                             |
|The доводят до требуемого размера, чтобы выделить для пула отображения памяти, который будет совместно использован всеми |
|stores. |
+-----------------------------------------------------------------------------+


Таблица 22.3. Позвольте обновление хранилища

+-----------------------------------------------------------------------------+
Значение |Default: ложь |
|-----------------------------------------------------------------------------|
|allow_store_upgrade |
|                                                                             |
|Whether, чтобы позволить хранилище обновляют в случае, если текущая версия базы данных |
|starts против более старой версии хранилища. Установка этого к истине не делает |
Успешное обновление |guarantee, только что это позволяет попытку этого. |
+-----------------------------------------------------------------------------+


Таблица 22.4. Размер блока массива

+-----------------------------------------------------------------------------+
Значение |Default: 120 |
|-----------------------------------------------------------------------------|
|array_block_size |
|                                                                             |
|Specifies размер блока для того, чтобы сохранить массивы. Этот параметр только соблюдают |
|when хранилище создается, иначе оно игнорируется. Размер блока значения по умолчанию |
|120 байтов, и издержки каждого блока являются тем же самым что касается строковых блоков, |
|i.e., 8 байтов. |
+-----------------------------------------------------------------------------+


Таблица 22.5. Резервное ведомое устройство

+-------------------------------------+
Значение |Default: ложь |
|-------------------------------------|
|backup_slave |
|                                     |
|Mark эта база данных как резервное ведомое устройство. |
+-------------------------------------+


Таблица 22.6. Тип кэша

+-----------------------------------------------------------------------------+
Значение |Default: мягкий |
|-----------------------------------------------------------------------------|
|cache_type |
|                                                                             |
Тип |The кэша, чтобы использовать для вершин и отношений. Заметьте что Neo4j |
У Выпуска |Enterprise есть дополнительный 'hpc' тип кэша (Эффективный |
|Cache). См. главу по кэшам в справочнике для получения дополнительной информации. |
+-----------------------------------------------------------------------------+


Таблица 22.7. Версия синтаксического анализатора кода

+-----------------------------------------------------------+
|cypher_parser_version |
|                                                           |
|Enable это, чтобы определить синтаксический анализатор кроме значения по умолчанию один. |
+-----------------------------------------------------------+


Таблица 22.8. Конфигурация дампа

+----------------------------------------------------------+
Значение |Default: ложь |
|----------------------------------------------------------|
|dump_configuration |
|                                                          |
|Print эффективная конфигурация Neo4j после запуска. |
+----------------------------------------------------------+


Таблица 22.9. Принудительный идентификатор ядра

+-----------------------------------------------------------------------------+
|forced_kernel_id |
|                                                                             |
Идентификатор |An, который однозначно определяет этот экземпляр базы данных графика в пределах |
JVM |this. Значения по умолчанию к автоматически сгенерированному номеру, в зависимости от сколько экземпляра |
|are запускался в этой JVM. |
+-----------------------------------------------------------------------------+


Таблица 22.10. Порог монитора Gc

+-----------------------------------------------------------------------------+
Значение |Default: 200 |
|-----------------------------------------------------------------------------|
|gc_monitor_threshold |
|                                                                             |
Количество времени |The в мс поток монитора должно быть блокировано прежде, чем зарегистрировать |
Сообщение |a это было блокировано. |
+-----------------------------------------------------------------------------+


Таблица 22.11. Монитор Gc ожидает время

+-----------------------------------------------------------------------------+
Значение |Default: 100 |
|-----------------------------------------------------------------------------|
|gc_monitor_wait_time |
|                                                                             |
|Amount времени в мс поток монитора GC будет ожидать прежде, чем взять другого |
|measurement. |
+-----------------------------------------------------------------------------+


Таблица 22.12. Транзакции фиксации прерывания

+-----------------------------------------------------------------------------+
Значение |Default: ложь |
|-----------------------------------------------------------------------------|
|intercept_committing_transactions |
|                                                                             |
|Determines, загружался ли какой-либо TransactionInterceptors, прервет подготовленный |
|transactions прежде, чем они достигнут логического журнала. |
+-----------------------------------------------------------------------------+


Таблица 22.13. Прервите десериализованные транзакции

+-----------------------------------------------------------------------------+
Значение |Default: ложь |
|-----------------------------------------------------------------------------|
|intercept_deserialized_transactions |
|                                                                             |
|Determines, загружался ли какой-либо TransactionInterceptors, прервет |
|externally получал транзакции (например, в HA) прежде, чем они достигнут логического |
|log и применены к хранилищу. |
+-----------------------------------------------------------------------------+


Таблица 22.14. Сохраните логические журналы

+-----------------------------------------------------------------------------+
Значение |Default: истина |
|-----------------------------------------------------------------------------|
|keep_logical_logs |
|                                                                             |
|Make Neo4j сохраняют логические журналы транзакций для возможности сделать копию |
|database. Может использоваться для того, чтобы определить порог, чтобы подрезать логические журналы |
|after. Например "10 дней" подрежут логические журналы, который только делится без остатка |
|transactions, более старый чем 10 дней с текущего времени, или "100 k txs", будет |
|keep 100 k самых последних транзакций и сливы любые более старые транзакции. |
+-----------------------------------------------------------------------------+


Таблица 22.15. Размер блока меток

+-----------------------------------------------------------------------------+
Значение |Default: 60 |
|-----------------------------------------------------------------------------|
|label_block_size |
|                                                                             |
|Specifies размер блока для того, чтобы сохранить метки, превышающие, встраивал пространство в вершине |
|record. Этот параметр только соблюдают, когда хранилище создается, иначе |
|it игнорируется. Размер блока значения по умолчанию составляет 60 байтов, и издержки каждого |
|block - то же самое что касается строковых блоков, то есть, 8 байтов. |
+-----------------------------------------------------------------------------+


Таблица 22.16. Зарегистрируйте расширенную память stats

+------------------------------------------------------+
Значение |Default: ложь |
|------------------------------------------------------|
|log_mapped_memory_stats |
|                                                      |
|Tell Neo4j, чтобы регулярно зарегистрировать статистику отображения памяти. |
+------------------------------------------------------+


Таблица 22.17. Зарегистрируйте расширенную память stats имя файла

+-----------------------------------------------------------+
Значение |Default: mapped_memory_stats.log |
|-----------------------------------------------------------|
|log_mapped_memory_stats_filename |
|                                                           |
Файл |The, где Neo4j запишет статистику отображения памяти. |
+-----------------------------------------------------------+


Таблица 22.18. Зарегистрируйте расширенную память stats интервал

+-----------------------------------------------------------------------------+
Значение |Default: 1000000 |
|-----------------------------------------------------------------------------|
|log_mapped_memory_stats_interval |
|                                                                             |
Номер |The записей, которые будут загружены между регулярным журналированием отображения памяти |
|statistics. |
+-----------------------------------------------------------------------------+


Таблица 22.19. Logging.threshold для вращения

+-----------------------------------------------------------------------------+
Значение |Default: 104857600 |
|-----------------------------------------------------------------------------|
|logging.threshold_for_rotation |
|                                                                             |
|Threshold в байтах для того, когда база данных регистрирует (текстовые журналы, для того, чтобы отладить, который является), |
|are вращался. |
+-----------------------------------------------------------------------------+


Таблица 22.20. Логический журнал

+-----------------------------------------------------------------------------+
Значение |Default: nioneo_logical.log |
|-----------------------------------------------------------------------------|
|logical_log |
|                                                                             |
Базовое имя |The для логических файлов системного журнала, или абсолютный путь или относительное число |
|to установка store_dir. Это не должно обычно быть изменено. |
+-----------------------------------------------------------------------------+


Таблица 22.21. Логический порог вращения журнала

+-----------------------------------------------------------------------------+
Значение |Default: 26214400 |
|-----------------------------------------------------------------------------|
|logical_log_rotation_threshold |
|                                                                             |
|Specifies, в котором размере файла будет самовращаться логический журнал. 0 средств это |
Вращение |no автоматически произойдет основанное на размере файла. Значение по умолчанию 25M |
+-----------------------------------------------------------------------------+


Таблица 22.22. Размер кэша искателя Lucene

+--------------------------------------------------------------------------+
Значение |Default: 2147483647 |
|--------------------------------------------------------------------------|
|lucene_searcher_cache_size |
|                                                                          |
Значение |Integer, которое устанавливает максимальное число открытого lucene, индексирует искателей. |
+--------------------------------------------------------------------------+


Таблица 22.23. Размер страницы расширенной памяти

+---------------------------------------+
Значение |Default: 1048576 |
|---------------------------------------|
|mapped_memory_page_size |
|                                       |
Размер |Target для нумерует страницу расширенной памяти. |
+---------------------------------------+


Таблица 22.24. Нео хранилище

+-----------------------------------------------------------------------------+
Значение |Default: neostore |
|-----------------------------------------------------------------------------|
|neo_store |
|                                                                             |
Базовое имя |The для Neo4j Хранит файлы, или абсолютный путь или относительное число |
|to установка store_dir. Это не должно обычно быть изменено. |
+-----------------------------------------------------------------------------+


Таблица 22.25. Память Neostore.nodestore.db.mapped

+-------------------------------------------------------+
Значение |Default: 20971520 |
|-------------------------------------------------------|
|neostore.nodestore.db.mapped_memory |
|                                                       |
|The доводят до требуемого размера, чтобы выделить для памяти, отображающей хранилище вершины. |
+-------------------------------------------------------+


Таблица 22.26. Память Neostore.propertystore.db.arrays.mapped

+-----------------------------------------------------------------+
Значение |Default: 136314880 |
|-----------------------------------------------------------------|
|neostore.propertystore.db.arrays.mapped_memory |
|                                                                 |
|The доводят до требуемого размера, чтобы выделить для памяти, отображающей хранилище свойства массива. |
+-----------------------------------------------------------------+


Таблица 22.27. Neostore.propertystore.db.index.keys.mapped память

+---------------------------------------------------------------------------+
Значение |Default: 1048576 |
|---------------------------------------------------------------------------|
|neostore.propertystore.db.index.keys.mapped_memory |
|                                                                           |
|The доводят до требуемого размера, чтобы выделить для памяти, отображающей хранилище для ключевых строк свойства. |
+---------------------------------------------------------------------------+


Таблица 22.28. Память Neostore.propertystore.db.index.mapped

+---------------------------------------------------------------------------+
Значение |Default: 1048576 |
|---------------------------------------------------------------------------|
|neostore.propertystore.db.index.mapped_memory |
|                                                                           |
Размер |The, чтобы выделить для памяти, отображающей хранилище для ключа свойства, индексирует. |
+---------------------------------------------------------------------------+


Таблица 22.29. Память Neostore.propertystore.db.mapped

+-----------------------------------------------------------------+
Значение |Default: 94371840 |
|-----------------------------------------------------------------|
|neostore.propertystore.db.mapped_memory |
|                                                                 |
|The доводят до требуемого размера, чтобы выделить для памяти, отображающей хранилище значения свойства. |
+-----------------------------------------------------------------+


Таблица 22.30. Память Neostore.propertystore.db.strings.mapped

+------------------------------------------------------------------+
Значение |Default: 136314880 |
|------------------------------------------------------------------|
|neostore.propertystore.db.strings.mapped_memory |
|                                                                  |
|The доводят до требуемого размера, чтобы выделить для памяти, отображающей строковое хранилище свойства. |
+------------------------------------------------------------------+


Таблица 22.31. Память Neostore.relationshipstore.db.mapped

+---------------------------------------------------------------+
Значение |Default: 104857600 |
|---------------------------------------------------------------|
|neostore.relationshipstore.db.mapped_memory |
|                                                               |
|The доводят до требуемого размера, чтобы выделить для памяти, отображающей хранилище отношения. |
+---------------------------------------------------------------+


Таблица 22.32. Вершина автоматическая индексация

+-----------------------------------------------------------------------------+
Значение |Default: ложь |
|-----------------------------------------------------------------------------|
|node_auto_indexing |
|                                                                             |
|Controls автоматическая функция индексации вершин. Установка в ложь завершает работу этого, |
Истина |while включает этому по умолчанию для свойств, перечисленных в |
Установка |node_keys_indexable. |
+-----------------------------------------------------------------------------+


Таблица 22.33. Индексируемые ключи вершины

+-----------------------------------------------------------------------------+
|node_keys_indexable |
|                                                                             |
Список |A имен свойства (разделенная запятая), который будет индексирован по умолчанию. |
|This применяется к Вершинам только. |
+-----------------------------------------------------------------------------+


Таблица 22.34. Размер кэша запроса

+-----------------------------------------------------------------------+
Значение |Default: 100 |
|-----------------------------------------------------------------------|
|query_cache_size |
|                                                                       |
|Used, чтобы определить номер Кода запрашивают схемы выполнения, которые кэшируются. |
+-----------------------------------------------------------------------+


Таблица 22.35. База данных только для чтения

+-----------------------------------------------------------------------------+
Значение |Default: ложь |
|-----------------------------------------------------------------------------|
|read_only |
|                                                                             |
|Only позволяют операции чтения от этого экземпляра Neo4j. Этот режим все еще требует |
Доступ |write к каталогу для блокировки имеет целью |
+-----------------------------------------------------------------------------+


Таблица 22.36. Восстановите idgenerators причал

+-----------------------------------------------------------------------------+
Значение |Default: истина |
|-----------------------------------------------------------------------------|
|rebuild_idgenerators_fast |
|                                                                             |
|Use быстрый подход для того, чтобы восстановить генераторы ID. Эта усадка, более быстрая |
Время |recovery, но ограничит возможность повторно использовать пространство стертых |
|entities. |
+-----------------------------------------------------------------------------+


Таблица 22.37. Отношение автоматическая индексация

+-----------------------------------------------------------------------------+
Значение |Default: ложь |
|-----------------------------------------------------------------------------|
|relationship_auto_indexing |
|                                                                             |
|Controls автоматическая функция индексации отношений. Установка в ложь закрывается |
|it вниз, в то время как истина включает этому по умолчанию для свойств, перечисленных в |
Установка |relationship_keys_indexable. |
+-----------------------------------------------------------------------------+


Таблица 22.38. Размер захвата отношения

+---------------------------------------------------------+
Значение |Default: 100 |
|---------------------------------------------------------|
|relationship_grab_size |
|                                                         |
|How много отношений, чтобы читать за один раз во время итерации |
+---------------------------------------------------------+


Таблица 22.39. Индексируемые ключи отношения

+-----------------------------------------------------------------------------+
|relationship_keys_indexable |
|                                                                             |
Список |A имен свойства (разделенная запятая), который будет индексирован по умолчанию. |
|This применяется к Отношениям только. |
+-----------------------------------------------------------------------------+


Таблица 22.40. Удаленное журналирование включено

+----------------------------------------------------+
Значение |Default: ложь |
|----------------------------------------------------|
|remote_logging_enabled |
|                                                    |
|Whether, чтобы позволить регистрировать к удаленному серверу или нет. |
+----------------------------------------------------+


Таблица 22.41. Удаленный узел журналирования

+-----------------------------------------------------+
Значение |Default: 127.0.0.1 |
|-----------------------------------------------------|
|remote_logging_host |
|                                                     |
|Host для удаленного использования журналирования LogBack SocketAppender. |
+-----------------------------------------------------+


Таблица 22.42. Удаленный порт журналирования

+-----------------------------------------------------+
Значение |Default: 4560 |
|-----------------------------------------------------|
|remote_logging_port |
|                                                     |
|Port для удаленного использования журналирования LogBack SocketAppender. |
+-----------------------------------------------------+


Таблица 22.43. dir хранилища

+---------------------------------------------------+
|store_dir |
|                                                   |
Каталог |The, где файлы базы данных расположены. |
+---------------------------------------------------+


Таблица 22.44. Строковый размер блока

+-----------------------------------------------------------------------------+
Значение |Default: 120 |
|-----------------------------------------------------------------------------|
|string_block_size |
|                                                                             |
|Specifies размер блока для того, чтобы сохранить строки. Этот параметр только соблюдают |
|when хранилище создается, иначе оно игнорируется. Заметьте что каждый символ |
|in строка занимает два байта, означая что размер блока 120 (значение по умолчанию |
|size), будет содержать 60 символов, долго представляют в виде строки прежде, чем переполниться в секунду |
|block. Также заметьте что каждый групповые переносы издержки 8 байтов. Это означает |
|that, если размер блока 120, размер сохраненных записей, будет 128 |
|bytes. |
+-----------------------------------------------------------------------------+


Таблица 22.45. Менеджер Tx impl

+-----------------------------------------------------------------------------+
Значение |Default: собственный |
|-----------------------------------------------------------------------------|
|tx_manager_impl |
|                                                                             |
Имя |The менеджера по Транзакции служба, чтобы использовать как определено в ТМ |
Строитель провайдера |service. |
+-----------------------------------------------------------------------------+


Таблица 22.46. Используйте буферы с отображенной памятью

+-----------------------------------------------------------------------------+
Значение |Default: истина |
|-----------------------------------------------------------------------------|
|use_memory_mapped_buffers |
|                                                                             |
|Tell Neo4j, чтобы использовать буферы с отображенной памятью для того, чтобы получить доступ к собственному хранению |
|layer. |
+-----------------------------------------------------------------------------+


22.6. Кэши в Neo4j

22.6.1. Буферный кэш файла
22.6.2. Объектный кэш

Для того, как обеспечить пользовательскую конфигурацию для Neo4j, см. Раздел 22.1,
"Введение".

Neo4j использует два различных типов кэшей: буферный кэш файла и объект
кэш. Буферный кэш файла кэширует данные файла хранения в том же самом формате как
это сохранено на долговечных носителях. Объектный кэш кэширует вершины,
отношения и свойства в формате, который оптимизирован для высокого обхода
скорости и транзакционные записи.

22.6.1. Буферный кэш файла

Быстрая информация

  * буферный кэш файла иногда вызывают низкоуровневым кэшем или файловой системой
    кэш.
  * Это кэширует данные Neo4j как сохраненный на долговечных носителях.
  * Это использует функции отображения памяти операционной системы когда возможный.
  * Neo4j сконфигурирует кэш автоматически пока размер "кучи"
    JVM сконфигурирована должным образом.

Буферный кэш файла кэширует данные Neo4j в том же самом формате, как это
представленный на долговечных носителях. Цель этого уровня кэша к
улучшите и чтение и производительность записи. Буферный кэш файла улучшает запись
производительность при записи в кэш и задерживая долговечную запись до
логический журнал повернут. Это поведение безопасно, так как все транзакции всегда
длительно записанный логическому журналу, который может использоваться, чтобы восстановить хранилище
файлы в случае катастрофического отказа.

Так как работа кэша плотно связана с данными, которые это хранит, a
краткое описание долговечного формата представления Neo4j необходимо
фон. Neo4j хранит данные в разнообразных файлах и полагается на базовое
файловая система, чтобы обработать это эффективно. Каждый файл хранения Neo4j делится без остатка
универсальные записи фиксированного размера определенного типа:

Содержание Записи файла хранилища
                                    размер
neostore.nodestore.db 14 Вершин B

neostore.relationshipstore.db 33 Отношения B

neostore.propertystore.db 41 Свойство B для вершин
                                         и отношения

neostore.propertystore.db.strings 128 Значений B строки
                                         свойства

neostore.propertystore.db.arrays 128 Значений B массива
                                         свойства

Для строк и массивов, где данные могут иметь переменную длину, данные хранятся в
один или более 120B блоки, с 8B записывают издержки. Размеры этих блоков могут
фактически будьте сконфигурированы, когда хранилище создается, используя string_block_size
и параметры array_block_size. Размер каждого типа записи может также использоваться
вычислить требования хранения графика Neo4j или соответствующего кэша
размер для каждого файла буферизует кэш. Заметьте, что некоторые строки и массивы могут быть
сохраненный, не используя строковое хранилище или хранилище массива соответственно, см.
Раздел 22.9, “Сжатое хранение коротких строк” и Раздела 22.10,
“Сжатое хранение коротких массивов”.

Neo4j использует разнообразные буферные кэши файла, один для каждого различного файла хранения.
Каждый буферный кэш файла делит свой файл хранения на много одинаково доведенные до требуемого размера
окна. Каждое окно кэша содержит четное число записей хранения.
кэш содержит самые активные окна кэша в памяти и отслеживает хит по сравнению с пропуском
отношение для окон. Когда коэффициент совпадения некэшируемого окна получает более высоким
чем отношение пропуска кэшируемого окна кэшируемое окно получает выселенным и
ранее некэшируемое окно кэшируется вместо этого.

Важный

Заметьте, что размеры блока могут только быть сконфигурированы во время создания хранилища.

22.6.1.1. Конфигурация

Параметр Возможный Эффект
                                                   значения
истина use_memory_mapped_buffers или Если установлено в истину
                                                   ложный Neo4j будет использовать
                                                             операционные системы
                                                             отображение памяти
                                                             функциональность для
                                                             буфер файла
                                                             окна кэша. Если
                                                             набор к ложному Neo4j
                                                             будет использовать его собственное
                                                             буфер
                                                             реализация. В
                                                             этот случай
                                                             буферы будут находиться
                                                             в "куче" JVM
                                                             который должен быть
                                                             увеличенный
                                                             соответственно.
                                                             значение по умолчанию для
                                                             этот параметр
                                                             истина, за исключением
                                                             Windows.

neostore.nodestore.db.mapped_memory максимальное количество
                                                             из памяти, чтобы использовать
                                                             для буфера файла
                                                             кэш вершины
                                                             файл хранения.

neostore.relationshipstore.db.mapped_memory максимальное количество
                                                             из памяти, чтобы использовать
                                                             для буфера файла
                                                             кэш
                                                             хранилище отношения
                                                      Файл.
                                                    максимум
neostore.propertystore.db.index.keys.mapped_memory количество максимального количества
                                                   память к памяти, чтобы использовать
                                                    используйте для для буфера файла
                                                    кэш-память
                                                    отображенный что-то - что-то
                                                    буферный файл.
                                                   для этого
neostore.propertystore.db.index.mapped_memory регистрируют максимальное количество
                                                    буфер памяти, чтобы использовать
                                                    кэш. для буфера файла
                                                      Кэш
                                                    примите значение по умолчанию что-то - что-то
                                                    модуль - файл.
                                                   Мебибайт, для
neostore.propertystore.db.mapped_memory другой максимальное количество
                                                   использование модулей памяти, чтобы использовать
                                                    любой из для буфера файла
                                                      кэш
                                                   следующее хранение свойства
                                                   суффиксы: файл.
                                                    B, k, М.
neostore.propertystore.db.strings.mapped_memory или Г. Максимальное количество
                                                             из памяти, чтобы использовать
                                                             для буфера файла
                                                             кэш строки
                                                             хранение свойства
                                                             файл.

neostore.propertystore.db.arrays.mapped_memory максимальное количество
                                                             из памяти, чтобы использовать
                                                             для буфера файла
                                                             кэш массива
                                                             хранение свойства
                                                             файл.

string_block_size Определяет блок
                                                             размер для того, чтобы сохранить
                                                             строки. Это
                                                             параметр только
                                                             соблюдаемый, когда
                                                             хранилище создается,
                                                             иначе это
                                                             игнорируемый. Заметьте это
                                                             каждый символ в a
                                                             строка занимает два
                                                             байты, означая это
                                                             размер блока 120
                                                             (размер значения по умолчанию)
                                                             будет содержать 60
                                                             символ долго
                                                             строка прежде
                                                             переполнение в a
                                                             второй блок. Также
                                                             заметьте что каждый
                                                      Групповые переносы
                                                   номер издержек 8
                                                   байты на байты. Это означает
                                                    блок. это, если блок
                                                             размер 120,
                                                             размер сохраненного
                                                             записи будут 128
                                                             байты.

array_block_size Определяет блок
                                                             размер для того, чтобы сохранить
                                                             массивы. Это
                                                             параметр только
                                                             соблюдаемый, когда
                                                             хранилище создается,
                                                             иначе это
                                                             игнорируемый.
                                                             размер блока значения по умолчанию
                                                             120 байтов, и
                                                             издержки
                                                             каждый блок
                                                             то же самое что касается строки
                                                             блоки, то есть, 8
                                                             байты.

истина dump_configuration или Если установлено в истину
                                                   ложный ток
                                                             конфигурация
                                                             настройки будут
                                                             записанный
                                                             система значения по умолчанию
                                                             вывод, главным образом
                                                             консоль или
                                                             logfiles.

Когда буферы с отображенной памятью используются (use_memory_mapped_buffers = истина) "куча"
размер JVM должен быть более малым чем полная доступная память
компьютер, минус общая сумма памяти используется для буферов. Когда "куча"
буферы используются (use_memory_mapped_buffers = ложь) размер "кучи" JVM
должно быть достаточно большим, чтобы содержать все буферы, плюс память "кучи" времени выполнения
требования приложения и объектного кэша.

Читая параметры конфигурации на запуске Neo4j будет автоматически
сконфигурируйте параметры, которые не определены. Размеры кэша будут
сконфигурированный основанный на доступной памяти на компьютере, сколько используется
"куча" JVM, и насколько большой файлы хранения.

22.6.2. Объектный кэш

Быстрая информация

  * объектный кэш иногда вызывают высокоуровневым кэшем.
  * Это кэширует данные Neo4j в форме, оптимизированной для быстрого обхода.

Объектные вершины единичного кэшей кэша и отношения и их свойства
в форме, которая оптимизирована для быстрого обхода графика. Есть два
различные категории объектных кэшей в Neo4j.

Есть ссылочные кэши. Здесь Neo4j использует столько, сколько он может из
выделенная память "кучи" для JVM для объектного кэширования и полагается на мусор
набор для замещения из кэша способом LRU. Заметьте однако это
Neo4j "конкурирует" за пространство "кучи" с другими объектами в той же самой JVM,
такой, поскольку Ваше приложение, если развернуто во встроенном режиме, и Neo4j пустит
"победа" приложения при использовании меньшего количества памяти, если приложение нуждается больше.

Замечание

Эффективный Кэш, описанный ниже, только доступен в Neo4j
Enterprise Edition.

Другой Эффективный Кэш, который получает присвоенным определенное количество
пространство в "куче" JVM и очистит объектов всякий раз, когда это становится больше чем
это. Это присвоено максимальный объем памяти, который кэшировала сумма всех
объекты в этом не будут превышать. Объекты будут выселены из кэша когда
максимальный размер собирается быть достигнутым, вместо того, чтобы положиться на набор мусора
(GC), чтобы принять то решение. Здесь соревнование с другими объектами в "куче"
так же как паузами GC можно лучше управлять, так как кэш получает присвоенный a
максимальное использование пространства "кучи". Издержки Эффективного Кэша также
намного меньший так же как вставляют/поиск времена быстрее чем для ссылочных кэшей.

Подсказка

Использование памяти "кучи" является подчиненным сборщику мусора java  -  в зависимости от
тип кэша некоторые настраивание мог бы быть необходим, чтобы играть хорошо с GC в целом
размеры "кучи". Поэтому, присвоение большой "кучи" для пользы Neo4j’s не всегда
лучшая стратегия, поскольку это может привести к длинным паузам GC. Вместо этого оставьте некоторое пространство для
Кэши файловой системы Neo4j’s. Они за пределами "кучи" и под под
прямое управление ядра, которым таким образом более эффективно управляют.

Контент этого кэша - объекты с представлением, сцепленным к
поддержка Neo4j возражает обходы графика и API. Чтение из этого кэша
в 5 - 10 раз более быстро чем чтение из буферного кэша файла. Этот кэш
содержавший в "куче" JVM и размера адаптирован к текущему количеству
из доступной памяти "кучи".

Вершины и отношения прибавлены к объектному кэшу, как только они
полученный доступ. Кэшируемые объекты однако заполнены лениво. Свойства для a
вершина или отношение не загружены, пока к свойствам не получают доступ для той вершины
или отношение. Строка (и массив) свойства не загружена до этого
к определенному свойству получают доступ. Отношения для определенной вершины
также не загруженный, пока к отношениям не получают доступ для той вершины.

22.6.2.1. Конфигурация

Основной параметр конфигурации для объектного кэша - cache_type
параметр. Это определяет который реализация кэша использовать для объекта
кэш. Заметьте, что там будет существовать два экземпляра кэша, один для вершин и один
для отношений. Доступные типы кэша:

Описание cache_type
ни один не использует высокоуровневый кэш. Никакие объекты не будут кэшироваться.

мягкий Обеспечивает оптимальное использование доступной памяти. Соответствующий для
           высокопроизводительный обход. Может столкнуться с проблемами GC при высокой загрузке
           если части, к которым часто получают доступ, графика не вписываются
           кэш.

           Это - реализация кэша значения по умолчанию.

слабый Обеспечивает короткую продолжительность жизни для кэшируемых объектов. Соответствующий для высоко
           приложения пропускной способности, где большая часть графика чем
           к тому, что может вписаться в память, часто получают доступ.

сильный Этот кэш будет держаться за все данные, которые не получают загруженными в никогда
           выпустите это снова. Обеспечивает хорошую производительность, если Ваш график - малая величина
           достаточно умещаться в памяти.

hpc Эффективный Кэш. Обеспечивает средства присвоения определенного
           объем памяти, чтобы выделить кэшированию загруженных вершин и
           отношения. Малое место и быстрая вставка/поиск. Должен быть
           наилучший вариант для большинства сценариев. См. ниже на том, как сконфигурировать это.
           Заметьте, что эта опция только доступна в Neo4j Enterprise
           Выпуск.

22.6.2.2. Эффективный Кэш

Так как Эффективный Кэш работает с максимальным размером в JVM, это может
будьте сконфигурированы на вариант использования для оптимальной производительности. Есть два аспекта
размер кэша.

Каждый - размер массива, ссылающегося на объекты, которые помещены в кэш.
Это определено, поскольку часть "кучи", например определяя 5 пустит
тот сам массив приводит 5 % в рабочее состояние из всей "кучи". Увеличение этой фигуры (
к максимуму 10), понизит шанс хэш-коллизий за счет
больше "кучи" используется для этого. Больше коллизий означает больше избыточной загрузки объектов
от низкоуровневого кэша.

Описание параметра конфигурации (чем это управляет), Пример
                                                                        значение
Часть node_cache_array_fraction "кучи", чтобы выделить 7
                                  массив, сдерживающий вершины
                                  кэш (максимальные 10).

Часть relationship_cache_array_fraction "кучи", чтобы выделить 5
                                  массив, содержащий отношения
                                  в кэше (максимальные 10).

Другой аспект - максимальный размер всех объектов в кэше. Это
определенный как размер в байтах, например 500M для 500 мегабайтов или 2 г для два
гигабайты. Прямо прежде, чем максимальный размер достигнут, чистка выполняется где
(в настоящий момент) случайные объекты выселены из кэша, пока размер кэша не добирается
ниже 90 % максимального размера. Оптимальные настройки для максимального размера зависят от
размер Вашего графика. Сконфигурированный максимальный размер должен оставить достаточно комнаты
для других объектов сосуществовать в той же самой JVM, но одновременно достаточно большой
продолжить загружаться от низкоуровневого кэша как минимум. Предсказанная загрузка на
JVM так же как расположение объектов уровня домена должна также быть взятием в
рассмотрение.

Описание параметра конфигурации (чем это управляет), Пример
                                                                       значение
размер Максимума node_cache_size памяти "кучи", чтобы выделить 2 г
                        кэшируемые вершины.

размер Максимума relationship_cache_size памяти "кучи", чтобы выделить 800M
                        кэшируемые отношения.

Вы можете считать о ссылках и соответствующих настройках JVM для Sun HotSpot здесь:

  * Понимание мягких / слабых ссылок <http://weblogs.java.net/blog/enicholas/
    archive/2006/05/understanding_w.html>
  *, Как Горячая точка Решает Очистить SoftReferences <http://
    jeremymanson.blogspot.com/2009/07/how-hotspot-decides-to-clear_07.html>
  * FAQ HotSpot <http://www.oracle.com/technetwork/java/hotspotfaq-138619.html#
    gc_softrefs>

22.7. Логические журналы

Логические журналы в Neo4j - журнал, которых операций происходит и
источник истины в сценариях, где база данных должна быть восстановлена после a
откажите или подобный. Время от времени повернуты журналы (значения по умолчанию, к когда они
превзойдите 25 Мбит в размере), и количество журналов наследства, чтобы сохранить может быть сконфигурировано.
Цель хранения истории логических журналов включает возможность служить
инкрементные резервные копии так же как хранение выполнения кластера HA.

Для любой данной конфигурации, по крайней мере, самый последний непустой логический журнал будет
сохраненный, но конфигурация может быть предоставлен, чтобы управлять, сколько еще сохранить. Там
несколько различных средств управления этим и формата в который
конфигурация предоставлена:

keep_logical_logs = <истина/ложь>
keep_logical_logs = <количество> <тип>

Например:

# сохранит логические журналы неопределенно
keep_logical_logs=true

# сохранит только новый непустой журнал
keep_logical_logs=false

# сохранит логические журналы, который содержит любую транзакцию, фиксировавшую в течение 30 дней
дни keep_logical_logs=30

# сохранит логические журналы, который содержит любую из новых 500 000 транзакций
keep_logical_logs=500k txs

Полный список:

Введите Пример Описания
Номер файлов новых логических файлов системного журнала "10 файлов"
      сохранить

доведите до требуемого размера размер диска Макса, чтобы позволить файлы системного журнала "300M размер"
      займите или "размер 1G"

Номер txs самых последних транзакций, чтобы сохранить "250 k txs"
      Сохраните или "5M txs"

часы Сохраняют журналы, который содержит любую транзакцию "10 часов"
      фиксировавший в течение часов N до тока
      время

дни Сохраняют журналы, который содержит любую транзакцию "50 дней"
      фиксировавший в течение дней N от тока
      время

22.8. Настройки JVM

22.8.1. Фон
22.8.2. Конфигурирование размера "кучи" и GC

22.8.1. Фон

Есть два параметра оперативной памяти для JVM, каждый управляет пространством "кучи"
и другие средства управления стековое пространство. Параметр пространства "кучи" наиболее
важный для Neo4j, так как это управляет, сколько объектов Вы можете выделить.
Параметр стекового пространства управляет как глубоко штабель вызова Вашего
приложению позволяют добраться.

Когда дело доходит до пространства "кучи" общее правило: большее пространство "кучи" Вы имеете
лучше, но удостоверяются, что "куча" помещается в Оперативную память компьютера. Если
"куча" нумерована страницу, чтобы обработать почву дисковым культиватором, производительность ухудшится быстро. Наличие "кучи"
это намного больше чем, в чем нуждается Ваше приложение, не хорошо также, с тех пор
это означает, что JVM накопит много глухих объектов перед
сборщик мусора выполняется, это приводит к длинным паузам набора мусора и
нежелательное поведение производительности.

Наличие большего пространства "кучи" будет означать, что Neo4j может обработать большие транзакции
и больше параллельных транзакций. Большое пространство "кучи" также сделает Neo4j выполненным
быстрее, так как это означает, что Neo4j может приспособить большую часть графика в
кэши, означая, что вершины и отношения Ваше использование приложения
часто всегда доступны быстро. "Куча" значения по умолчанию доводит до требуемого размера для JVM на 32 бита
64 МБ (и на 30 % больше для 64 битов), который слишком мал для самого реального
приложения.

Neo4j хорошо работает с конфигурацией стекового пространства значения по умолчанию, но если Ваш
приложение реализует некоторое рекурсивное поведение, которое это - хорошая идея постепенно увеличить
размер штабеля. Заметьте, что размер штабеля совместно использован для всех потоков, так если Вы
приложение выполняет много параллельных потоков, которым это является хорошая идея
увеличьте размер штабеля.

  * размер "кучи" установлен, определяя-Xmx??? м. параметра к горячей точке, где
    ??? размер "кучи" в мегабайтах. Размер "кучи" значения по умолчанию составляет 64 МБ для 32 битов
    JVM, на 30 % больше (appr. 83 МБ) для JVM на 64 бита.
  * размер штабеля установлен, определяя-Xss??? м. параметра к горячей точке,
    где??? размер штабеля в мегабайтах. Размер штабеля значения по умолчанию составляет 512 Кбит для
    JVM на 32 бита на Солярисе, 320 Кбит для JVM на 32 бита на Linux (и Windows), и
    1024 Кбита для JVM на 64 бита.

Самые современные ЦП реализуют Неравномерный Доступ к памяти (NUMA) архитектура
<http://en.wikipedia.org/wiki/Non-Uniform_Memory_Access>, где различные части
из памяти имеют различные скорости выборки. JVM Горячей точки Sun в состоянии к
выделите объекты с пониманием строения NUMA с версии 1.6.0
обновление 18. Когда включено это может дать 40%-ые улучшения производительности. К
включенный понимание NUMA, определите-XX: + параметр UseNUMA (работает только когда
использование Параллельного сборщика мусора Раскислителя (значение по умолчанию или-XX: + UseParallelGC
не параллельная метка и развертка один).

Должным образом конфигурирующее использование памяти JVM крайне важно для оптимального
производительность. Как пример, плохо сконфигурированная JVM могла провести все время ЦП
выполнение набора мусора (блокирующий все потоки от выполнения любой работы).
Требования, такие как задержка, полная пропускная способность и доступные аппаратные средства имеют к
как полагайте, обнаружить правильную установку. В производстве Neo4j должен работать на a
много платформа ядра/ЦП с JVM в режиме сервера.

22.8.2. Конфигурирование размера "кучи" и GC

Большая "куча" учитывает большую вершину и кэши отношения  - , который является пользой
вещь  - , но большая "куча" может также привести к проблемам задержки, вызванным полным
набор мусора. Различные высокоуровневые реализации кэша, доступные в
Neo4j вместе с соответствующей конфигурацией JVM размера "кучи" и мусора
набор (GC) должен быть в состоянии обработать большинство рабочих нагрузок.

Кэш значения по умолчанию (мягкая ссылка базировала кэш LRU), работы лучше всего с "кучей" это
никогда не получает полным: график, где наиболее используемые вершины и отношения могут быть
кэшируемый. Если "куча" получает слишком полной есть риск, что полный GC будет
инициированный; чем больше "куча", тем более длинный это может взять, чтобы определить что мягкий
ссылки должны быть очищены.

Используя сильную ссылку кэш означает что все вершины и отношения
быть используемым должно поместиться в доступную "кучу". Иначе есть риск получения
исключения из памяти. Мягкая ссылка и сильные ссылочные кэши
хорошо удовлетворенный для приложений была полная пропускная способность, важно.

Кэш слабой ссылки в основном нуждается в достаточном количестве "кучи", чтобы обработать максимальную нагрузку
приложение  -  максимальная нагрузка, умноженная на среднюю память, требуемую на
запрос. Это хорошо подходит для низких требований задержки, был GC interuptions
не являются приемлемыми.

Важный

Выполняя Neo4j на Windows, имейте в виду, что буферы с отображенной памятью
выделенный на "куче" по умолчанию, таким образом, они должны быть приняты во внимание когда
определение размера "кучи".

Таблица 22.47. Направляющие линии для размера "кучи"

Номер RAM доводит до требуемого размера "Кучу" Зарезервированная RAM для
конфигурация примитивов ОС
10M 512 МБ на 2 Гбайт остальные

100M 8 ГБАЙТ + 1-4GB 1-2GB

1B + 16GB-32GB + 4 ГБАЙТ + 1-2GB


Подсказка

Рекомендуемый сборщик мусора, чтобы использовать, выполняя Neo4j в производстве
Параллельный Марк и Компактор Развертки включены, предоставляя
-XX: + UseConcMarkSweepGC как параметр JVM.

Когда удостоверявшийся, что размер "кучи" хорошо сконфигурирован вторая вещь к
настройтесь, чтобы настроиться, сборщик мусора для Вашего приложения должен определить
размеры различных поколений "кучи". Настройки по умолчанию
хорошо настроенный для "нормальных" приложений, и работы вполне хорошо для больше всего
приложения, но если у Вас есть приложение с любым действительно высоким выделением
уровень, или много долговечных объектов Вы могли бы хотеть рассмотреть настраивание
размеры генерации "кучи". Отношение между молодёжью и tenured
генерация "кучи" определена при использовании -XX:NewRatio=# командная строка
опция (где # заменен номером). Отношение значения по умолчанию 1:12 для клиента
JVM режима, и 1:8 для JVM режима сервера. Вы можете также определить размер
молодая генерация, явно используя-Xmn параметр командной строки, который работает
точно так же как-Xmx опция, которая определяет полное пространство "кучи".

GC shortname Комментарий параметра Командной строки Генерации
Копия Янг-КСКС: + UseSerialGC Копирование коллектора

MarkSweepCompact Tenured-XX: + UseSerialGC Марк и Развертка
                                                       Компактор

ConcurrentMarkSweep Tenured-XX: + UseConcMarkSweepGC Параллельный Марк и
                                                       Компактор развертки

ParNew Янг-КСКС: + UseParNewGC параллель Янг
                                                       Генерация
                                                       Коллектор  -  может только быть
                                                       используемый с Параллельным
                                                       метка и развертка
                                                       компактор.

PS Очищают Янга-КСКС: + UseParallelGC параллельный объект
                                                       раскислитель

PS MarkSweep Tenured-XX: + UseParallelGC параллельная метка и
                                                       коллектор развертки

Они - конфигурации значения по умолчанию на некоторых платформах согласно нашему
неисчерпывающее исследование:

JVM-d32 - клиент-d32 - сервер-d64 - клиент-d64
                                                                      - сервер
Mac OS X ParNew и PS Очищает и ParNew и PS
Снег PS ConcurrentMarkSweep MarkSweep ConcurrentMarkSweep Очищает
Leopard, и PS
64-разрядный, MarkSweep
Горячая точка
1.6.0_17

Ubuntu, Копия и Копия и N/A N/A
32-разрядный, MarkSweepCompact MarkSweepCompact
Горячая точка
1.6.0_16

22.9. Сжатое хранение коротких строк

Neo4j попытается классифицировать Ваши строки в коротком строковом классе и если это
управляет этим, это обработает это соответственно. В этом случае, это будет сохранено
без косвенности в хранилище свойства, встраивая это вместо этого в свойстве
запись, означая, что динамическое строковое хранилище не будет включено в хранение
то значение, приводя к пониженному месту диска. Дополнительно, когда никакая строка
запись необходима, чтобы сохранить свойство, она может быть считана и записана в единственном
поиск, приводя к улучшениям производительности и меньшему количеству дискового пространства требован.

Различные классы для коротких строк:

  * Численный, строение цифр 0.. 9 и пространство пунктуации, период,
    тире, плюс, запятая и апостроф.
  * Дата, строение цифр 0.. 9 и пунктуация располагают с интервалами тире, двоеточие,
    наклонная черта, плюс и запятая.
  * Шестнадцатеричный (нижний регистр), строение цифр 0.. 9 и строчные буквы a.. f
  * Шестнадцатеричный (верхний регистр), строение цифр 0.. 9 и прописные буквы a.. f
  * Верхний регистр, строение прописных букв A. Z, и пунктуация
    пространство, подчеркивание, период, тире, двоеточие и наклонная черта.
  * Нижний регистр, как верхний, но со строчными буквами a.. z вместо верхнего
    случай
  * Электронная почта, строение строчных букв a.. z и запятая пунктуации,
    подчеркивание, период, тире, плюс и в знаке.
  * URI, строение строчных букв a.. z, цифры 0.. 9 и больше всего
    доступная пунктуация.
  * Алфавитно-цифровой, строение и прописных букв и строчных букв a.. зона действий. z,
    цифры 0.. 9 и пространство пунктуации и подчеркивание.
  * Символический альфе, строение и прописных букв и строчных букв a.. зона действий. Z
    и пространство пунктуации, подчеркивание, период, тире, двоеточие, наклонная черта, плюс,
    запятая, апостроф, в знаке, канале и точке с запятой.
  * европеец, строение большинства европейских плюсов символов и цифр с диакритическим знаком
    пространство пунктуации, тире, подчеркивание и период  -  как latin1, но с меньше
    пунктуация.
  * латинский 1.
  * UTF-8.

В дополнение к содержанию строки номер символов также определяет
если строка может быть встроена или нет. У каждого класса есть свое собственное символьное количество
пределы, которые являются

Таблица 22.48. Символьные пределы количества

Символ строкового класса
                          предел количества
Численный, Дата и Шестнадцатеричные 54

Верхний регистр, Нижний регистр и 43
Электронная почта

URI, Алфавитно-цифровой и 36
Alphasymbolical

Европейские 31

Latin1 27

UTF-8 14


Это означает, что самая большая встроено-квалифицированная строка - 54 символа долго, и должен
имейте Численный класс и также что все Строки размера 14 или меньше будут
всегда встраивайтесь.

Также заметьте, что вышеупомянутые пределы - для значения по умолчанию 41 байт PropertyRecord
расположение  - , если тот параметр изменен через редактирование источника и перекомпиляцию,
вышеупомянутое должно быть повторно вычислено.

22.10. Сжатое хранение коротких массивов

Neo4j попытается сохранить Ваши примитивные массивы сжатым способом, чтобы к
сохраните дисковое пространство и возможно работу ввода-вывода. Чтобы сделать это, это использует a
"скоблящий бит" алгоритм, который пытается сократить количество битов, требуемых для
хранение элементов массива. В особенности:

 1. Для каждого элемента массива это определяет позицию крайнего левого набора
    бит.
 2. Определяет самое большое такая позиция среди всех элементов массива
 3. Это понижает все элементы к тому номеру битов
 4. Хранилища те значения, снабженные префиксом малой головной частью.

Это означает это, когда даже единственная отрицательная величина включена в массив тогда
естественный размер примитивов будет использоваться.

Есть возможность, что результат может быть встроен в отчете об имуществе
если:

  * Это - меньше чем 24 байта после сжатия
  * у Этого есть меньше чем 64 элемента

Например, массив долго [] {0L, 1L, 2L, 4L} будет встроен, как самое большое
запись (4) будет требовать, чтобы 3 бита, чтобы сохранить так целый массив были сохранены в 4*3
=12 битов. Массив долго [] {-1L, 1L, 2L, 4L} однако будет требовать целых 64
биты для-1 записи, таким образом, это нуждается 64*4 =, 32 байта и это закончатся
динамическая память.

22.11. Настройки IO с отображенной памятью

22.11.1. Введение
22.11.2. Оптимизация для примера скорости обхода
22.11.3. Пакетный пример вставки

22.11.1. Введение

Каждый файл в хранилище Neo4j может использовать ввод-вывод с отображенной памятью для того, чтобы читать/писать.
Лучшая производительность достигнута, если полный файл может быть с отображенной памятью, но если там
не достаточно памяти для того Neo4j, попытается лучше всего использовать память
это добирается (области файла, которые получают полученными доступ, часто более вероятно будет память
отображенный).

Важный

Neo4j делает интенсивное использование java.nio пакета. Собственный ввод-вывод будет следовать памятью
будучи выделенным вне нормальной "кучи" Java так, чтобы использование памяти было
учтенный. Другие процессы, работающие на ОС, плотно сожмут
доступность такой памяти. Neo4j будет требовать всей памяти "кучи"
Плюс JVM память, которая будет использоваться для памяти, отображающейся, чтобы быть доступным как материальный
память. Другие процессы, возможно, не таким образом используют больше чем, что доступно после
сконфигурированное выделение памяти сделано для Neo4j.

Хороший сконфигурированный ОС с большими дисковыми кэшами поможет много, как только мы получаем кэш
пропуски в вершине и кэшах отношения. Поэтому это не хорошая идея
используйте всю доступную память в качестве "кучи" Java.

Если Вы изучите каталог своей базы данных Neo4j, то Вы обнаружите ее хранилище
файлы, все снабженные префиксом neostore:

  * nodestore хранит информацию о вершинах
  * relationshipstore содержит все отношения
  * propertystore хранит информацию свойств и всех простых свойств
    такой как типы примитивов (и для отношений и для вершин)
  * propertystore строки хранит все строковые свойства
  * propertystore массивы хранит все свойства массива

Есть другие файлы там также, но они обычно не интересны в
этот контекст.

Это - то, как память значения по умолчанию, отображающая конфигурацию, смотрит:

neostore.nodestore.db.mapped_memory=25M
neostore.relationshipstore.db.mapped_memory=50M
neostore.propertystore.db.mapped_memory=90M
neostore.propertystore.db.strings.mapped_memory=130M
neostore.propertystore.db.arrays.mapped_memory=130M

22.11.2. Оптимизация для примера скорости обхода

Чтобы настроить настройки отображения памяти запускаются, исследуя размер
различные файлы хранилища найдены в каталоге Вашей базы данных Neo4j. Вот
пример некоторых из файлов и размеров в базе данных Neo4j:

14M neostore.nodestore.db
510M neostore.propertystore.db
1.2 г neostore.propertystore.db.strings
304M neostore.relationshipstore.db

В этом примере приложение работает на машине с 4 Гбайт RAM. Мы имеем
зарезервированные приблизительно 2 Гбайт для ОС и других программ. "Куча" Java установлена в
1.5 Гбайт, что листы приблизительно 500 МБ RAM, которая может использоваться для отображения памяти.

Подсказка

Если скорость обхода - самый высокий приоритет, это хорошо к карте памяти столько, сколько
возможный из вершины - и хранилища отношения.

Конфигурация в качестве примера на машине в качестве примера, сосредотачивающейся на скорости обхода
тогда смотрел бы что-то как:

neostore.nodestore.db.mapped_memory=15M
neostore.relationshipstore.db.mapped_memory=285M
neostore.propertystore.db.mapped_memory=100M
neostore.propertystore.db.strings.mapped_memory=100M
neostore.propertystore.db.arrays.mapped_memory=0M

22.11.3. Пакетный пример вставки

Считайте общую информацию о пакетной вставке в Главе 35, Пакетной Вставке.

Конфигурация должна удовлетворить набор данных, Вы собираетесь ввести использование
BatchInsert. Пускает говорят, что у нас есть случайно-подобный график с 10M вершины и 100M
отношения. Каждая вершина (и возможно некоторые отношения) имеет отличающийся
свойства строки и типов примитивов Java (но никакие массивы). Важное
вещь со случайным графиком будет состоять в том, чтобы дать много памяти к отношению
и хранилище вершины:

neostore.nodestore.db.mapped_memory=90M
neostore.relationshipstore.db.mapped_memory=3G
neostore.propertystore.db.mapped_memory=50M
neostore.propertystore.db.strings.mapped_memory=100M
neostore.propertystore.db.arrays.mapped_memory=0M

Конфигурация выше приспособит весь график (с исключением к
свойства) в памяти.

Приблизительная формула, чтобы вычислить память, необходимую для вершин:

number_of_nodes * 9 байтов

и для отношений:

number_of_relationships * 33 байта

Свойства будут обычно только вводиться однажды и никогда не читаться так некоторые
мегабайты для хранилища свойства и строкового хранилища обычно достаточно. Если Вы
имейте очень большие строки или массивы, Вы можете хотеть увеличить объем памяти
присвоенный строке и массиву хранят файлы.

Важная вещь помнить состоит в том, что вышеупомянутая конфигурация будет нуждаться в Java
"куча" 3.3 г + с тех пор в пакетных буферах Java нормали режима вставки, который добирается
выделенный на "куче" будет использоваться вместо с отображенной памятью.

22.12. Руководство по Производительности Linux

22.12.1. Введение
22.12.2. Сравнительный тест файловой системы
22.12.3. Файловая система, настраивающаяся для высокого IO
22.12.4. Определение номера открытых файлов

22.12.1. Введение

У ключа, чтобы достигнуть хорошей производительности на чтениях и записях должно быть много RAM
так как диски настолько медленны. Это руководство сосредоточится на том, чтобы достигать хорошей записи
производительность на ядре Linux базировала операционную систему.

Если Вы уже не считали информацию, доступную в Главе 22,
Конфигурация & Производительность, сделайте это теперь, чтобы получить некоторые элементарные знания о памяти
отображение и хранит файлы с Neo4j.

Этот раздел будет вести Вас через, как установить сравнительный тест файловой системы и
используйте это, чтобы сконфигурировать Вашу систему лучшим способом.

22.12.2. Сравнительный тест файловой системы

22.12.2.1. Установка

Создайте большой файл со случайными данными. Файл должен поместиться в RAM так если Ваш
у машины есть 4 Гбайт RAM, которой 1-2GB файл со случайными данными будет достаточно. После
файл был создан, мы считаем файл последовательно несколько раз, чтобы сделать
уверенный это кэшируется.

$ dd, если =/dev/urandom of=store bs=1M count=1000
1000+0 записей в
1000+0 записей
1048576000 байтов скопированные (1.0 Гбайт), 263.53 s, 4.0 Мбайт/с
$
$ dd if=store =/dev/null bs=100M
10+0 записей в
10+0 записей
1048576000 байтов скопированные (1.0 Гбайт), 38.6809 s, 27.1 Мбайт/с
$
$ dd if=store =/dev/null bs=100M
10+0 записей в
10+0 записей
1048576000 байтов скопированные (1.0 Гбайт), 1.52365 s, 688 Мбайт/с
$ dd if=store =/dev/null bs=100M
10+0 записей в
10+0 записей
1048576000 байтов скопированные (1.0 Гбайт), 0.776044 s, 1.4 Гбайт/с

Если у Вас есть стандартный жесткий диск в машине, Вы можете знать, что это не
способный к скоростям передачи столь же высоко как 1.4GB/s. То, что измерено, то, как причал мы
может считать файл, который кэшируется для нас операционной системой.

Затем мы будем использовать малую утилиту, которая моделирует поведение ядра Neo4j к
протестируйте скорости записи в сравнении с эталоном системы.

Литник $ обеспечивает совместимость git@github.com:neo4j-contrib/tooling.git
...
cd $ tooling/write-test/
$ mvn компиляция
[ИНФОРМАЦИЯ] Сканирование для проектов...
...
$./выполнение
Использование: <большой файл> <файл системного журнала> <[записывают размер] [минута tx размер] [максимальный размер tx] [tx количество] <[-nosync | - nowritelog | - nowritestore | - noread | - nomemorymap]>>

Утилите дадут файл хранилища (большой файл, который мы только создали), и имя
из файла системного журнала. Затем размер записи в байтах, минута tx размер, максимальный размер tx и
количество транзакции должно быть установлено. Когда запущено утилита отобразит большое
храните файл полностью в памяти и считайте (размер транзакции) записи от этого
в произвольном порядке и затем запишите им последовательно в файл системного журнала. Файл системного журнала будет
тогда сила изменяется на диск, и наконец записи будут записаны обратно к
храните файл.

22.12.2.2. Выполнение сравнительного теста

Пускает попытке протестировать 100 транзакций в сравнении с эталоном размера 100-500 с размером записи 33
байты (тот же самый размер записи, используемый хранилищем отношения).

Хранилище за $./выполнение logfile 33 100 500 100
tx_count [100] записи [30759] fdatasyncs [100] читают [0.96802425 Мбайта] записал [1.9360485 Мбайта]
Время было: 4.973
20.108585 tx/s, 6185.2 records/s, 20.108585 fdatasyncs/s, 199.32773 кБайт/с на чтениях, 398.65546 кБайт/с на записях

Мы видим, что получаем приблизительно 6185 записей updates/s и 20 transactions/s с
текущий размер транзакции. Мы можем изменить размер транзакции, чтобы быть больше, для
пример пишущий 10 транзакций размера 1000-5000 записей:

Хранилище за $./выполнение logfile 33 1000 5000 10
tx_count [10] записи [24511] fdatasyncs [10] читают [0.77139187 Мбайта] записал [1.5427837 Мбайта]
Время было: 0.792
12.626263 tx/s, 30948.232 records/s, 12.626263 fdatasyncs/s, 997.35516 кБайт/с на чтениях, 1994.7103 кБайт/с на записях

С большей транзакцией мы сделаем меньше из них в секунду, но записи
пропускная способность увеличится. Пускает видят, масштабируется ли это, 10 транзакций в под 1s
тогда 100 из них должны выполниться в приблизительно 10-ых:

Хранилище за $./выполнение logfile 33 1000 5000 100
tx_count [100] записи [308814] fdatasyncs [100] читают [9.718763 Мбайт] записал [19.437527 Мбайт]
Время было: 65.115
1.5357445 tx/s, 4742.594 records/s, 1.5357445 fdatasyncs/s, 152.83751 кБайт/с на чтениях, 305.67502 кБайт/с на записях

Это не очень линейное масштабирование. Мы модифицировали немного больше чем 10x записи в
сумма, но время подпрыгивала почти 100x. Выполнение сравнительного теста, смотря vmstat
вывод откроет, что что-то не, как это должно быть:

$ vmstat 3
procs-----------память------------подкачка-----io----система----центральный процессор----
 r b swpd освобождают си кэша цвета буйволовой кожи так bi филиал в cs нас sy идентификатор wa
 0 1 47660 298884 136036 2650324 0 0 0 10239 1167 2268 5 7 46 42
 0 1 47660 302728 136044 2646060 0 0 0 7389 1267 2627 6 7 47 40
 0 1 47660 302408 136044 2646024 0 0 0 11707 1861 2016 8 5 48 39
 0 2 47660 302472 136060 2646432 0 0 0 10011 1704 1878 4 7 49 40
 0 1 47660 303420 136068 2645788 0 0 0 13807 1406 1601 4 5 44 47

Есть много блоков, выходящих в IO, путь, более чем ожидаемый для записи
скорость мы видим в сравнительном тесте. Другое наблюдение, которое может быть сделано,
то, что ядро Linux метало икру, процесс вызывал "сброс-x:x" (выполненная вершина) это
кажется, использует много ресурсов.

Проблема здесь состоит в том, что ядро Linux пытается быть умным и выписать
грязный нумерует страницу от виртуальной памяти. Поскольку сравнительный тест будет память отобразить 1 Гбайт
файл и делает случайные записи, вероятно, что это будет следовать 1/4
память нумерует страницу доступная на системе, которая будет отмечена как грязный. Ядро Neo4j
отправка любых системных вызовов к ядру Linux, чтобы выписать их нумерует страницу к
обработайте почву дисковым культиватором однако, ядро Linux решило начать делать так, и это - очень плохое
решение. Результат - то, что вместо того, чтобы делать последовательный как записывает к
диск (логический файл системного журнала) мы теперь делаем случайные записи, пишущий области
файл с отображенной памятью, чтобы обработать почву дисковым культиватором.

Возможно наблюдать это поведение более подробно, смотря/proc/
vmstat "nr_dirty" и значения "nr_writeback". По умолчанию ядро Linux будет
начните запись, нумерует страницу в очень низком отношении грязных, нумерует страницу (10 %).

Синхронизация $
$ наблюдают grep-A 1 грязный/proc/vmstat
...
nr_dirty 22
nr_writeback 0

"Синхронизирующая" команда выпишет все данные (который нуждается в записи), из памяти к
диск. Вторая команда будет наблюдать количество "nr_dirty" и "nr_writeback"
от vmstat. Теперь запустите сравнительный тест снова и наблюдайте номера:

nr_dirty 124947
nr_writeback 232

"nr_dirty" нумерует страницу, быстро начнет возвышаться и через некоторое время
"nr_writeback" также увеличит значение, что ядро Linux планирует много
из нумерует страницу, чтобы выписать, чтобы обработать почву дисковым культиватором.

22.12.2.3. Решение проблемы

Поскольку у нас есть RAM на 4 Гбайт на машине, и память отображают файл на 1 Гбайт, который не нуждается
его контент, записанный, чтобы обработать почву дисковым культиватором (пока мы не говорим этому делать так из-за логического журнала
вращение или завершение работы ядра Neo4j), должно быть возможно сделать бесконечный случайный
записи к той памяти с высокой пропускной способностью. Все, что мы должны сделать, должно сказать
Ядро Linux, чтобы прекратить пытаться быть умным. Отредактируйте/etc/sysctl.conf (должны будьте базироваться
доступ), и прибавляют следующие строки:

vm.dirty_background_ratio = 50
vm.dirty_ratio = 80

Затем (как корень) выполнитесь:

# sysctl-p

"vm.dirty_background_ratio" говорит в том, какое отношение должно ядро linux
начните фоновую задачу записи грязного, нумерует страницу. Мы увеличили это с
значение по умолчанию 10 % к 50 % и это должно покрыть файл с отображенной памятью на 1 Гбайт.
"vm.dirty_ratio" говорит, в каком отношении все записи IO становятся синхронными, означая
то, что мы не можем сделать вызовов IO, не ожидая базового устройства к
завершите их (который является чем-то, что Вы никогда не хотите произойти).

Запустите повторно сравнительный тест:

Хранилище за $./выполнение logfile 33 1000 5000 100
tx_count [100] записи [265624] fdatasyncs [100] читают [8.35952 Мбайт] записал [16.71904 Мбайт]
Время было: 6.781
14.7470875 tx/s, 39171.805 records/s, 14.7470875 fdatasyncs/s, 1262.3726 кБайт/с на чтениях, 2524.745 кБайт/с на записях

Результаты теперь больше в соответствии с тем, что может ожидаться, 10x больше записей
модифицированные результаты в 10x более длинное время выполнения. vmstat утилита не будет
сообщите о любом абсурдном количестве блоков IO, выходящих (оно сообщает о тех вызванных
fdatasync к логическому журналу), и ядро Linux не будет метать икру "сброс-x:x"
фоновый процесс, выписывающий грязный, нумерует страницу вызванный записями к памяти
отображенный хранят файл.

22.12.3. Файловая система, настраивающаяся для высокого IO

Чтобы поддерживать высокую загрузку IO малых транзакций от базы данных,
базовая файловая система должна быть настроена. Признаки для этого - низкая загрузка ЦП с
высоко iowait. В этом случае, есть несколько тонких настроек, возможных на Linux
системы:

  * Отключают обновления времени доступа: noatime, nodiratime флаги для диска монтируются
    команда или в/etc/fstab для объема диска базы данных монтируется.
  * Мелодия планировщик IO для высокого диска IO на диске базы данных.

22.12.4. Определение номера открытых файлов

Платформы Linux налагают верхний предел на номер параллельных файлов пользователь
может иметь открытый. Об этом номере сообщают для текущего пользователя и сеанса с
команда

user@localhost:~ $ ulimit-n
1024

Обычное значение по умолчанию 1024 достаточно часто, особенно когда многие индексируют,
используемый или установка сервера видит слишком много соединений (сетевое количество сокетов
против того предела также). Пользователи поэтому поощрены увеличить это
ограничьте здоровым значением 40000 или больше, в зависимости от моделей использования. Установка
это значение через ulimit команду возможно только для корневого пользователя и этого
для того сеанса только. Чтобы установить систему ценностей, широкую, Вы должны следовать
инструкции для Вашей платформы.

То, что следует, является процедурой, чтобы установить открытый предел дескриптора файла к 40 k для
пользователь neo4j под Ubuntu 10.04 и позже. Если Вы решили выполнить neo4j службу
как различный пользователь, измените первое поле синхронно 2 соответственно.

 1. Станьте корнем начиная со всех операций, которые следуют, требуют предохраненного редактирования
    системные файлы.

    user@localhost:~ $ sudo su -
    Пароль:
    root@localhost:~ $

 2. Отредактируйте/etc/security/limits.conf и прибавьте эти две строки:

    neo4j мягкий nofile 40000
    neo4j трудно nofile 40000

 3. Отредактируйте/etc/pam.d/su и непрокомментируйте или прибавьте следующую строку:

    сеанс требовал pam_limits.so

 4. Запущение снова требуется для настроек вступить в силу.

    После вышеупомянутой процедуры у neo4j пользователя будет предел 40000
    одновременные открытые файлы. Если Вы продолжаете испытывать исключения на Также
    много открытых файлов или не Могли stat () каталог тогда, Вам, вероятно, придется повысить
    тот предел далее.

Глава 23. Высокая доступность

Замечание

Высоконадежные функции только доступны в Neo4j Enterprise
Выпуск.

Высокая доступность Neo4j или “HA Neo4j” обеспечивают следующие две основных функции:

 1. Это включает отказоустойчивой архитектуре базы данных, где несколько Neo4j
    ведомые базы данных могут быть сконфигурированы, чтобы быть точными копиями единственного Neo4j
    основная база данных. Это позволяет системе конечного пользователя быть полностью функциональной и
    оба чтения и запись к базе данных в случае отказа оборудования.
 2. Это включает горизонтально масштабирующейся архитектуре чтения главным образом, которая включает
    система, чтобы обработать более загрузку чтения чем единственный экземпляр базы данных Neo4j может
    дескриптор.

23.1. Архитектура

HA Neo4j был разработан, чтобы сделать переход от единственной машины до много
простая работа машины, не имея необходимость уже измениться существующий
приложение.

Рассмотрите существующее заявление со встроенным Neo4j и работа единственного
машина. Чтобы развернуть такое приложение во много машине устанавливают единственное
заданное изменение должно переключить создание GraphDatabaseService от
GraphDatabaseFactory к HighlyAvailableGraphDatabaseFactory. Начиная с обоих
реализуйте тот же самый интерфейс, никакие дополнительные изменения не требуются.

Рисунок 23.1. Разнообразные экземпляры Neo4j в режиме HA

Neo4j Высоконадежный Кластер


Выполняя Neo4j в режиме HA всегда есть единственное ведущее устройство и нуль или больше
ведомые устройства. По сравнению с HA установок другой основной ведомой репликации Neo4j может обработать
запишите запросы на всех машинах, таким образом, нет никакой потребности перенаправить тех к
освойте определенно.

Ведомое устройство обработает записи, синхронизируясь с ведущим устройством, чтобы сохранить
непротиворечивость. Записи ведущему устройству могут быть сконфигурированы, чтобы быть оптимистично продвинутыми к
0 или больше ведомых устройств. Оптимистично мы подразумеваем, что ведущее устройство попытается продвинуть к
ведомые устройства перед транзакцией завершаются, но если она перестанет работать, то транзакция будет
все еще будьте успешны (отличающийся от нормального фактора репликации). Все обновления
однако распространит от ведущего устройства к другим ведомым устройствам в конечном счете так запись
от одного ведомого устройства, возможно, не сразу видимо на всех других ведомых устройствах. Это
единственная разница между разнообразными машинами, прирабатывающими режим HA, сравнилась с единственным
работа машины. Все другие характеристики ACID - то же самое.

23.2. Установка и конфигурация

23.2.1. Определение элементов кластера
23.2.2. Конфигурация сервера
23.2.3. Конфигурация базы данных

HA Neo4j может быть установлен, чтобы разместить отличающиеся требования для загрузки, отказа
допуск и доступные аппаратные средства.

В режиме HA экземпляры Neo4j формируют кластер. Монитор экземпляров, друг друга
доступность, чтобы принять во внимание соединение экземпляров и отъезд кластера. Они
выберите один экземпляр, чтобы быть ведущим устройством, и определять другие экземпляры быть
ведомые устройства.

Поскольку инструкции по установке Кластера высокой доступности видят Раздел 23.6,
“Высокая доступность устанавливает учебное руководство”.

23.2.1. Определение элементов кластера

Определите экземпляры, которые должны сформировать кластер, предоставляя
ха initial_hosts, список разделенных запятой значений URL. Когда каждый экземпляр запускается, если
это может войти в контакт с любым из начальных узлов, тогда это сформирует кластер с ними,
иначе это запустит свой собственный кластер.

Заметьте, что параметр вызывают ха initial_hosts, потому что он только используется когда
экземпляры первоначально соединяют к кластеру. Это означает, что Вы можете расшириться
кластер, не изменяя конфигурацию существующих экземпляров.

23.2.2. Конфигурация сервера

Если Вы выполняете сервер Neo4j, определите org.neo4j.server.database.mode=HA в
neo4j-server.properties.

Таблица 23.1. Параметры конфигурации сервера HA

Заданный Пример Описания Названия параметра?
                                                             значение
org.neo4j.server.database.mode, Работать ли как единственное единственное да
                               сервер или в режиме HA. или HA


23.2.3. Конфигурация базы данных

Параметры конфигурации HA должны быть предоставлены рядом с общим Neo4j
параметры в neo4j.properties. Есть много конфигурируемых параметров, больше всего в
большинство случаев не необходимо модифицировать значения по умолчанию. Единственные параметры
это должно быть определено, ха server_id и ха initial_hosts.

Таблица 23.2. Параметры конфигурации базы данных HA

Заданное значение Описания Названия параметра В качестве примера?
ха server_id Идентификатор для кластера 1 да
                                     экземпляр. Должен быть
                                     уникальный в пределах
                                     кластер.

ха initial_hosts список разделенных запятой значений server1:5001, server2:5001 да
                                     из других элементов
                                     кластер, чтобы присоединиться.

ха cluster_server Узел & порт, чтобы связать server1:5001 нет
                                     управление кластером
                                     передача.

ха allow_init_cluster, Ли позволить эту истину нет
                                     экземпляр, чтобы создать a
                                     кластер если неспособный к
                                     соединение.

ха default_timeout тайм-аут Значения по умолчанию, используемый 5s нет
                                     для того, чтобы кластеризироваться
                                     тайм-ауты. Переопределение
                                     определенный тайм-аут
                                     настройки с присущим
                                     значения в случае необходимости.
                                     Это значение
                                     значение по умолчанию для
                                     настройки
                                     ха heartbeat_interval,
                                     ха paxos_timeout и
                                     ха learn_timeout.

ха heartbeat_interval, Как часто биение 5s нет
                                     сообщения должны быть
                                     отправленный. Значения по умолчанию к
                                     ха default_timeout.

ха heartbeat_timeout Тайм-аут для 11 биений нет
                                     между кластером
                                     элементы. Должен быть в
                                     наименее дважды это
                                     ха heartbeat_interval.

ха broadcast_timeout Тайм-аут в течение многих 30-ых нет
                                     широковещательная передача значений в
                                     кластер. Должен рассмотреть
                                     непрерывная продолжительность
                                     Алгоритм Paxos. Это
                                     значение - значение по умолчанию
                                     значение для настроек
                                     ха join_timeout и
                                     ха leave_timeout.

ха join_timeout Тайм-аут для того, чтобы соединить к 30-ым нет
                                     кластер. Значения по умолчанию к
                                     ха broadcast_timeout.

ха configuration_timeout Тайм-аут для того, чтобы ожидать 1s нет
                                     для конфигурации от
                                     существующий кластер
                                     элемент во время кластера
                                     соединение.

ха leave_timeout Тайм-аут в течение 30-ых ожидания нет
                                     поскольку кластер уезжает к
                                     отделка. Значения по умолчанию к
                                     ха broadcast_timeout.

ха paxos_timeout тайм-аут Значения по умолчанию для 5s нет
                                     все тайм-ауты Paxos.
                                     Значения по умолчанию к
                                     ха default_timeout.
                                     Это значение
                                     значение по умолчанию для
                                     настройки
                                     ха phase1_timeout,
                                     ха phase2_timeout и
                                     ха election_timeout.

ха phase1_timeout Тайм-аут для Paxos 5s нет
                                     фаза 1. Значения по умолчанию к
                                     ха paxos_timeout.

ха phase2_timeout Тайм-аут для Paxos 5s нет
                                     фаза 2. Значения по умолчанию к
                                     ха paxos_timeout.

ха learn_timeout Тайм-аут для того, чтобы учиться 5s нет
                                     значения. Значения по умолчанию к
                                     ха default_timeout.

ха election_timeout Тайм-аут для того, чтобы ожидать 5s нет
                                     для других элементов к
                                     обработайте начисто роль
                                     выборы. Значения по умолчанию к
                                     ха paxos_timeout.

ха read_timeout, Сколько времени ведомое устройство будет 20-ые нет
                                     ожидайте реакции от
                                     ведущее устройство перед предоставлением
                                     .

ха state_switch_timeout Тайм-аут в течение 20-ых ожидания нет
                                     например стать
                                     ведущее устройство или ведомое устройство.

ха lock_read_timeout Тайм-аут для того, чтобы занять 20-ые нет
                                     удаленный (запись) блокировки
                                     на ведомых устройствах. Значения по умолчанию к
                                     ха read_timeout.

ха max_concurrent_channels_per_slave Максимальное количество 20 нет
                                     соединения ведомое устройство
                                     может иметь к
                                     ведущее устройство.

Имя узла ha.server и порт к мой-domain.com:6001 нет
                                     свяжите сервер HA.

ха slave_only, Ли эта ложь экземпляра нет
                                     если только
                                     участвуйте как ведомое устройство
                                     в кластере. Если установлено в
                                     истина, это никогда не будет
                                     избранный ведущим устройством.

ха branched_data_policy Политика, для как к keep_last или keep_all или нет
                                     обработайте переходил данные. keep_none

ха com_chunk_size размер Макса данных 2M нет
                                     блоки, который течет
                                     между ведущим устройством и
                                     ведомые устройства в HA. Больше
                                     размер может увеличиться
                                     пропускная способность, но может быть
                                     более чувствительный к
                                     вариации в
                                     пропускная способность, тогда как
                                     понизьте увеличения размера
                                     допуск для
                                     вариации пропускной способности.

ха pull_interval Интервал получения по запросу 10-ых нет
                                     обновления от ведущего устройства.

ха tx_push_factor количество ведомых устройств 1 нет
                                     ведущее устройство спросит к
                                     тиражируйте фиксировавший
                                     транзакция.

ха tx_push_strategy стратегия Нажатия фиксированного или round_robin нет
                                     транзакция к ведомому устройству
                                     во время фиксации.


23.3. Как HA Neo4j работает

Кластер HA Neo4j работает совместно  - , каждый экземпляр базы данных делится без остатка
логика нуждалась, чтобы скоординировать с другими элементами кластера. На
запуститесь экземпляр базы данных HA Neo4j попытается соединиться с существующим кластером
определенный конфигурацией. Если кластер будет существовать, то экземпляр соединит к нему как
ведомое устройство. Иначе кластер будет создаваться, и экземпляр станет
ведущее устройство.

Выполняя транзакцию записи на ведомом устройстве каждая работа записи будет
синхронизируемый с ведущим устройством (блокировки будут получены и на ведущем устройстве и на ведомом устройстве).
Когда фиксации транзакции это будет сначала фиксироваться на ведущем устройстве и затем,
в случае успеха, на ведомом устройстве. Чтобы гарантировать непротиворечивость, ведомое устройство должно составить
дата с ведущим устройством прежде, чем выполнить работу записи. Это создано в
протокол связи между ведомым устройством и ведущим устройством, так, чтобы обновления были
будьте применены к ведомому устройству, связывающемуся с его ведущим устройством автоматически.

Запишите, что транзакции, выполняемые прямо через ведущее устройство, выполнятся в
тот же самый путь как прирабатывание нормального режима неHA. На успехе транзакция будет
выставленный к конфигурируемому номеру ведомых устройств (принимают значение по умолчанию одно ведомое устройство). Это сделано
оптимистично значение, приводит ли нажатие транзакцию к сбою, все еще будет
успешный. Также возможно сконфигурировать фактор нажатия к 0 для более высокой записи
производительность при записи прямо через ведущее устройство, хотя увеличиваясь
риск потери любой транзакции, которую еще вытягивает другое ведомое устройство, если ведущее устройство
теряет работоспособность.

Ведомые устройства могут также быть сконфигурированы, чтобы вытянуть обновления асинхронно, устанавливая
ха pull_interval опция.

Всякий раз, когда база данных Neo4j становится недоступной, посредством например аппаратных средств
отказ или сетевые простои, другие экземпляры базы данных в кластере будут
обнаружьте, что и отмечают это как временно отказавший. Экземпляр базы данных, который становится
доступный будучи недоступным автоматически догонит кластер.
Если ведущее устройство спустится другой (лучше всего удовлетворенный), то элемент будет избран и иметь
его роль, переключенная от ведомого устройства до ведущего устройства после кворума, была достигнута в пределах
кластер. Когда новое ведущее устройство выполнило его ролевой переключатель, это будет
широковещательно передайте его доступность ко всем другим элементам кластера. Обычно a
новое ведущее устройство избрано и запущено в течение только нескольких секунд и во время этого
время никакие записи не могут иметь место (записи блокируют или в редких случаях, бросает
исключение). Единственное время это не истина, - то, когда у старого мастера были изменения
это не получало тиражированным в любой другой элемент прежде, чем стать недоступным. Если
новое ведущее устройство избрано и выполняет изменения прежде, чем старый мастер восстановится,
будет два "ответвления" базы данных после точки где старое
ведущее устройство стало недоступным. Старый мастер отодвинет его базу данных (его
"ответвление") и загрузка полная копия от нового ведущего устройства, чтобы стать доступный как
ведомое устройство в кластере.

Все это может быть получено в итоге как:

  * транзакции Записи могут быть выполнены на любом экземпляре базы данных в кластере.
  * HA Neo4j - терпимый отказ и может продолжать работать от любого номера
    машины вниз к единственной машине.
  * Ведомые устройства будут автоматически синхронизироваться с ведущим устройством на записи
    операции.
  *, Если ведущее устройство приводит новое ведущее устройство к сбою, будет избран автоматически.
  * кластер автоматически обрабатывает экземпляры, становящиеся недоступным (для
    сбор в качестве примера к сетевым проблемам), и также удостоверяется, что принял их как
    элементы в кластере, когда они доступны снова.
  * Транзакции являются атомарными, непротиворечивыми и долговечными, но в конечном счете распространенными
    к другим ведомым устройствам.
  * Обновления к ведомым устройствам возможны непротиворечивый по своей природе, но могут быть сконфигурированы
    быть продвинутым оптимистично от ведущего устройства во время фиксации.
  *, Если ведущее устройство спускается, любая рабочая транзакция записи будет откатываться
    и новые транзакции блокируют или перестанут работать, пока новое ведущее устройство не стало
    доступный.
  * Чтения являются высоконадежными и возможность обработать масштабы загрузки чтения с
    больше экземпляров базы данных в кластере.

23.4. Экземпляры арбитра

Типичное развертывание Neo4j будет использовать кластер 3 машин, чтобы обеспечить
отказоустойчивость и читала масштабируемость. Эта установка описана в Разделе 23.6,
“Высокая доступность устанавливает учебное руководство”.

В то время как наличие по крайней мере 3 экземпляров необходимо для failover, чтобы произойти в случае, если
ведущее устройство становится недоступным, это не требуется для всех экземпляров работать
валяйте штабель Neo4j, который включает механизм базы данных. Вместо этого что вызывают
экземпляры арбитра могут быть развернуты. Они могут быть расценены как участники кластера
в той их роли должен принять участие в основных выборах с единственной целью
из ломки связывает избирательный процесс. Это делает возможным сценарий где
у Вас есть кластер 2 экземпляров базы данных Neo4j и дополнительного арбитра
экземпляр и все еще обладает допуском единственного отказа любого из 3
экземпляры.

Экземпляры арбитра сконфигурированы таким же образом как элементы HA Neo4j
 -  через neo4j.properties файл в conf/каталоге установки.
Настройки, которые не являются определенным кластером, конечно, игнорируются, таким образом, Вы можете легко
запустите экземпляр арбитра вместо должным образом сконфигурированного экземпляра Neo4j.

Чтобы запустить экземпляр арбитра, вызвать

neo4j_home$./bin/neo4j-arbiter запускаются

Вы можете также остановить, установить и переместить это как сервис и спросить, поскольку это - состояние
точно таким же образом что касается экземпляров Neo4j. См. также Раздел 21.2, “Сервер
Установка”.

23.5. Обновление Кластера HA Neo4j

23.5.1. Обновление от 1.9.x до 2.0
23.5.2. Обновление от 1.8.x до 1.9
23.5.3. Обновление в пределах 1.9.x ряд

Этот документ описывает шаги, требуемые обновить кластер Neo4j без
разрушение его работы. Этот процесс упоминается как прокручивающееся обновление.

23.5.1. Обновление от 1.9.x до 2.0

В настоящий момент не возможно сделать прокручивающееся обновление от 1.9.x до 2.0. Это
средства, что для Вас, чтобы обновить 1.9.x кластер к 2.0, Вы подвергнетесь
некоторое время простоя.

23.5.1.1. Шаги

Чтобы обновить кластер от 1.9.x до 2.0, Вы должны будете сделать
следующий вручную:

 1. Сделайте копию своих данных!
 2. Выключение каждый элемент кластера кроме ведущего устройства.
 3. Установите новую версию Neo4j для каждого ведомого экземпляра  -  передвижение
    каталог данных, но хранение конфигурации.
 4. Выключение основной  -  это приносит Ваш кластер абсолютно офлайн!
 5. Следуйте инструкциям, найденным в Разделе 21.4.2, “Явное Обновление” для
    только основной экземпляр  -  данные в основном экземпляре теперь был
    преобразованный в новый Neo4j 2.0 формата.
 6. Выключение основной экземпляр снова.
 7. Распределите каталог данных от ведущего устройства к каждому ведомому экземпляру  -  это
    экономит время, не имея необходимость восстановить хранилища и индексирует для каждого ведомого устройства.
 8. Принесите ведущему устройству онлайн.
 9. Принесите ведомые устройства онлайн.

Ваш весь кластер был теперь полностью преобразован в Neo4j 2.0.

23.5.2. Обновление от 1.8.x до 1.9

Запускающиеся предположения - то, что там существует кластер, выполняющий версию Neo4j
1.8 или более новый с соответствующими экземплярами ZooKeeper и что машина
то, который является в настоящий момент ведущим устройством, известно. Это также принято это на каждой машине
служба Neo4j и neo4j служба координатора установлены под a
каталог, который отсюда на, как предполагается,/opt/old-neo4j

Составы процесса обновления каждой машины поочередно, перемещая это от
кластер, отодвигаясь база данных и запуская это поддерживает снова. Конфигурация
настройки также должны быть переданы. Важно заметить что последнее
машина, которая будет обновлена, должна быть ведущим устройством. Вообще, "версия кластера"
определенный версией ведущего устройства, предоставляя ведущему устройству имеет более старое
присвойте версию кластеру, в целом может работать (эти 1.9 прирабатывающие экземпляра
режим эмуляции). Когда 1.9 экземпляра избраны ведущим устройством однако, более старым
экземпляры не способны к передаче с этим, таким образом, мы должны удостовериться
то, что последняя обновленная машина является старым мастером. Процесс обновления
обнаруженный автоматически от соединения к 1.9 экземплярам и они не будут
участвуйте в основных выборах, в то время как даже единственный старый экземпляр - часть
кластер.

23.5.2.1. Шаг 1: На каждом ведомом устройстве выполняют обновление

Загрузите и распакуйте новую версию. Скопируйте по любым настройкам конфигурации Вас
выполните свои экземпляры с, заботясь для осуждаемых настроек и изменений API
это может произойти между версиями. Кроме того, гарантируйте, что это недавно представляло настройки
имейте собственные значения (см. Раздел 23.2, “Установка и конфигурация”). Наиболее
важная вещь об установке настроек - приводящий в движение ha.coordinators
neo4j.properties, который должен быть установлен в значение существующие 1.8 экземпляра,
использование. Вы также должны удостовериться, что все кроме одного экземпляра имеют
ха allow_init_cluster устанавливая в ложь - машина, у которой есть это набор к истине
должен быть тот, который должен стать новым ведущим устройством. Кроме того, это
необходимый, что последняя машина, которая будет обновлена (1.8 ведущих устройства), не имеет
ha.coordinators, устанавливающий существующий в его конфигурационном файле. Наконец, не делать
забудьте копировать по любым плагинам сервера, которые Вы можете иметь. Во-первых, завершение работы neo4j
экземпляр с

остановка neo4j-службы службы

Затем, удалите это

перемещение neo4j-службы службы

Теперь Вы можете скопировать по базе данных. Принятие старого экземпляра в/opt/
старый-neo4j и недавно распакованный под/opt/neo4j-enterprise-1.9 присущим
команда была бы

cp-R/opt/old-neo4j/data/graph.db/opt/neo4j-enterprise-1.9/data/

Затем установите neo4j службу, которая также запускает это

/opt/neo4j-enterprise-1.9/bin/neo4j установка

Договорились. Теперь проверьте, что службы работают и что webadmin сообщает
версия 1.9. Транзакции должны также быть применены от ведущего устройства как обычно.

23.5.2.2. Шаг 2: Обновите ведущее устройство, завершите процедуру

Предупреждение

Удостоверьтесь, что установка, которая заменит текущий основной экземпляр
не имеет ha.coordinators, устанавливающего существующий в neo4j.properties файле.

Пойдите к текущему ведущему устройству и выполните шаг 1 момент, это будет остановлено
другой экземпляр вступит во владение (тот с установкой allow_init_cluster
набор к истине), переходя кластер к 1.9. Шаг отделки 1 на этой машине
также и Вы завершите процесс.

23.5.2.3. Шаг 3: Уборка, перемещая службы координатора

Каждым 1.8 установкам все еще устанавливали службу координатора и выполнение. К
переместите тех, Вы должны выполниться в каждом обновленном экземпляре

остановка neo4j-координатора службы
перемещение neo4j-координатора службы

После этого эти 1.8 экземпляра больше не являются активными или необходимыми и могут быть удалены
или заархивированный.

23.5.3. Обновление в пределах 1.9.x ряд

Предупреждение

Сбор к ошибке в коде HA, возможно, не возможно сделать прокрутку (то есть.
непрерывный), обновляют до Neo4j 1.9.2 на 1.9 или 1.9.1 кластерах. Попытка к
сделайте так может привести к нестабильному кластеру, и потеря данных может произойти. Это предложено
это обновляет до 1.9.2, происходят офлайн, где все экземпляры - завершение работы,
обновленный и запущенный снова. Обновление от 1.9.2 до любой другой версии работает как
описанный в другом месте в этом руководстве.

Обновление между 1.9.x версии следует за той же самой общей моделью как описано
в первой части этого руководства, но намного более просто из-за
совместимость параметров конфигурации между 1.9.x выпуски. Мы будем
опишите пошаговую процедуру, нацеленную на сокращение главных выключателей к a
единственное изменение.

23.5.3.1. Шаг 1: На каждом ведомом устройстве выполняют обновление

Загрузите и распакуйте новую версию. Скопируйте по любым настройкам конфигурации,
у обеспечения, которое недавно представляло настройки, есть собственные значения (см. Раздел 23.2,
“Установка и конфигурация”). Не забывайте копировать по любым плагинам сервера Вас
может иметь.

Во-первых, завершение работы neo4j экземпляр с

остановка neo4j-службы службы

Затем, удалите это

перемещение neo4j-службы службы

Теперь Вы можете скопировать по базе данных. Принятие старого экземпляра в/opt/
старый-neo4j и недавно распакованный под/opt/neo4j-enterprise-1.9.x присущим
команда была бы

cp-R/opt/old-neo4j/data/graph.db/opt/neo4j-enterprise-1.9.x/data/

Затем установите neo4j службу, которая также запускает это

/opt/neo4j-enterprise-1.9.x/bin/neo4j установка

Теперь проверьте, что службы работают и что webadmin сообщает о версии
1.9.x. Транзакции должны также быть применены от ведущего устройства как обычно.

23.5.3.2. Шаг 2: Обновите ведущее устройство, завершите процедуру

Пойдите к текущему ведущему устройству и выполните шаг 1 момент, это будет остановлено
другой экземпляр вступит во владение, переходя кластер к новому 1.9.x
версия. Шаг отделки 1 на этой машине также и Вы завершитесь
процесс.

23.6. Высоконадежное учебное руководство по установке

23.6.1. Фон
23.6.2. Начинание: Установка производственного кластера
23.6.3. Переменная установка: Создание локального кластера для того, чтобы протестировать

Это руководство поможет Вам понять, как сконфигурировать и развернуть Neo4j Высоко
Кластер доступности. Два сценария рассмотрят:

  * Конфигурирование 3 экземпляров, которые будут развернуты на 3 отдельных машинах, в установке
    подобный тому, с чем можно было бы встретиться в продуктивной среде.
  * Модифицирующий прежнего, чтобы позволить работать на кластере 3 экземпляров
    та же самая материальная машина, которая особенно полезна во время разработки.

23.6.1. Фон

Каждый экземпляр в кластере HA Neo4j должен быть присвоен целочисленный ID, который
служит его уникальным идентификатором. При запуске экземпляр Neo4j входит в контакт
другие экземпляры, определенные в ха initial_hosts параметре конфигурации.

Когда экземпляр устанавливает соединение с любым другим, он определяет
текущее состояние кластера и гарантирует, что правомочно присоединиться. Быть
имеющий право экземпляр Neo4j должен разместить то же самое хранилище базы данных как другие элементы
из кластера (хотя позволено быть в более старом состоянии), или новое
развертывание без хранилища базы данных.

Явно сконфигурируйте Адреса/Имена узлов IP для кластера

Neo4j попытается сконфигурировать IP-адреса для себя в отсутствие
явная конфигурация. Однако в типичных операционных средах, где
машины имеют разнообразные сетевые платы и поддерживают IPv4 и IPv6, который это строго
рекомендуемый, что оператор явно устанавливает IP-адрес / имя узла
конфигурация для каждой машины в кластере.

Пустите нам исследовать доступные настройки и значения, которые они принимают.

23.6.1.1. ха server_id

ха server_id идентификатор кластера для каждого экземпляра. Это должно быть положительное
целое число и должно быть уникальным среди всех экземпляров Neo4j в кластере.

Например, ха server_id=1.

23.6.1.2. ха cluster_server

ха cluster_server адрес/порт, устанавливающий, который определяет где Neo4j
экземпляр прислушается к связи кластера (как сообщения hearbeat).
порт значения по умолчанию 5001. В отсутствие указанного IP-адреса будет Neo4j
попытайтесь обнаружить допустимый интерфейс для того, чтобы связать. В то время как это поведение обычно
результаты в сервере хорошего поведения, этому строго рекомендуют это пользователей
явно выберите IP-адрес, связанный с сетевым интерфейсом их
желание гарантировать когерентное развертывание кластера.

Например, ха cluster_server=192.168.33.22:5001 прислушается к кластеру
связь на сетевом интерфейсе, связанном с 192.168.33.0 подсетями на
порт 5001.

23.6.1.3. ха initial_hosts

ха initial_hosts список разделенных запятой значений пар адреса/порта, которые определяют
как достигнуть других экземпляров Neo4j в кластере (как конфигурирующийся через их
ха cluster_server опция). Они имя узла/порты будут использоваться когда Neo4j
экземпляры запускаются, чтобы позволить этому обнаруживать и соединять к кластеру. Определение
собственный адрес экземпляра разрешен.

Предупреждение

Не используйте пробел в этом параметре конфигурации.

Например, ha.initial_hosts=192.168.33.22:5001,192.168.33.21:5001 будет
попытайтесь достигнуть экземпляров Neo4j, слушающих на 192.168.33.22 на порту 5001 и
192.168.33.21 на порту 5001 на 192.168.33.0 подсетях.

23.6.1.4. ha.server

ha.server - адрес/порт, устанавливающий, который определяет где экземпляр Neo4j
прислушается к транзакциям (изменяется на данные графика) от кластера
ведущее устройство. Порт значения по умолчанию 6001. В отсутствие указанного IP-адреса,
Neo4j попытается обнаружить допустимый интерфейс для того, чтобы связать. В то время как это поведение
обычно результаты в сервере хорошего поведения, этому строго рекомендуют это
пользователи явно выбирают IP-адрес, связанный с сетевым интерфейсом их
желание гарантировать когерентную топологию кластера.

ha.server должен пользователь различный порт к ха cluster_server.

Например, ха server=192.168.33.22:6001 прислушается к кластеру
связь на сетевом интерфейсе, связанном с 192.168.33.0 подсетями на
порт 6001.

Формат адреса/порта

Ха cluster_server и ha.server параметры конфигурации определены как <IP
адрес>: <порт>.

Для ha.server IP-адрес ДОЛЖЕН быть адресом, присвоенным одному из узла
сетевые интерфейсы.

Поскольку ха cluster_server IP-адрес ДОЛЖЕН быть адресом, присвоенным одному из
сетевые интерфейсы узла, или значение 0.0.0.0, который вызовет Neo4j к
слушайте на каждом сетевом интерфейсе.

Или адрес или порт могут быть опущены, когда значение по умолчанию для
та часть будет использоваться. Если адрес опущен, то порт должен быть
предшествовавший с двоеточием (eg.:5001).

Синтаксис для того, чтобы установить диапазон порта: <имя узла>: <первый порт> [-<второй
порт>]. В этом случае, Neo4j протестирует каждый порт в последовательности, и выберет
сначала это неиспользовано. Заметьте, что это использование не разрешено когда имя узла
определен как 0.0.0.0 ("все интерфейсы" адрес).

23.6.2. Начинание: Установка производственного кластера

23.6.2.1. Загрузите и распакуйте Neo4j Enterprise

Download Neo4j Enterprise от сайта для скачивания Neo4j <http://neo4j.org/
загрузка>, и распаковывает на 3 отдельных машинах.

23.6.2.2. Сконфигурируйте связанные настройки HA для каждой установки

Следующие настройки должны быть сконфигурированы для каждой установки Neo4j. Замечание
у этого всего 3 установки есть та же самая конфигурация, за исключением
ха server_id свойство.

Экземпляр Neo4j #1-neo4j-01.local

conf/neo4j.properties:

# Уникальный идентификатор сервера для этого экземпляра Neo4j
# не может быть отрицательный идентификатор и должен быть уникальным
ха server_id = 1

# Список других известных экземпляров в этом кластере
ха initial_hosts = neo4j-01.local:5001,neo4j-02.local:5001,neo4j-03.local:5001
# Альтернативно, используйте IP-адреса:
#ha.initial_hosts = 192.168.0.20:5001,192.168.0.21:5001,192.168.0.22:5001

conf/neo4j-server.properties

# Пущенный веб-сервер только слушать на указанном IP.
org.neo4j.server.webserver.address=0.0.0.0

# HA - Высокая доступность
# ЕДИНСТВЕННЫЙ - Единственный режим, значение по умолчанию.
org.neo4j.server.database.mode=HA

Экземпляр Neo4j #2-neo4j-02.local

conf/neo4j.properties:

# Уникальный идентификатор сервера для этого экземпляра Neo4j
# не может быть отрицательный идентификатор и должен быть уникальным
ха server_id = 2

# Список других известных экземпляров в этом кластере
ха initial_hosts = neo4j-01.local:5001,neo4j-02.local:5001,neo4j-03.local:5001
# Альтернативно, используйте IP-адреса:
#ha.initial_hosts = 192.168.0.20:5001,192.168.0.21:5001,192.168.0.22:5001

conf/neo4j-server.properties

# Пущенный веб-сервер только слушать на указанном IP.
org.neo4j.server.webserver.address=0.0.0.0

# HA - Высокая доступность
# ЕДИНСТВЕННЫЙ - Единственный режим, значение по умолчанию.
org.neo4j.server.database.mode=HA

Экземпляр Neo4j #3-neo4j-03.local

conf/neo4j.properties:

# Уникальный идентификатор сервера для этого экземпляра Neo4j
# не может быть отрицательный идентификатор и должен быть уникальным
ха server_id = 3

# Список других известных экземпляров в этом кластере
ха initial_hosts = neo4j-01.local:5001,neo4j-02.local:5001,neo4j-03.local:5001
# Альтернативно, используйте IP-адреса:
#ha.initial_hosts = 192.168.0.20:5001,192.168.0.21:5001,192.168.0.22:5001

conf/neo4j-server.properties

# Пущенный веб-сервер только слушать на указанном IP.
org.neo4j.server.webserver.address=0.0.0.0

# HA - Высокая доступность
# ЕДИНСТВЕННЫЙ - Единственный режим, значение по умолчанию.
org.neo4j.server.database.mode=HA

23.6.2.3. Запустите Серверы Neo4j

Запустите серверы Neo4j как нормаль. Заметьте, что порядок запуска не имеет значение.

$ neo4j-01./bin/neo4j запускаются

$ neo4j-02./bin/neo4j запускаются

$ neo4j-03./bin/neo4j запускаются

Время запуска

Прирабатывая режим HA, сценарий запуска сразу возвращается вместо
ожидание сервера, чтобы стать доступный. Это - то, потому что экземпляр делает
не принимают любые запросы, пока кластер не был сформирован. В примере выше
это происходит, когда Вы запускаете второй экземпляр. Отслеживать запуск
состояние, в котором Вы можете следовать за сообщениями console.log - путь к этому, печатается
перед возвратами сценария запуска.

Теперь, Вы должны быть в состоянии получить доступ к этим 3 серверам и проверить их состояние HA:

http://neo4j-01.local:7474/webadmin/#/info/org.neo4j/High%20Availability/
<http://neo4j-01.local:7474/webadmin/#/info/org.neo4j/High%20Availability/>

http://neo4j-02.local:7474/webadmin/#/info/org.neo4j/High%20Availability/
<http://neo4j-02.local:7474/webadmin/#/info/org.neo4j/High%20Availability/>

http://neo4j-03.local:7474/webadmin/#/info/org.neo4j/High%20Availability/
<http://neo4j-03.local:7474/webadmin/#/info/org.neo4j/High%20Availability/>

Подсказка

Вы можете заменить базу данных #3 экземпляром арбитра, видеть Экземпляры Арбитра.

Вот именно! У Вас теперь есть кластер HA Neo4j 3 выполнений экземпляров. Вы можете
запустите, производя изменение на любом экземпляре, и те изменения будут распространены
между ними. Поскольку больше HA имело отношение, параметры конфигурации смотрят на HA
Конфигурация.

23.6.3. Переменная установка: Создание локального кластера для того, чтобы протестировать

Если Вы хотите запустить кластер, подобный тому, описанному выше, но для
разработка и тестирующие цели, удобно выполнить все экземпляры Neo4j
на той же самой машине. Этого легко достигнуть, хотя это требует некоторых
дополнительная конфигурация как значения по умолчанию будет конфликтовать друг с другом.

23.6.3.1. Загрузите и распакуйте Neo4j Enterprise

Download Neo4j Enterprise от сайта для скачивания Neo4j <http://neo4j.org/
загрузка>, и распаковывает в 3 отдельных каталога на Вашей тестовой машине.

23.6.3.2. Сконфигурируйте связанные настройки HA для каждой установки

Следующие настройки должны быть сконфигурированы для каждой установки Neo4j.

Экземпляр Neo4j #1-~/neo4j-01

conf/neo4j.properties:

# Уникальный идентификатор сервера для этого экземпляра Neo4j
# не может быть отрицательный идентификатор и должен быть уникальным
ха server_id = 1

# IP и порт для этого экземпляра, чтобы связать с для того, чтобы передать данные с
# другие neo4j экземпляры в кластере.
ha.server = 127.0.0.1:6363
online_backup_server = 127.0.0.1:6366

# IP и порт для этого экземпляра, чтобы связать с для того, чтобы передать информацию о кластере
# с другими neo4j экземплярами в кластере.
ха cluster_server = 127.0.0.1:5001

# Список других известных экземпляров в этом кластере
ха initial_hosts = 127.0.0.1:5001,127.0.0.1:5002,127.0.0.1:5003

conf/neo4j-server.properties

# расположение базы данных
org.neo4j.server.database.location=data/graph.db

# http порт (для всех данных, административных, и доступ UI)
org.neo4j.server.webserver.port=7474

# https порт (для всех данных, административных, и доступ UI)
org.neo4j.server.webserver.https.port=7484

# HA - Высокая доступность
# ЕДИНСТВЕННЫЙ - Единственный режим, значение по умолчанию.
org.neo4j.server.database.mode=HA

Экземпляр Neo4j #2-~/neo4j-02

conf/neo4j.properties:

# Уникальный идентификатор сервера для этого экземпляра Neo4j
# не может быть отрицательный идентификатор и должен быть уникальным
ха server_id = 2

# IP и порт для этого экземпляра, чтобы связать с для того, чтобы передать данные с
# другие neo4j экземпляры в кластере.
ha.server = 127.0.0.1:6364
online_backup_server = 127.0.0.1:6367

# IP и порт для этого экземпляра, чтобы связать с для того, чтобы передать информацию о кластере
# с другими neo4j экземплярами в кластере.
ха cluster_server = 127.0.0.1:5002

# Список других известных экземпляров в этом кластере
ха initial_hosts = 127.0.0.1:5001,127.0.0.1:5002,127.0.0.1:5003

conf/neo4j-server.properties

# расположение базы данных
org.neo4j.server.database.location=data/graph.db

# http порт (для всех данных, административных, и доступ UI)
org.neo4j.server.webserver.port=7475

# https порт (для всех данных, административных, и доступ UI)
org.neo4j.server.webserver.https.port=7485

# HA - Высокая доступность
# ЕДИНСТВЕННЫЙ - Единственный режим, значение по умолчанию.
org.neo4j.server.database.mode=HA

Экземпляр Neo4j #3-~/neo4j-03

conf/neo4j.properties:

# Уникальный идентификатор сервера для этого экземпляра Neo4j
# не может быть отрицательный идентификатор и должен быть уникальным
ха server_id = 3

# IP и порт для этого экземпляра, чтобы связать с для того, чтобы передать данные с
# другие neo4j экземпляры в кластере.
ha.server = 127.0.0.1:6365
online_backup_server = 127.0.0.1:6368

# IP и порт для этого экземпляра, чтобы связать с для того, чтобы передать информацию о кластере
# с другими neo4j экземплярами в кластере.
ха cluster_server = 127.0.0.1:5003

# Список других известных экземпляров в этом кластере
ха initial_hosts = 127.0.0.1:5001,127.0.0.1:5002,127.0.0.1:5003

conf/neo4j-server.properties

# расположение базы данных
org.neo4j.server.database.location=data/graph.db

# http порт (для всех данных, административных, и доступ UI)
org.neo4j.server.webserver.port=7476

# https порт (для всех данных, административных, и доступ UI)
org.neo4j.server.webserver.https.port=7486

# HA - Высокая доступность
# ЕДИНСТВЕННЫЙ - Единственный режим, значение по умолчанию.
org.neo4j.server.database.mode=HA

23.6.3.3. Запустите Серверы Neo4j

Запустите серверы Neo4j как нормаль. Заметьте, что порядок запуска не имеет значение.

localhost: ~/neo4j-01$./bin/neo4j запускаются

localhost: ~/neo4j-02$./bin/neo4j запускаются

localhost: ~/neo4j-03$./bin/neo4j запускаются

Теперь, Вы должны быть в состоянии получить доступ к этим 3 серверам и проверить их состояние HA:

http://127.0.0.1:7474/webadmin/#/info/org.neo4j/High%20Availability/ <http://
127.0.0.1:7474/webadmin/#/info/org.neo4j/High%20Availability/>

http://127.0.0.1:7475/webadmin/#/info/org.neo4j/High%20Availability/ <http://
127.0.0.1:7475/webadmin/#/info/org.neo4j/High%20Availability/>

http://127.0.0.1:7476/webadmin/#/info/org.neo4j/High%20Availability/ <http://
127.0.0.1:7476/webadmin/#/info/org.neo4j/High%20Availability/>

23.7. Конечная точка REST для информации о статусе HA

23.7.1. Введение
23.7.2. Конечные точки
23.7.3. Примеры

23.7.1. Введение

Случай обычного использования для кластеров HA Neo4j должен предписать, чтобы вся запись запросила к
ведущее устройство, используя ведомые устройства для операций чтения, распределяя загрузку чтения
через кластер и и усиление failover возможности Вашего развертывания.
наиболее распространенный способ достигнуть этого состоит в том, чтобы разместить балансир загрузки перед HA
кластер, пример, показываемый с Прокси HA. Поскольку Вы можете видеть в том руководстве, этом
использует конечную точку REST, чтобы обнаружить, какой экземпляр - ведущее устройство и
прямая загрузка записи в это. В этом разделе мы будем иметь дело с этой конечной точкой REST
и объясните его семантику.

23.7.2. Конечные точки

Каждый экземпляр HA идет с 2 конечными точками относительно своего состояния HA. Они
приветственный, но каждый может использоваться в зависимости от Ваших потребностей балансирования загрузки и
Ваша производственная установка. Те:

  */db/manage/server/ha/master
  */db/manage/server/ha/slave

Чтобы использовать их, выполните HTTP, ПОЛУЧАЮТ работу на любом, и следующее будет
возвращенный:

Таблица 23.3. Реакции конечной точки REST HA

Государство Экземпляра конечной точки Возвратило Основной текст Кода
                            Ведущее устройство 200 истин OK

/db/manage/server/ha/master Ведомое устройство 404 Не Найденная ложь

                            Неизвестное 404 Не Найденное НЕИЗВЕСТНОЕ

                            Ведущее устройство 404 Не Найденная ложь

/db/manage/server/ha/slave Ведомое устройство 200 истин OK

                            Неизвестное 404 Не Найденное НЕИЗВЕСТНОЕ


23.7.3. Примеры

От командной строки распространенный способ спросить те конечные точки состоит в том, чтобы использовать завихрение. С
никакие параметры, завихрение сделает, HTTP Входит в обеспеченный URI и выведет
основной текст, если любой. Если Вы также хотите получить код реакции, только прибавить-v
флаг для многословного вывода. Вот некоторые примеры:

  * Запрос основной конечной точки на рабочем ведущем устройстве с многословным выводом

#> завихряются-v localhost:7474/db/manage/server/ha/master
* Собирающийся соединиться () с localhost портом 7474 (#0)
* Попытка:: 1...
* соединенный
* Соединенный с localhost (:: 1) порт 7474 (#0)
> ПОЛУЧИТЕ/db/manage/server/ha/master HTTP/1.1
> Пользовательский агент: завихрение/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8r zlib/1.2.5
> Узел: localhost:7474
> Примите: */*
>
<HTTP/1.1 200 OK
<Тип контента: текст/плоскость
<"Управление доступом Позволяет Источник": *
<Кодирование передачи: разделенный на блоки
<Сервер: Причал (6.1.25)
<
* Соединение #0, чтобы разместить localhost оставило неповрежденным
true* Заключительное соединение #0

  * Запрос ведомой конечной точки на рабочем ведущем устройстве без многословного вывода:

#> завихряются localhost:7474/db/manage/server/ha/slave
ложь

  * Наконец, запрашивая основную конечную точку на ведомом устройстве с многословным выводом

#> завихряются-v localhost:7475/db/manage/server/ha/master
* Собирающийся соединиться () с localhost портом 7475 (#0)
* Попытка:: 1...
* соединенный
* Соединенный с localhost (:: 1) порт 7475 (#0)
> ПОЛУЧИТЕ/db/manage/server/ha/master HTTP/1.1
> Пользовательский агент: завихрение/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8r zlib/1.2.5
> Узел: localhost:7475
> Примите: */*
>
<HTTP/1.1 404 Не Найденный
<Тип контента: текст/плоскость
<"Управление доступом Позволяет Источник": *
<Кодирование передачи: разделенный на блоки
<Сервер: Причал (6.1.25)
<
* Соединение #0, чтобы разместить localhost оставило неповрежденным
false* Заключительное соединение #0

Неизвестное состояние

НЕИЗВЕСТНОЕ состояние существует, чтобы описать, когда экземпляр Neo4j ни один не ведущее устройство
ни ведомое устройство. Например, экземпляр мог переходить между состояниями
(ведущее устройство к ведомому устройству в сценарии восстановления или ведомому устройству, способствовал ведущему устройству в
событие отказа). Если НЕИЗВЕСТНОЕ состояние возвращено, клиент не должен
обработайте экземпляр как ведущее устройство или ведомое устройство, и должен вместо этого выбрать другого
экземпляр в кластере, чтобы использовать, ожидайте экземпляра, чтобы передать транзитом от
НЕИЗВЕСТНОЕ состояние, или предпринимают укрепляющее действие через системного администратора.

23.8. Установка HAProxy как балансир загрузки

23.8.1. Конфигурирование HAProxy
23.8.2. Конфигурирование отдельных наборов для ведущего устройства и ведомых устройств
23.8.3. Основанный на кэше sharding с HAProxy

В архитектуре HA Neo4j на кластер обычно выходит загрузка
балансир. В этом разделе мы будем зондировать, как установить HAProxy, чтобы выполнить загрузку
балансирование через кластер HA.

Для этого учебного руководства мы уже примем среду Linux с HAProxy
установленный. См. http://haproxy.1wt.eu/ <http://haproxy.1wt.eu/> для загрузок
и инструкции по установке.

23.8.1. Конфигурирование HAProxy

HAProxy может быть сконфигурирован разными способами. Полная документация доступна в
их веб-сайт.

Для этого примера мы сконфигурируем HAProxy, чтобы загрузить запросы баланса в три
Серверы HA. Просто запишите следовать конфигурацию в/etc/haproxy.cfg:

глобальная переменная
    демон
    maxconn 256

значения по умолчанию
    режим http
    тайм-аут соединяет 5000 мс
    клиент тайм-аута 50000 мс
    сервер тайм-аута 50000 мс

фронтэнд http-в
    свяжите *:80
    default_backend neo4j

бэкэнд neo4j
    сервер s1 10.0.1.10:7474 maxconn 32
    сервер s2 10.0.1.11:7474 maxconn 32
    сервер s3 10.0.1.12:7474 maxconn 32

слушайте администратор
    свяжите *:8080
    stats включают

HAProxy может теперь быть запущен, работая:

/usr/sbin/haproxy-f/etc/haproxy.cfg

Вы можете соединиться с http://<ha-proxy-ip>:8080/haproxy? stats <http://
<ha-proxy-ip>:8080/haproxy? stats>, чтобы просмотреть инструментальную панель состояния. Эта инструментальная панель
может быть перемещен, чтобы работать на порту 80, и аутентификация может также быть прибавлена. См.
Документация HAProxy для деталей относительно этого.

23.8.2. Конфигурирование отдельных наборов для ведущего устройства и ведомых устройств

Возможно установить бэкэнды HAProxy до, только включают ведомые устройства или ведущее устройство.
Чтобы выполнить это, Neo4j обеспечивает медицинский осмотр URL что HAProxy (или любая загрузка
балансир в этом отношении), может использовать, чтобы отличить машины, используя реакцию HTTP
коды. Эти два URL:

  */db/manage/server/ha/master, который возвращается 200, если машина
    ведущее устройство, и 404, если машина - ведомое устройство
  */db/manage/server/ha/slave, который возвращается 200, если машина - ведомое устройство,
    и 404, если машина - ведущее устройство

Следующий пример исключает ведущее устройство из набора машин, так, чтобы
запросы только быть отправленными ведомым устройствам.

глобальная переменная
    демон
    maxconn 256

значения по умолчанию
    режим http
    тайм-аут соединяет 5000 мс
    клиент тайм-аута 50000 мс
    сервер тайм-аута 50000 мс

фронтэнд http-в
    свяжите *:80
    neo4j-ведомые-устройства default_backend

neo4j-ведомые-устройства бэкэнда
    опция httpchk ПОЛУЧАЕТ/db/manage/server/ha/slave
    сервер s1 10.0.1.10:7474 maxconn 32 проверки
    сервер s2 10.0.1.11:7474 maxconn 32 проверки
    сервер s3 10.0.1.12:7474 maxconn 32 проверки

слушайте администратор
    свяжите *:8080
    stats включают

Замечание

Практически, запись в ведомое устройство является редкой. В то время как запись в ведомые устройства имеет
преимущество обеспечения, что данные сохранены в двух местах (ведомое устройство и
ведущее устройство), это прибывает в стоимость. Стоимость - то, что ведомое устройство должно сразу стать
непротиворечивый с ведущим устройством, применяя любые транзакции отсутствия и затем
синхронно примените новую транзакцию с ведущим устройством. Это больше
дорогая работа чем запись в ведущее устройство и наличие основного нажатия
изменения к одному или более ведомым устройствам.

23.8.3. Основанный на кэше sharding с HAProxy

HA Neo4j включает то, что вызывают основанным на кэше sharding. Если набор данных является слишком большим
вписываться в кэш любой единственной машины, затем применяя непротиворечивое
направляя алгоритм к запросам, кэши на каждой машине будут фактически кэшироваться
различные части графика. Типичный ключ маршрутизации мог быть идентификатором пользователя.

В этом примере идентификатор пользователя - параметр запроса в URL, который требуют.
Это направит того же самого пользователя к той же самой машине для каждого запроса.

глобальная переменная
    демон
    maxconn 256

значения по умолчанию
    режим http
    тайм-аут соединяет 5000 мс
    клиент тайм-аута 50000 мс
    сервер тайм-аута 50000 мс

фронтэнд http-в
    свяжите *:80
    neo4j-ведомые-устройства default_backend

neo4j-ведомые-устройства бэкэнда
    сбалансируйте url_param user_id
    сервер s1 10.0.1.10:7474 maxconn 32
    сервер s2 10.0.1.11:7474 maxconn 32
    сервер s3 10.0.1.12:7474 maxconn 32

слушайте администратор
    свяжите *:8080
    stats включают

Естественно медицинский осмотр и запрашивает основанную на параметре маршрутизацию, может быть объединен к
только маршрут запрашивает к ведомым устройствам идентификатором пользователя. Другие алгоритмы балансирования загрузки
также доступный, такие как маршрутизация исходным IP (источник), URI (туры) или HTTP
головные части (hdr).

Глава 24. Резервное копирование

Замечание

Резервные функции только доступны в Neo4j Enterprise Edition.

24.1. Представление Резервного копирования

Резервные копии выполняются по сети, переменной от рабочей базы данных графика на
локальная копия. Есть два типа резервного копирования: полный и инкрементный.

Полные резервные копии файлы базы данных, не получая блокировок, позволяя
для продолжительных операций на целевом экземпляре. Это, конечно, означает это
копируя, транзакции будут продолжаться, и хранилище изменится. Для этого
причина, транзакция, которая работала, когда резервная работа запускалась,
замеченный и, когда работа копии завершается, все транзакции от последнего
вниз к тому, происходящему в конце копии, воспроизводятся на резервном копировании
файлы. Это гарантирует, что поддержанные данные представляют непротиворечивое и
актуальный снимок хранения базы данных.

Напротив, инкрементное резервное копирование не копирует, хранят файлы  -  вместо этого это
копирует журналы транзакций, которые имели место начиная с последнего полного
или инкрементное резервное копирование, которые тогда воспроизводятся по существующему резервному хранилищу.
Это делает инкрементные резервные копии далеко более эффективными чем выполнение полных резервных копий каждый
время, но они также требуют, чтобы полное резервное копирование имело место прежде, чем они будут
выполняемый.

Резервный инструмент обнаружит, пытаетесь ли Вы выполнить полное резервное копирование или
инкрементный, осматривая целевой каталог. Независимо от режима a
резервное копирование создается с, следующие файлы представляют непротиворечивую базу данных
снимок и они могут использоваться, чтобы загрузить экземпляр Neo4j.

База данных, которая будет поддержана, определена, используя URI с синтаксисом

<рабочий режим>://<узел> [:port] {<узел> [:port] *}

Рабочий режим должен быть определен и или единственный для неHA или ха для HA
кластеры. <Узел> [:port] часть указывает на узел, выполняющий базу данных, на порту
порт, если не значение по умолчанию. Дополнительные host:port параметры полезны для
передача разнообразных элементов кластера.

Важный

С версии 1.9 резервные копии включены по умолчанию. Это означает что
параметр конфигурации online_backup_enabled значения по умолчанию к истине и это делает
резервная служба, доступная на порту значения по умолчанию (6362). Включать резервному копированию
служба на различный порт использует online_backup_server =:9999.

24.2. Сервер и Встроенный

Выполнять резервное копирование от встроенного выполнения или выполненная база данных сервера:

# Выполнение полного резервного копирования: создайте пустой каталог и выполните резервный инструмент
mkdir/mnt/backup/neo4j-backup
./neo4j-backup - от single://192.168.1.34 - к/mnt/backup/neo4j-backup

# Выполнение инкрементного резервного копирования: только определите расположение своего предыдущего резервного копирования
./neo4j-backup - от single://192.168.1.34 - к/mnt/backup/neo4j-backup

# Выполнение инкрементного резервного копирования, где служба зарегистрирована на пользовательском порту
./neo4j-backup - от single://192.168.1.34:9999 - к/mnt/backup/neo4j-backup

24.3. Онлайновое Резервное копирование от Java

Чтобы программно сделать копию Ваших полных данных или впоследствии инкрементный
из базируемой программы JVM Вы должны записать код Java как

OnlineBackup делают копию = OnlineBackup.from ("127.0.0.1");
backup.full (backupPath.getPath);
backup.incremental (backupPath.getPath);

Для получения дополнительной информации, пожалуйста, см. Javadocs для OnlineBackup <http://
components.neo4j.org/neo4j-enterprise/2.0.0/apidocs/org/neo4j/backup/
OnlineBackup.html>

24.4. Высокая доступность

Чтобы выполнить резервное копирование на кластере HA, Вы определяете один или более элементов
целевой кластер HA. Заметьте, что адреса, которые Вы должны обеспечить, являются кластером
сервер адресуется а не адреса сервера HA. Таким образом, используйте значение
ха cluster_server приведение в движение конфигурации.

# Выполнение резервного копирования от кластера HA, определяя только один элемент кластера
./neo4j-backup - от ha://192.168.1.15:5001 - к/mnt/backup/neo4j-backup

# Выполнение резервного копирования от кластера HA, определяя два возможных элемента кластера
./neo4j-backup - от ha://192.168.1.15:5001,192.168.1.16:5002 - к/mnt/backup/neo4j-backup

24.5. Восстановление Ваших Данных

Резервные копии Neo4j - полностью функциональные базы данных. Чтобы использовать резервное копирование, все, Вы нуждаетесь
сделать замену Ваш прибор для испытания на излом базы данных с резервным копированием. Только удостоверьтесь база данных
не работает, заменяя прибор для испытания на излом.

Глава 25. Безопасность

Neo4j сам по себе не осуществляет безопасность на уровне данных. Однако, есть
различные аспекты, которые нужно рассмотреть при использовании Neo4j в различном
сценарии. См. Раздел 25.1, “Защищая доступ к Серверу Neo4j” для деталей.

25.1. Обеспечение доступа к Серверу Neo4j

25.1.1. Защитите порт и отдалите клиентское соединение, принимает
25.1.2. Произвольное выполнение кода
25.1.3. Поддержка HTTPS
25.1.4. Правила Авторизации сервера
25.1.5. Размещенные Сценарии
25.1.6. Безопасность подробно

25.1.1. Защитите порт и отдалите клиентское соединение, принимает

По умолчанию, Сервер Neo4j связан веб-сервером, который связывает, чтобы разместить
localhost на порту 7474, отвечая только запрашивает от локальной машины.

Это сконфигурировано в conf/neo4j-server.properties файл:

# http порт (для всех данных, административных, и доступ UI)
org.neo4j.server.webserver.port=7474

#let веб-сервер только слушают на указанном IP. Значение по умолчанию
#is localhost (только принимают локальные соединения). Некомментарий, чтобы позволить
#any соединение.
#org.neo4j.server.webserver.address=0.0.0.0

Если Вы должны включить доступу от внешних узлов, сконфигурируйте веб-сервер в
conf/neo4j-server.properties, устанавливая свойство
org.neo4j.server.webserver.address=0.0.0.0, чтобы включить доступу от любого узла.

25.1.2. Произвольное выполнение кода

По умолчанию, Сервер Neo4j идет с некоторыми местами где произвольный код кода
выполнение может произойти. Они - Раздел 19.15, конечные точки REST "Обходов".
Чтобы защитить их, любой отключает их полностью, перемещая оскорбление плагинов
от пути к классу сервера, или безопасного доступа к этим URL через прокси или
Правила авторизации. Кроме того, Руководитель службы безопасности Java, см. http://
docs.oracle.com/javase/7/docs/technotes/guides/security/index.html <http://
docs.oracle.com/javase/7/docs/technotes/guides/security/index.html> может использоваться
защитить части кодовой базы.

25.1.3. Поддержка HTTPS

Сервер Neo4j включает созданный в поддержку зашифрованной передачи SSL
HTTPS. В первый раз, когда сервер запускается, он автоматически генерирует a
самоподписанный сертификат SSL и закрытый ключ. Поскольку сертификат сам
подписанный, не безопасно положиться для производственного использования, вместо этого, Вы должны
обеспечьте свой собственный ключ и сертификат для сервера, чтобы использовать.

Чтобы обеспечить Ваш собственный ключ и сертификат, замените сгенерированный ключ и
сертификат, или изменение neo4j-server.properties файл, чтобы установить расположение
Ваш сертификат и ключ:

# расположение Сертификата (автоматический сгенерированный, если файл не существует),
org.neo4j.server.webserver.https.cert.location=ssl/snakeoil.cert

# расположение С закрытым ключом (автоматический сгенерированный, если файл не существует),
org.neo4j.server.webserver.https.key.location=ssl/snakeoil.key

Заметьте, что ключ должен быть незашифрован. Удостоверьтесь, что Вы устанавливаете корректные полномочия
на закрытом ключе, так, чтобы только пользователь сервера Neo4j мог чтение-запись это.

Neo4j также поддерживает объединенные в цепочку сертификаты SSL. Это требует, чтобы иметь все
сертификаты в формате PEM, объединенном в одном файле и закрытом ключе, должны быть
в формате DER.

Вы можете установить, с каким портом соединитель HTTPS должен связать в том же самом
конфигурационный файл, так же как выключают HTTPS:

# https-поддержка Поворота вкл\выкл
org.neo4j.server.webserver.https.enabled=true

# https порт (для всех данных, административных, и доступ UI)
org.neo4j.server.webserver.https.port=443

25.1.4. Правила Авторизации сервера

Администраторы могут требовать более мелкомодульной политики безопасности в дополнение к
Сужения на уровне IP на веб-сервер. Сервер Neo4j поддерживает администраторов
в разрешении или отвергании доступа определенные аспекты базы данных, основанной на
учетные данные, которые обеспечивают пользователи или приложения.

Облегчить проблемно-ориентированные политики авторизации в Сервере Neo4j,
SecurityRules <http://components.neo4j.org/neo4j-server/2.0.0/apidocs/org/neo4j
/server/rest/security/SecurityRule.html> может быть реализован и зарегистрирован в
сервер. Это делает сценарии как пользователь и безопасность на уровне ролей и
аутентификация против внешних возможных служб поиска.

25.1.4.1. Осуществление Правил Авторизации Сервера

В этом примере (фиктивное) правило безопасности сбоя зарегистрировано, чтобы лишить доступа
ко всем URI к серверу, перечисляя класс правил в neo4j-server.properties
:

org.neo4j.server.rest.security_rules=my.rules.PermanentlyFailingSecurityRule

с исходным кодом правила:

общедоступный класс PermanentlyFailingSecurityRule реализует SecurityRule
{

    общедоступная статическая конечная Строковая ОБЛАСТЬ = "WallyWorld";//согласно RFC2617 :-)

    @Override
    общедоступный булев isAuthorized (запрос HttpServletRequest)
    {
        возвратите false;//всегда перестал работать - производственная реализация выполняет
                      //специфичная для развертывания логика авторизации здесь
    }

    @Override
    общедоступная Строка forUriPath ()
    {
        возвратитесь "/*";
    }

    @Override
    общедоступная Строка wwwAuthenticateHeader ()
    {
        возвратитесь SecurityFilter.basicAuthenticationResponse (ОБЛАСТЬ);
    }
}

С этим зарегистрированным правилом будет лишен любой доступ к серверу. В a
качественная производством реализация правило будет вероятные учетные данные поиска /
требования в службе каталога 3-ьей стороны (например. LDAP) или в локальной базе данных
авторизованные пользователи.

Запрос в качестве примера

  * POST http://localhost:7474/db/data/node
  * Примите: application/json; charset=UTF-8

Реакция в качестве примера

  * 401: Неразрешенный
  * WWW - Аутентифицируйте: Основная область = "WallyWorld"

25.1.4.2. Используя Подстановочные знаки, чтобы Предназначаться для Правил безопасности

В этом примере правило безопасности зарегистрировано, чтобы лишить доступа ко всем URI к
сервер, перечисляя класс (ы) правила () в neo4j-server.properties. В этом
случай, правило зарегистрировано, используя подстановочный путь URI (где * символы могут
используйтесь, чтобы показать любую часть пути). Например/users* означает правило
будет связан с любыми ресурсами под / пользовательским корневым путем. Так же /
users*type* свяжет правило с ресурсами, соответствующими URI как/users/fred/type
/ премия.

org.neo4j.server.rest.security_rules=my.rules.PermanentlyFailingSecurityRuleWithWildcardPath

с исходным кодом правила:

общедоступная Строка forUriPath ()
{
    возвратитесь "/protected/*";
}

С этим зарегистрированным правилом будет лишен любой доступ к URI под/protected/
сервером. Используя подстановочные знаки позволяет гибкое предназначение правил безопасности к
произвольные части API сервера, включая любые неуправляемые расширения или
управляемые плагины, которые были зарегистрированы.

Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/protected/tree/starts/here/dummy/more/stuff
  * Примите: application/json

Реакция в качестве примера

  * 401: Неразрешенный
  * WWW - Аутентифицируйте: Основная область = "WallyWorld"

25.1.4.3. Используя Комплексные Подстановочные знаки, чтобы Предназначаться для Правил безопасности

В этом примере правило безопасности зарегистрировано, чтобы лишить доступа ко всем URI
соответствие комплексной модели. Конфигурация похожа на это:

org.neo4j.server.rest.security_rules=my.rules.PermanentlyFailingSecurityRuleWithComplexWildcardPath

с исходным кодом правила:

общедоступный класс PermanentlyFailingSecurityRuleWithComplexWildcardPath реализует SecurityRule
{

    общедоступная статическая конечная Строковая ОБЛАСТЬ = "WallyWorld";//согласно RFC2617 :-)

    @Override
    общедоступный булев isAuthorized (запрос HttpServletRequest)
    {
        возвратите false;
    }

    @Override
    общедоступная Строка forUriPath ()
    {
        возвратите "/protected/*/something/else/*/final/bit";
    }

    @Override
    общедоступная Строка wwwAuthenticateHeader ()
    {
        возвратитесь SecurityFilter.basicAuthenticationResponse (ОБЛАСТЬ);
    }
}

Запрос в качестве примера

  * ДОБИРАЮТСЯ http://localhost:7474/protected/wildcard_replacement/x/y/z/something/
    else/more_wildcard_replacement/a/b/c/final/bit/more/stuff
  * Примите: application/json

Реакция в качестве примера

  * 401: Неразрешенный
  * WWW - Аутентифицируйте: Основная область = "WallyWorld"

25.1.5. Размещенные Сценарии

Важный

neo4j сервер представляет удаленную функциональность сценариев по умолчанию, которые позволяют
полный доступ к базовой системе. Представление Вашего сервера без реализации
уровень безопасности излагает существенную уязвимость системы обеспечения безопасности.

25.1.6. Безопасность подробно

Хотя у сервера Neo4j есть много встроенных средств защиты (см.
выше глав), для чувствительного развертывания это часто разумно к передней стороне
против внешнего мира это с прокси как Apache mod_proxy ^ [1].

Это обеспечивает много преимуществ:

  * доступ Управления к серверу Neo4j к определенным IP-адресам, моделям URL
    и диапазоны IP. Это может использоваться, чтобы сделать например только/db/data
    пространство имен, доступное для нелокальных клиентов, в то время как/db/admin URL только
    ответьте на определенный IP-адрес.

    <Прокси *>
      Порядок Отрицает, Позволяет
      Отрицайте от всех
      Позвольте от 192.168.0
    </Прокси>

В то время как эквивалентная функциональность может быть реализована с SecurityRule Neo4j’s
плагины (см. выше), для профессионалов операций, конфигурирующих серверы как
Apache часто предпочтителен для разработки плагинов. Однако это должно быть замечено
это, где оба подхода используются, они будут работать, гармонично обеспечивая
поведение является непротиворечивым через сервер прокси и плагины SecurityRule.

  * Выполнение Сервер Neo4j как некорневой пользователь на системе Linux/Unix на порту <1000
    (например, порт 80) использование

    ProxyPass/neo4jdb/data http://localhost:7474/db/data
    ProxyPassReverse/neo4jdb/data http://localhost:7474/db/data

  * Простая загрузка, балансирующаяся в кластеризируемой среде к загрузке чтения баланса загрузки
    использование Apache mod_proxy_balancer ^ [2] плагин

    <Проксируют balancer://mycluster>
    BalancerMember http://192.168.1.50:80
    BalancerMember http://192.168.1.51:80
    </Прокси>
    ProxyPass / тестируют balancer://mycluster


--------------

^ [1] http://httpd.apache.org/docs/2.2/mod/mod_proxy.html <http://
httpd.apache.org/docs/2.2/mod/mod_proxy.html>

^ [2] http://httpd.apache.org/docs/2.2/mod/mod_proxy_balancer.html <http://
httpd.apache.org/docs/2.2/mod/mod_proxy_balancer.html>

Глава 26. Контроль

Замечание

Большинство контролирующих функций только доступно в Версии для предприятий
Neo4j.

Чтобы быть в состоянии непрерывно получить краткий обзор здоровья Neo4j
база данных, есть разные уровни контролирующих доступных средств. Больше всего
из них представлены через JMX <http://www.oracle.com/technetwork/java/javase
/tech/javamanagement-140525.html>.

26.1. Наладка удаленный доступ JMX к Серверу Neo4j

На значение по умолчанию выпуск Сервера Neo4j Enterprise не позволяет удаленный JMX
соединения, начиная с соответствующих опций в conf/neo4j-wrapper.conf
конфигурационный файл прокомментирован. Чтобы активировать эту опцию, Вы имеете к
переместите # символы от различных com.sun.management.jmxremote опций
там.

Когда комментирующийся в, значения по умолчанию установлены, чтобы позволить удаленный JMX
соединения с определенными ролями, обратитесь к conf/jmx.password, conf/jmx.access
и conf/neo4j-wrapper.conf файлы для деталей.

Удостоверьтесь, что у conf/jmx.password есть корректные полномочия файла. Владелец
файл должен быть пользователем, который выполнит службу, и полномочия
должно быть только для чтения для того пользователя. На системах Unix это 0600.

На Windows, следуйте за учебным руководством в http://docs.oracle.com/javase/7/docs/
technotes/guides/management/security-windows.html <http://docs.oracle.com/
javase/7/docs/technotes/guides/management/security-windows.html>, чтобы установить
корректные полномочия. Если Вы - обеспечение движения под Локальной Системой
Учетной записью, пользователь, который имеет файл и имеет доступ к этому, должна быть СИСТЕМА.

С этой установкой Вы должны быть в состоянии соединиться с контролем JMX Neo4j
сервер используя <IP СЕРВЕРА>:3637, с именем пользователя контролирует и пароль
Neo4j.

Заметьте, что возможно, что Вы должны обновить полномочия и/или
владение conf/jmx.password и conf/jmx.access файлов  -  обращается к
соответствующий раздел в conf/neo4j-wrapper.conf для деталей.

Предупреждение

Для максимальной безопасности, пожалуйста, отрегулируйте, по крайней мере, настройки пароля в conf/
jmx.password для производственной установки.

Для получения дополнительной информации, см.: http://docs.oracle.com/javase/7/docs/technotes/guides/
management/agent.html <http://docs.oracle.com/javase/7/docs/technotes/guides/
management/agent.html>.

26.2. Как соединиться с экземпляром Neo4j, используя JMX и JConsole

Во-первых, запустите свою встроенную базу данных или Сервер Neo4j, например используя

$NEO4j_HOME/bin/neo4j запускаются

Теперь, запустите JConsole с

$JAVA_HOME/bin/jconsole

Соединитесь с процессом, выполняющим Ваш экземпляр базы данных Neo4j:

Рисунок 26.1. Соединение JConsole к процессу Java Neo4j

Соединение с JConsole


Теперь, около MBeans, представленного JVM, Вы будете видеть org.neo4j раздел в
вкладка MBeans. Под этим у Вас будет доступ ко всему контролю
информация представлена Neo4j.

Для открытия JMX к доступу дистанционного мониторинга, пожалуйста, см. Раздел 26.1,
“Регулируя удаленный доступ JMX к Серверу Neo4j” и JMX documention
<http://docs.oracle.com/javase/7/docs/technotes/guides/management/agent.html>.
При использовании Neo4j во встроенном режиме, удостоверьтесь, что передали
com.sun.management.jmxremote.port=portNum или другая конфигурация как JVM
параметры к Вашему рабочему процессу Java.

Рисунок 26.2. Neo4j Представление MBeans

Neo4j MBeans представление


26.3. Как соединиться с JMX, контролирующим программно

Чтобы программно соединить с Neo4j JMX сервер, есть некоторые
методы удобства в компоненте управления Neo4j, чтобы помочь Вам узнать
обычно используемые контрольные атрибуты Neo4j. См. Раздел 32.10, “Читая
атрибут управления” для примера.

Как только у Вас есть доступ к этой информации, Вы можете использовать это, чтобы например представить
значения к SNMP <http://en.wikipedia.org/wiki/
Simple_Network_Management_Protocol> или другие системы контроля.

26.4. Ссылка поддерживаемого JMX MBeans

MBeans представлен Neo4j

  * Переходил Хранилище: информация о перешедших хранилищах, существующих в этом HA
    элемент кластера
  * Cache/NodeCache: информация о кэшировании в Neo4j
  * Cache/RelationshipCache: информация о кэшировании в Neo4j
  * Конфигурация: параметры конфигурации имели обыкновение конфигурировать Neo4j
  * Диагностика: Диагностика обеспечила Neo4j
  * Высокая доступность: информация об экземпляре, участвующем в HA
    кластер
  * Ядро: информация о ядре Neo4j
  * Блокировка: информация о Neo4j блокирует состояние
  * Отображение Памяти: состояние отображения памяти Neo4j
  * Примитивное количество: Оценки номеров различных видов Neo4j
    примитивы
  * размеры файла Хранилища: информация о размерах различных частей
    Хранилище графика Neo4j
  * Транзакции: информация о менеджере по транзакции Neo4j
  * Ресурсы XA: информация о менеджере по транзакции XA

Замечание

Для дополнительной информации о примитивных типах данных (интервал, долго и т.д.) используемый в
атрибуты JMX, пожалуйста, см. Таблицу 3.2, “Значение свойства вводит” в
Раздел 3.3, "Свойства".

Таблица 26.1. MBean Переходил Хранилище (org.neo4j.management. BranchedStore)
Атрибуты

Описание имени Тайп Рид Райт
    Информация о перешедших хранилищах, существующих в этом элементе кластера HA

BranchedStores список org.neo4j.management. BranchedStoreInfo да нет
               перешедший [] как CompositeData []
               хранилища


Таблица 26.2. MBean Cache/NodeCache (org.neo4j.management. Кэш) Атрибуты

Описание имени Тайп Рид Райт
                    Информация о кэшировании в Neo4j

CacheSize размер этого кэша (номер объектов или суммы долго да нет
          размер в байтах)

CacheType тип кэша, используемого Строкой Neo4j да нет

HitCount число раз запрос кэша возвратил результат долго да нет

MissCount число раз запрос кэша не возвращал длинное да нет
          результат


Таблица 26.3. MBean Cache/NodeCache (org.neo4j.management. Кэш) Операции

Описание имени Подпись ReturnType
четкий Очищает кэши Neo4j пусто (никакие параметры)


Таблица 26.4. MBean Cache/RelationshipCache (org.neo4j.management. Кэш)
Атрибуты

Описание имени Тайп Рид Райт
                    Информация о кэшировании в Neo4j

CacheSize размер этого кэша (номер объектов или суммы долго да нет
          размер в байтах)

CacheType тип кэша, используемого Строкой Neo4j да нет

HitCount число раз запрос кэша возвратил результат долго да нет

MissCount число раз запрос кэша не возвращал длинное да нет
          результат


Таблица 26.5. MBean Cache/RelationshipCache (org.neo4j.management. Кэш)
Операции

Описание имени Подпись ReturnType
четкий Очищает кэши Neo4j пусто (никакие параметры)


Таблица 26.6. Конфигурация MBean (org.neo4j.jmx.impl. ConfigurationBean)
Атрибуты

Описание имени Тайп Рид Райт
                      Параметры конфигурации имели обыкновение конфигурировать Neo4j

all_stores_total_mapped_memory_size размер, чтобы выделить для Строки да нет
                                                   отображение памяти объединяет в пул, чтобы быть
                                                   совместно использованный всеми хранилищами.

allow_store_upgrade, позволить Ли Строку хранилища да нет
                                                   обновите в случае, если ток
                                                   версия базы данных
                                                   запускается против более старого
                                                   версия хранилища. Установка этого
                                                   к истине не гарантирует
                                                   успешное обновление, только
                                                   то, что это позволяет попытку
                                                   в этом.

array_block_size Определяет Строку размера блока да нет
                                                   для того, чтобы сохранить массивы. Это
                                                   параметр только соблюдают
                                                   когда хранилище создается,
                                                   иначе это игнорируется.
                                                   Размер блока значения по умолчанию
                                                   120 байтов, и издержки
                                                   из каждого блока то же самое
                                                   что касается строковых блоков, то есть,
                                                   8 байтов.

backup_slave отмечают эту базу данных как Строка да нет
                                                   резервное ведомое устройство.

cache_type тип кэша, чтобы использовать Строку да нет
                                                   для вершин и
                                                   отношения. Заметьте это
                                                   Neo4j Enterprise
                                                   У выпуска есть дополнительное
                                                   тип кэша hpc
                                                   (Эффективный Кэш).
                                                   См. главу по кэшам
                                                   в справочнике для больше
                                                   информация.

cypher_parser_version Позволяют этому определить Строку да нет
                                                   синтаксический анализатор кроме
                                                   примите значение по умолчанию тот.

dump_configuration Распечатывают эффективную Строку да нет
                                                   Конфигурация Neo4j после
                                                   запуск.

кратковременная Строка атрибута Конфигурации да нет

forced_kernel_id идентификатор, который уникально Строка да нет
                                                   идентифицирует этот график
                                                   экземпляр базы данных в пределах
                                                   эта JVM. Значения по умолчанию к
                                                   автоматически сгенерированный номер
                                                   в зависимости от сколько
                                                   экземпляр запущен в
                                                   эта JVM.

gc_monitor_threshold количество времени в Строке мс да нет
                                                   поток монитора имеет к
                                                   будьте блокированы прежде, чем зарегистрировать a
                                                   сообщение это было блокировано.

Количество времени gc_monitor_wait_time в мс Строка GC да нет
                                                   поток монитора будет ожидать
                                                   прежде, чем взять другого
                                                   измерение.

ха allow_init_cluster, Ли позволить эту Строку да нет
                                                   экземпляр, чтобы создать a
                                                   кластер если неспособный, чтобы присоединиться.

ха branched_data_policy Политика для того, как обработать Строку да нет
                                                   перешедшие данные.

ха broadcast_timeout Тайм-аут для того, чтобы широковещательно передать Строку да нет
                                                   значения в кластере. Должен
                                                   рассмотрите впритык
                                                   продолжительность Paxos
                                                   алгоритм. Это значение
                                                   значение по умолчанию для
                                                   настройки ха join_timeout
                                                   и ха leave_timeout.

ха cluster_name имя кластера. Представьте да в виде строки нет

ха cluster_server Узел & порт, чтобы связать Строку да нет
                                                   управление кластером
                                                   передача.

ха com_chunk_size размер Макса данных разделяет Строку на блоки да нет
                                                   это течет между ведущим устройством
                                                   и ведомые устройства в HA. Больше
                                                   размер может увеличиться
                                                   пропускная способность, но может быть больше
                                                   чувствительный к вариациям в
                                                   пропускная способность, тогда как ниже
                                                   доведите до требуемого размера допуск увеличений
                                                   для вариаций пропускной способности.

ха configuration_timeout Тайм-аут для того, чтобы ожидать Строки да нет
                                                   конфигурация от
                                                   существующий элемент кластера
                                                   во время соединения кластера.

ха default_timeout тайм-аут Значения по умолчанию, используемый для Строки да нет
                                                   кластеризация тайм-аутов.
                                                   Переопределите определенный тайм-аут
                                                   настройки с собственными значениями
                                                   в случае необходимости. Это значение
                                                   значение по умолчанию для
                                                   настройки
                                                   ха heartbeat_interval,
                                                   ха paxos_timeout и
                                                   ха learn_timeout.

ха election_timeout Тайм-аут для того, чтобы ожидать Строки да нет
                                                   другие элементы, чтобы обработать начисто a
                                                   ролевые выборы. Значения по умолчанию к
                                                   ха paxos_timeout.

ха heartbeat_interval, Как часто Строка биения да нет
                                                   сообщения должны быть отправлены.
                                                   Значения по умолчанию к
                                                   ха default_timeout.

ха heartbeat_timeout Тайм-аут для Строки биений да нет
                                                   между элементами кластера.
                                                   Должен быть, по крайней мере, дважды
                                                   это
                                                   ха heartbeat_interval.

ха initial_hosts список разделенных запятой значений Строки да нет
                                                   другие элементы
                                                   кластер, чтобы присоединиться.

ха join_timeout Тайм-аут для того, чтобы соединить к Строке да нет
                                                   кластер. Значения по умолчанию к
                                                   ха broadcast_timeout.

ха learn_timeout Тайм-аут для того, чтобы изучить Строку да нет
                                                   значения. Значения по умолчанию к
                                                   ха default_timeout.

ха leave_timeout Тайм-аут для того, чтобы ожидать Строки да нет
                                                   отпуск кластера, чтобы закончить.
                                                   Значения по умолчанию к
                                                   ха broadcast_timeout.

ха lock_read_timeout Тайм-аут для того, чтобы взять удаленную Строку да нет
                                                   (запись) соединяет ведомые устройства.
                                                   Значения по умолчанию к
                                                   ха read_timeout.

ха max_concurrent_channels_per_slave Максимальное количество Строки да нет
                                                   соединения ведомое устройство могут
                                                   имейте ведущему устройству.

ха paxos_timeout тайм-аут Значения по умолчанию для всей Строки да нет
                                                   Тайм-ауты Paxos. Значения по умолчанию к
                                                   ха default_timeout. Это
                                                   значение - значение по умолчанию
                                                   для настроек
                                                   ха phase1_timeout,
                                                   ха phase2_timeout и
                                                   ха election_timeout.

ха phase1_timeout Тайм-аут для фазы 1 Paxos. Представьте да в виде строки нет
                                                   Значения по умолчанию к
                                                   ха paxos_timeout.

ха phase2_timeout Тайм-аут для фазы 2 Paxos. Представьте да в виде строки нет
                                                   Значения по умолчанию к
                                                   ха paxos_timeout.

ха pull_interval Интервал дергания за Ниточку обновлений да нет
                                                   от ведущего устройства.

ха read_timeout, Сколько времени ведомое устройство будет ожидать Строка да нет
                                                   для реакции от ведущего устройства
                                                   перед отказом.

ха server_id Идентификатор для экземпляра кластера. Представьте да в виде строки нет
                                                   Должно быть уникальным в пределах
                                                   кластер.

Имя узла ha.server и порт, чтобы связать Строку да нет
                                                   сервер HA.

ха slave_only, Ли эта Строка экземпляра да нет
                                                   должен только участвовать как
                                                   ведомое устройство в кластере. Если установлено в
                                                   истина, это никогда не будет
                                                   избранный ведущим устройством.

ха state_switch_timeout Тайм-аут для того, чтобы ожидать Строки да нет
                                                   экземпляр, чтобы стать ведущим устройством
                                                   или ведомое устройство.

ха tx_push_factor количество ведомых устройств Строка да нет
                                                   ведущее устройство спросит к
                                                   тиражируйте фиксировавший
                                                   транзакция.

ха tx_push_strategy стратегия Нажатия Строки да нет
                                                   транзакция к ведомому устройству
                                                   во время фиксации.

intercept_committing_transactions Определяет ли любая Строка да нет
                                                   TransactionInterceptors
                                                   загруженный прервет
                                                   готовые транзакции
                                                   прежде, чем они достигнут
                                                   логический журнал.

intercept_deserialized_transactions Определяет ли любая Строка да нет
                                                   TransactionInterceptors
                                                   загруженный прервет
                                                   внешним образом полученный
                                                   транзакции (например, в HA)
                                                   прежде, чем они достигнут
                                                   логический журнал и применен
                                                   к хранилищу.

Конфигурация jmx.port приписывает Строку да нет

keep_logical_logs Заставляют Neo4j сохранить логическую Строку да нет
                                                   журналы транзакций для того, чтобы быть
                                                   квалифицированный сделать копию
                                                   база данных. Может использоваться для
                                                   определение порога к
                                                   подрежьте логические журналы после.
                                                   Например "10 дней" будут
                                                   подрежьте логические журналы это
                                                   только содержит транзакции
                                                   более старый чем 10 дней от
                                                   текущее время, или "100 k txs"
                                                   сохранит 100 k самого последнего
                                                   транзакции и слива любой
                                                   более старые транзакции.

label_block_size Определяет Строку размера блока да нет
                                                   для того, чтобы сохранить метки
                                                   превышение встроенного пространства в
                                                   запись вершины. Этот параметр
                                                   только соблюдается когда
                                                   хранилище создается, иначе
                                                   это игнорируется. Значение по умолчанию
                                                   размер блока составляет 60 байтов, и
                                                   издержки каждого блока
                                                   то же самое что касается строки
                                                   блоки, то есть, 8 байтов.

log_mapped_memory_stats_filename файл, где Neo4j Представит да в виде строки нет
                                                   отображение памяти записи
                                                   статистика.

log_mapped_memory_stats_interval номер записей, чтобы быть Строкой да нет
                                                   загруженный между регулярным
                                                   журналирование отображения памяти
                                                   статистика.

log_mapped_memory_stats Говорят Neo4j регулярно регистрировать Строку да нет
                                                   статистика отображения памяти.

журналирование threshold_for_rotation Порога в байтах, для когда Строка да нет
                                                   журналы базы данных (текстовые журналы,
                                                   для того, чтобы отладить, который является)
                                                   повернутый.

logical_log_rotation_threshold Определяет в который Строка файла да нет
                                                   размер логический журнал будет
                                                   самовращаться. 0 средств это
                                                   никакое вращение не будет
                                                   автоматически происходите базируемые
                                                   на размере файла. Значение по умолчанию
                                                   25M

logical_log базовое имя для Строки да нет
                                                   логические файлы системного журнала, также
                                                   абсолютный путь или
                                                   относительно store_dir
                                                   установка. Это должно
                                                   обычно не быть измененным.

Целевой размер mapped_memory_page_size для нумерует страницу Строки да нет
                                                   расширенная память.

neo_store базовое имя для Строки Neo4j да нет
                                                   Храните файлы, любой
                                                   абсолютный путь или относительное число
                                                   к установке store_dir.
                                                   Это должно обычно нет
                                                   быть измененным.

neostore.nodestore.db.mapped_memory размер, чтобы выделить для Строки да нет
                                                   память, отображающая вершину
                                                   хранилище.

neostore.propertystore.db.arrays.mapped_memory размер, чтобы выделить для Строки да нет
                                                   память, отображающая массив
                                                   хранилище свойства.

neostore.propertystore.db.index.keys.mapped_memory размер, чтобы выделить для Строки да нет
                                                   память, отображающая хранилище
                                                   для ключевых строк свойства.

neostore.propertystore.db.index.mapped_memory размер, чтобы выделить для Строки да нет
                                                   память, отображающая хранилище
                                                   для свойства ключ индексирует.

neostore.propertystore.db.mapped_memory размер, чтобы выделить для Строки да нет
                                                   память, отображающая свойство
                                                   хранилище значения.

neostore.propertystore.db.strings.mapped_memory размер, чтобы выделить для Строки да нет
                                                   память, отображающая строку
                                                   хранилище свойства.

neostore.relationshipstore.db.mapped_memory размер, чтобы выделить для Строки да нет
                                                   память, отображающаяся
                                                   хранилище отношения.

Средства управления node_auto_indexing автоматическая Строка индексации да нет
                                                   функция вершин. Установка
                                                   ко лжи завершает работу этого,
                                                   в то время как истина включает этому
                                                   значение по умолчанию для свойств
                                                   перечисленный в
                                                   node_keys_indexable
                                                   установка.

node_keys_indexable список свойства называет Строку да нет
                                                   (разделенная запятая), который будет
                                                   будьте индексированы по умолчанию. Это
                                                   применяется к Вершинам только.

online_backup_enabled Включают поддержке выполнения Строки да нет
                                                   онлайновые резервные копии

online_backup_server Слушая сервер для онлайновой Строки да нет
                                                   резервные копии

read_only Только позволяют Строку операций чтения да нет
                                                   от этого экземпляра Neo4j.
                                                   Этот режим все еще требует
                                                   запишите доступ к
                                                   каталог для целей блокировки

Использование rebuild_idgenerators_fast быстрый подход для Строки да нет
                                                   восстановление ID
                                                   генераторы. Эта усадка
                                                   более быстрое время восстановления, но
                                                   ограничит возможность
                                                   повторно используйте пространство стертых
                                                   объекты.

Средства управления relationship_auto_indexing автоматическая Строка индексации да нет
                                                   функция отношений.
                                                   Установка в ложь закрывает это
                                                   вниз, в то время как истина включает этому
                                                   по умолчанию для свойств
                                                   перечисленный в
                                                   relationship_keys_indexable
                                                   установка.

relationship_grab_size, Сколько отношений, чтобы Представить да в виде строки нет
                                                   читайте за один раз во время
                                                   итерация

relationship_keys_indexable список свойства называет Строку да нет
                                                   (разделенная запятая), который будет
                                                   будьте индексированы по умолчанию. Это
                                                   применяется к Отношениям
                                                   только.

remote_logging_enabled, позволить Ли регистрировать Строку да нет
                                                   к удаленному серверу или нет.

Узел remote_logging_host к удаленной Строке журналирования да нет
                                                   использование LogBack
                                                   SocketAppender.

Порт remote_logging_port для удаленной Строки журналирования да нет
                                                   использование LogBack
                                                   SocketAppender.

remote_shell_enabled Включают удаленной Строке оболочки да нет
                                                   сервер, которые окружают клиенты
                                                   может войти в систему к

store_dir каталог, где Строка да нет
                                                   файлы базы данных расположены.

string_block_size Определяет Строку размера блока да нет
                                                   для того, чтобы сохранить строки. Это
                                                   параметр только соблюдают
                                                   когда хранилище создается,
                                                   иначе это игнорируется.
                                                   Заметьте что каждый символ в
                                                   строка занимает два
                                                   байты, означая, что блок
                                                   размер 120 (значение по умолчанию
                                                   размер), будет содержать 60
                                                   символ долго представляет в виде строки
                                                   прежде, чем переполниться в a
                                                   второй блок. Также замечание
                                                   то, что каждый групповые переносы
                                                   издержки 8 байтов. Это
                                                   средства это, если блок
                                                   размер 120, размер
                                                   сохраненные записи будут
                                                   128 байтов.

tx_manager_impl имя Строки Транзакции да нет
                                                   Служба менеджера, чтобы использовать как
                                                   определенный в службе ТМ
                                                   строитель провайдера.

use_memory_mapped_buffers Говорят Neo4j использовать Строку памяти да нет
                                                   отображенные буферы для
                                                   доступ к собственному
                                                   уровень хранения.


Таблица 26.7. Конфигурация MBean (org.neo4j.jmx.impl. ConfigurationBean)
Операции

Описание имени Подпись ReturnType
примените настройки Apply пусто (никакие параметры)


Таблица 26.8. Диагностика MBean (org.neo4j.management. Диагностика) Атрибуты

Описание имени Тайп Рид Райт
                         Диагностика обеспечила Neo4j

DiagnosticsProviders список идентификаторов для Списка да нет
                     зарегистрированная диагностика (java.util. Список)
                     провайдеры.


Таблица 26.9. Диагностика MBean (org.neo4j.management. Диагностика) Операции

Описание имени Подпись ReturnType
информация о диагностике Дампа dumpAll к Строке JMX (никакие параметры)

информация о диагностике Дампа dumpToLog к журналу. пусто (никакие параметры)

информация о диагностике Дампа dumpToLog к журналу. пусто java.lang. Строка

извлеките Работу, представленную для Строки управления java.lang. Строка


Таблица 26.10. Высокая доступность MBean (org.neo4j.management. HighAvailability)
Атрибуты

Описание имени Тайп Рид Райт
          Информация об экземпляре, участвующем в кластере HA

Под током, Ли булев да нет
                   это
                   экземпляр
                   под током или
                   нет

Доступный, Ли булев да нет
                   это
                   экземпляр
                   доступный
                   или нет

InstanceId Строка да нет
                   идентификатор
                   привыкший к
                   идентифицировать
                   этот сервер
                   в HA
                   кластер

Информация о InstancesInCluster org.neo4j.management. ClusterMemberInfo да нет
                   обо всех [] как CompositeData []
                   экземпляры
                   в этом
                   кластер

LastCommittedTxId самое последнее длинное да нет
                   транзакция
                   существующий идентификатор
                   в этом
                   экземпляр
                   хранилище

LastUpdateTime Строка времени да нет
                   когда
                   данные на
                   это
                   экземпляр
                   было последним
                   обновленный
                   от
                   ведущее устройство

Роль ролевая Строка да нет
                   это
                   экземпляр
                   имеет в
                   кластер


Таблица 26.11. Высокая доступность MBean (org.neo4j.management. HighAvailability)
Операции

Описание имени Подпись ReturnType
обновление (Если это - ведомое устройство) Обновление база данных на этой Строке (нет
       экземпляр с самыми последними транзакциями от параметров)
       ведущее устройство


Таблица 26.12. Ядро MBean (org.neo4j.jmx. Ядро) Атрибуты

Описание имени Тайп Рид Райт
                      Информация о ядре Neo4j

KernelStartTime то, время, от который Дата (java.util. Дата) да нет
                  этот экземпляр Neo4j
                  был в операционном
                  режим.

KernelVersion версия Строки Neo4j да нет

MBeanQuery ObjectName, который может javax.management. ObjectName да нет
                  используйтесь в качестве запроса для
                  получение всего управления
                  бобы для этого Neo4j
                  экземпляр.

ReadOnly, является Ли это чтением, булевым да нет
                  только экземпляр

StoreCreationDate время, когда эта Дата (java.util. Дата) да нет
                  Хранилище графика Neo4j было
                  создаваемый.

StoreDirectory расположение, где Строка да нет
                  Хранилище Neo4j расположено

StoreId идентификатор, что, Строка да нет
                  вместе с хранилищем
                  время создания,
                  однозначно определяет
                  этот график Neo4j
                  хранилище.

StoreLogVersion текущая версия длинных да нет
                  хранилище Neo4j
                  логический журнал.


Таблица 26.13. MBean, Блокирующий (org.neo4j.management. LockManager) Атрибуты

Описание имени Тайп Рид Райт
                            Информация о Neo4j блокирует состояние

Информация о блокировках обо всех блокировках java.util. Перечислите да нет
                         сохраненный Neo4j <org.neo4j.kernel.info. LockInfo>
                                                     как CompositeData []

NumberOfAvertedDeadlocks номер блокировки долго да нет
                         последовательности, которые имели бы
                         приведите к тупику
                         ситуация, которую имеет Neo4j
                         обнаруженный и предотвращенный (
                         бросок
                         DeadlockDetectedException).


Таблица 26.14. MBean, Блокирующий (org.neo4j.management. LockManager) Операции

Описание имени Подпись ReturnType
getContendedLocks getContendedLocks java.util. Список долго
                                    <org.neo4j.kernel.info. LockInfo>
                                    как CompositeData []


Таблица 26.15. Отображение Памяти MBean (org.neo4j.management. MemoryMapping)
Атрибуты

Описание имени Тайп Рид Райт
                      Состояние отображения памяти Neo4j

MemoryPools Получают информацию org.neo4j.management. WindowPoolInfo да нет
            о каждом пуле [] как CompositeData []
            с отображенной памятью
            области от хранилища
            файлы с памятью
            отображение включено


Таблица 26.16. MBean Примитивное количество (org.neo4j.jmx. Примитивы) Атрибуты

Описание имени Тайп Рид Райт
        Оценки номеров различных видов примитивов Neo4j

NumberOfNodeIdsInUse оценка номера длинных да нет
                                 вершины используются в этом Neo4j
                                 экземпляр

NumberOfPropertyIdsInUse оценка номера длинных да нет
                                 свойства используются в этом Neo4j
                                 экземпляр

NumberOfRelationshipIdsInUse оценка номера длинных да нет
                                 отношения используются в этом
                                 Экземпляр Neo4j

NumberOfRelationshipTypeIdsInUse номер отношения долго да нет
                                 типы используются в этом Neo4j
                                 экземпляр


Таблица 26.17. Размеры файла Хранилища MBean (org.neo4j.jmx. StoreFile) Атрибуты

Описание имени Тайп Рид Райт
  Информация о размерах различных частей хранилища графика Neo4j

ArrayStoreSize количество дискового пространства имел обыкновение хранить долго да нет
                      свойства массива, в байтах.

LogicalLogSize количество дискового пространства, используемого длинным да нет
                      текущий Neo4j логический журнал, в байтах.

NodeStoreSize количество дискового пространства имел обыкновение хранить долго да нет
                      вершины, в байтах.

PropertyStoreSize количество дискового пространства имел обыкновение хранить долго да нет
                      свойства (исключая строковые значения и
                      выстройте значения), в байтах.

RelationshipStoreSize количество дискового пространства имел обыкновение хранить долго да нет
                      отношения, в байтах.

StringStoreSize количество дискового пространства имел обыкновение хранить долго да нет
                      строковые свойства, в байтах.

TotalStoreSize полное дисковое пространство, используемое этим Neo4j долго да нет
                      экземпляр, в байтах.


Таблица 26.18. Транзакции MBean (org.neo4j.management. TransactionManager)
Атрибуты

Описание имени Тайп Рид Райт
                Информация о менеджере по транзакции Neo4j

LastCommittedTxId идентификатор самого последнего длинного да нет
                                   фиксировавшая транзакция

NumberOfCommittedTransactions общее количество длинных да нет
                                   фиксировавшие транзакции

NumberOfOpenedTransactions общее количество запустил интервал да нет
                                   транзакции

NumberOfOpenTransactions номер в настоящий момент открытого интервала да нет
                                   транзакции

NumberOfRolledBackTransactions общее количество прокрученных, длинных да нет
                                   назад транзакции

PeakNumberOfConcurrentTransactions самое большое количество интервала да нет
                                   транзакции когда-либо открывались
                                   одновременно


Таблица 26.19. MBean XA Ресурсы (org.neo4j.management. XaManager) Атрибуты

Описание имени Тайп Рид Райт
                 Информация о менеджере по транзакции XA

Информация о XaResources о org.neo4j.management. XaResourceInfo да нет
            все ресурсы XA [] как CompositeData []
            управляемый
            менеджер по транзакции


Часть VI. Инструменты

Часть Инструментов описывает доступные инструменты Neo4j и как использовать их.

Оглавление

27. Веб-Интерфейс
28. Neo4j Shell

    28.1. Запуск оболочки
    28.2. Передача опций и параметров
    28.3. Перечислимые опции
    28.4. Фильтры
    28.5. Заголовки вершины
    28.6. Как использовать (индивидуальные команды)
    28.7. Сеанс оболочки в качестве примера
    28.8. Матричный пример

Глава 27. Веб-Интерфейс

Веб-Интерфейс Neo4j - интерфейс основного пользователя для Neo4j.

Инструмент доступен в http://127.0.0.1:7474/ <http://127.0.0.1:7474/> после
Вы установили Сервер Neo4j.

См. инструмент непосредственно для получения дополнительной информации!

Глава 28. Neo4j Shell

Оболочка Neo4j - оболочка командной строки для того, чтобы выполнить запросы Кода. Есть также
команды, чтобы получить информацию о базе данных. Кроме того, Вы можете просмотреть
график, очень как то, как оболочка Unix наряду с командами как cd, ls и pwd может
используйтесь, чтобы просмотреть Вашу локальную файловую систему.

Это - хороший инструмент для разработки и отладки. Это руководство покажет Вам как
получите это продвижение!

28.1. Запуск оболочки

28.1.1. Включение серверу оболочки
28.1.2. Соединение с сервером оболочки
28.1.3. Указание на оболочку к пути
28.1.4. Режим только для чтения
28.1.5. Выполните команду и затем выйдите
28.1.6. Передайте параметры конфигурации Neo4j
28.1.7. Выполните файл и затем выйдите

Когда использующийся вместе с сервером Neo4j, просто выпустите следующее в
командная строка:

./bin/neo4j-shell

Для полного списка опций, см. ссылку в странице руководства Shell.

Чтобы соединить с выполнением базу данных Neo4j, используйте Раздел 28.1.4, “Режим Только для чтения”
для локальных баз данных и см. Раздел 28.1.1, “Включая серверу оболочки” для
удаленные базы данных.

Вы должны удостовериться, что файл толчка оболочки находится на пути к классу когда Вы
запустите свой экземпляр Neo4j.

28.1.1. Включение серверу оболочки

Shell включают от конфигурации ядра Neo4j, см. Раздел 22.2,
“Конфигурация сервера”. Вот некоторые демонстрационные конфигурации:

# Активируют удаленную опцию оболочки
remote_shell_enabled = истина

# порт значения по умолчанию - 1337, но Вы можете определить что-то еще, если Вам нравится
remote_shell_port = 1337

#, Если Вы хотите быть немного защитными Ваших данных,
# Вы можете также сказать оболочке только поддерживать операции чтения
remote_shell_read_only = истина

При использовании сервера Neo4j, см. Раздел 22.2, “Конфигурация Сервера” для как
прибавлять настройки конфигурации в этом случае.

Есть два способа запустить оболочку, любого, соединяясь с удаленной оболочкой
сервер или указывая на это на Neo4j хранит путь.

28.1.2. Соединение с сервером оболочки

Чтобы запустить оболочку и соединиться с рабочим сервером, работайте:

neo4j-оболочка

Альтернативно предоставление - порт и - называет опции в зависимости от как удаленная оболочка
сервер был включен. Затем Вы получите подсказку оболочки как это:

neo4j-sh (0) $

28.1.3. Указание на оболочку к пути

Чтобы запустить оболочку, только указывая, это на Neo4j хранит путь, Вы выполняете оболочку
файл толчка., Учитывая, что правильное neo4j-ядро - <версия>.jar и файлы толчка jta
в том же самом пути как Ваша neo4j-оболочка - <версия>.jar файл Вы выполняете это с:

Neo4j-оболочка $ - путь path/to/neo4j-db

28.1.4. Режим только для чтения

Выходя - переключатель только для чтения, запуская оболочку с пути хранилища,
изменения не могут быть произведены в базе данных во время сеанса.

Neo4j-оболочка $ - только для чтения - путь path/to/neo4j-db

28.1.5. Выполните команду и затем выйдите

Возможно сказать оболочке только запускать, выполнять команду и затем
выход. Это открывается для использования низкоприоритетных заданий и также обработки огромных
вывод f.ex. ls команда, где Вы тогда могли передать вывод по каналу к меньше или
другой читатель Вашего выбора, или даже к файлу.

И даже к другой neo4j-оболочке, например, для того, чтобы импортировать дамп другой базы данных
или результат кода. Когда использующийся с командным режимом оболочка не будет выводить a
приветствуйте сообщение. Так некоторые примеры использования:

$ neo4j-окружают-c "cd-a 24 && определенное имя Маттиас"
$ neo4j-окружают-c "trav-r, ЗНАЕТ" | меньше

28.1.6. Передайте параметры конфигурации Neo4j

Устанавливая - переключатель конфигурации, Вы можете обеспечить файл свойств, который будет
используемый, чтобы сконфигурировать Ваш экземпляр Neo4j, если запущено во встроенном режиме.

Neo4j-оболочка $ - конфигурация conf/neo4j.properties - путь mydb

28.1.7. Выполните файл и затем выйдите

Чтобы выполнить команды от файла и затем выйти только обеспечивают - имя файла файла.
Это более быстро чем передача по каналу к оболочке, которая все еще обрабатывает ввод как будто она
был ввод данных пользователем.

Например читая файл дампа прямо из командной строки и выполняя это
против данной базы данных. Например:

Neo4j-оболочка $ - файл export.cql> result.txt

Предоставляя - поскольку имя файла читает из stdin вместо этого.

28.2. Передача опций и параметров

Передача опций и параметров Вашим командам очень подобна многим CLI
команды в *nix среде. Опции снабжены префиксом - и могут делиться без остатка
одна или более опций. Некоторые опции ожидают, что значение будет связано с этим.
Параметры - строковые значения, которые не снабжены префиксом-. Пустите нам смотреть на ls как
пример:

ls-r-f KNOWS:out-v 12345 сделает полную распечатку вершины 12345
исходящие отношения типа ЗНАЮТ. Идентификатор вершины, 12345, является параметром ls
который говорит этому делать перечисление на той вершине вместо текущей вершины (см.
команда pwd). Однако более короткая версия этого может быть записана:

ls-rfv KNOWS:out 12345. Здесь все три опции записаны вместе после a
единственный - префикс. Даже при том, что f находится в середине, это получает связанным с
Значение KNOWS:out. Причина этого состоит в том, что ls команда не ожидает никого
значения связались с r или v опциями. Так, это может вывести правильные значения
для опций прав.

28.3. Перечислимые опции

Некоторые опции ожидают значение, которое является одним из значений в перечислении, f.ex.
часть направления фильтрации типа отношения, где там ПОСТУПАЕТ, ИСХОДЯ
и ОБА. Все такие значения могут быть предоставлены более легким способом. Это - достаточно это
Вы пишете запуск значения, и интерпретатор обнаружит что Вы действительно
предназначенный. F.ex., в, я или четное ПОСТУПЛЕНИЕ.

28.4. Фильтры

Некоторые команды используют фильтры для того, чтобы изменить цели. F.ex.-f в ls и в
trav. Фильтр предоставлен как json <http://www.json.org/> объект (w/или w/o
окружение {} скобки. И ключи и значения могут делиться без остатка регулярный
выражения для более гибкого соответствия. Пример фильтра мог быть
.*url.*:http.*neo4j. *, name:Neo4j. Опция фильтра также сопровождается
опции-i и-l, который обозначает, игнорируют регистр (преобразование регистра знака при полном отсутствии действий
символы) и неточное соответствие (это рассмотрело соответствие даже если фильтр
оцените только соответствует часть сравненного значения, не обязательно все
значение). Так для нечувствительного к регистру, неточного фильтра Вы можете предоставить фильтр-f
-i-l или-fil для краткости

28.5. Заголовки вершины

Чтобы облегчить перемещаться по Вашему графику, оболочка может вывести на экран заголовок для каждого
вершина, f.ex. в ls-r. Это выведет на экран отношения так же как вершины на
другая сторона отношений. Заголовок выведен на экран вместе с каждым
вершина и ее лучшее удовлетворенное значение свойства от списка ключей свойства.

Если Вы стоите на вершине, которая имеет два, ЗНАЕТ отношения к другим вершинам
было бы трудно знать, который друг который. Адреса функции заголовка
это, читая список ключей свойства и захватывая первое существующее
значение свойства тех ключей и дисплеев это как заголовок для вершины. Так Вы
может определить список (с или без регулярных выражений), f.ex:
имя, title. *, заголовок и заголовок для каждой вершины будет значением свойства
первый существующий ключ в том списке. Список определен клиентом (Вы)
использование переменной окружения TITLE_KEYS (см. Раздел 28.6.7, “Среда
переменные”) и значение по умолчанию, являющееся.*name. *.*title.*

28.6. Как использовать (индивидуальные команды)

28.6.1. Комментарии
28.6.2. Текущая вершина/отношение и путь
28.6.3. Перечисление содержания вершины/отношения
28.6.4. Создание вершин и отношений
28.6.5. Установка, переименование и передвижение свойств
28.6.6. Удаление вершин и отношений
28.6.7. Переменные окружения
28.6.8. Выполнение отличных сценариев / сценариев питона
28.6.9. Траверз
28.6.10. Запрос с Кодом
28.6.11. Перечисление Индексирует и Ограничения
28.6.12. Индексация наследства
28.6.13. Транзакции
28.6.14. Дамп базы данных или кода следует к операторам Cypher

Оболочка смоделирована после оболочек Unix как удар, который Вы используете, чтобы идти вокруг
Ваша локальная файловая система. У этого есть некоторые из тех же самых команд, как cd и ls. Когда
Вы сначала запускаете оболочку (см. инструкции выше), Вы получите список всех
доступные команды. Используйте человека <команда>, чтобы получить больше информации о детали
команда. Некоторые замечания:

28.6.1. Комментарии

Однострочные комментарии, которые будут игнорироваться, могут быть сделаны при использовании префикса /
/. Пример:

//Это - комментарий

28.6.2. Текущая вершина/отношение и путь

У Вас есть текущая вершина/отношение и "текущий путь" (как ток
рабочий каталог в ударе), что Вы до сих пор пересекали. Когда оболочка сначала
запускается Вы не расположены ни на какой объект, но Вы можете cd Ваш путь через
график (проверяют Ваш текущий путь в любое время с pwd командой). cd может быть
используемый по-разному:

  * cd <идентификатор вершины> пересечет одно отношение к предоставленному идентификатору вершины.
    у вершины должна быть непосредственная связь к текущей вершине.
  * cd-a <идентификатор вершины> сделает абсолютное изменение пути, что означает предоставленный
    у вершины не должно быть непосредственной связи к текущей вершине.
  * cd-r <идентификатор отношения> пересечет к отношению вместо вершины.
    У отношения должна быть текущая вершина или как запуститься или как конечная точка.
    Видеть, что идентификаторы отношения используют ls - команда стабиловольта на вершинах.
  * cd - площадь <идентификатор отношения> сделает абсолютное изменение пути, что означает
    отношение может быть любым отношением в графике.
  * cd.. пересечет назад один шаг к предыдущему расположению, перемещая
    последний элемент пути от Вашего текущего пути (pwd).
  * cd запускается (только если Ваше текущее расположение - отношение). Траверзы к
    вершина запуска отношения.
  * конец cd (только если Ваше текущее расположение - отношение). Траверзы к
    конечный узел отношения.

28.6.3. Перечисление содержания вершины/отношения

Содержание списка текущей вершины/отношения (или любой другой вершины) с ls
команда. Пожалуйста, заметьте, что это даст пустой вывод если текущая вершина /
у отношения нет никаких свойств или отношений (например в случае a
совершенно новый график). ls может взять идентификатор вершины в качестве параметра так же как фильтров, видеть
Раздел 28.4, "Фильтры" и для информации о том, как определить направление, видят
Раздел 28.3, “Перечислимые опции”. Используйте человека ls для большего количества информации.

28.6.4. Создание вершин и отношений

Вы создаете новые вершины, соединяя их с отношениями к текущей вершине.
Например, mkrel-t A_RELATIONSHIP_TYPE-d ИСХОДЯЩИЙ-c создаст новую вершину
(-c) и тяга к этому ИСХОДЯЩЕЕ отношение типа A_RELATIONSHIP_TYPE от
текущая вершина. Если бы у Вас уже есть две вершины, которые Вы хотели бы тянуть a
отношение между (не создавая новую вершину) Вы можете сделать например,
mkrel-t A_RELATIONSHIP_TYPE-d ИСХОДЯЩИЙ-n <другой идентификатор вершины> и это будет только
создайте новое отношение между текущей вершиной и что другая вершина.

28.6.5. Установка, переименование и передвижение свойств

Операции свойства сделаны с набором, милливольтом и командами комнаты. Эти команды
работает на текущей вершине/отношении.

Используйте набор <ключ> <значение>, дополнительно с-t опцией (для типа значения), чтобы установить a
свойство. Поддерживает каждый тип имеющий значение, который поддерживает Neo4j. Примеры a
свойство интервала типа:

$ устанавливают-t международный возраст 29

И пример установки двойного количества [] свойство:

$ устанавливают двойное количество-t [] my_values [1.4,12.2,13]

Пример установки свойства String, содержащего строку ДЖСОНА:

mkrel-c-d i-t DOMAIN_OF - np" {'приложение':'foobar'}"

  * комната <ключ> перемещает свойство.
  * милливольт <ключ> <новый ключ> переименовывает свойство от одного ключа до другого.

28.6.6. Удаление вершин и отношений

Удаление вершин и отношений сделано с rmnode и rmrel командами.
rmnode может стереть вершины, если у вершины, которая будет стерта все еще, есть отношения они
может также быть стерт, предоставляя-f опция. rmrel может стереть отношения, это
попытки гарантировать связность в графике, но отношения могут быть стерты
независимо с-f опцией. rmrel может также стереть вершину с другой стороны
из стертого отношения, если это оставляют без большего количества отношений, см.-d
опция.

28.6.7. Переменные окружения

Оболочка использует удар крыла переменных окружения, чтобы хранить информацию сеанса,
такой как текущий путь и больше. Команды для этого подражают удару
экспорт команд и конверт. Например Вы можете в в любое время проблеме экспорт
Команда STACKTRACES=true, чтобы установить переменную окружения STACKTRACES в истину.
Это будет тогда следовать stacktraces быть печатаемым если исключение или погрешность
должен произойти. Позволенные значения - все parseable строки ДЖСОНА, так карты
{age:10, имя: "Маттиас"} и массивы [1,2,3] также поддерживается.

Переменные могут также быть присвоены друг другу. Например, a=b будет следовать a
содержание значения b.

Это становится особенно интересным, как все переменные оболочки автоматически
переданный к операторам кода как параметры. Это облегчает запрашивать для
определенные вершины запуска или создают вершины и отношения с обеспеченным определенным
свойства (как карты).

Значения удалены, устанавливая в NULL их или пустое значение. Среда списка
переменные используя конверт

28.6.8. Выполнение отличных сценариев / сценариев питона

У оболочки есть поддержка выполнения сценариев, таких как Groovy <http://
groovy.codehaus.org> и Python <http://www.python.org> (через Jython <http://
www.jython.org>). На данный момент сценарии (*.groovy, *.py) должны существовать на
сторона сервера и получает вызванной от клиента с например, gsh - renamePerson
1234 "Матиас" "Маттиас" - doSomethingElse, где сценарии
renamePerson.groovy и doSomethingElse.groovy должны существовать на стороне сервера в
любой из путей, данных переменной окружения GSH_PATH (значения по умолчанию к
.:src:src/script). Эта переменная походит на путь к классу java, разделенный a:.
python/jython сценарии могут быть выполнены с jsh подобным способом,
однако у сценариев есть.py расширение и переменная окружения для
пути - JSH_PATH.

Когда запись сценариев предполагает, что там сделал доступным args переменная (a
Строка []), который содержит предоставленные параметры. В случае
пример renamePerson выше массива делился бы без остатка ["1234", "Матиас",
"Маттиас"]. Также, пожалуйста, запишите свои выводы в переменная, такой как
out.println ("Мой текст трассировки") так, чтобы это печаталось в клиенте оболочки
вместо сервера.

28.6.9. Траверз

Вы можете пересечь график с trav командой, которая учитывает простой
полигонометрия от текущей вершины. Вы можете предоставить, который вводит отношение (w/
соответствие regex), и дополнительно направление так же как свойство фильтрует для
соответствие вершин. В дополнение к этому Вы можете предоставить командную строку, чтобы выполниться
для каждого соответствия. Пример: trav-o глубина-r KNOWS:both, HAS_.*:incoming-c "ls
$n". Что означает, что глубина траверза сначала для отношений с типом ЗНАЕТ
игнорирование направления и входящих отношений с типом, соответствующим HAS_.\*
и сделайте ls <соответствие вершины> для каждого соответствия. Фильтрация вершины предоставлена
-f опция, см. Раздел 28.4, "Фильтры". См. Раздел 28.3, “Перечислимые опции”
поскольку обход упорядочивает опцию. Предоставлены четные типы/направления отношения
использование того же самого формата как фильтры.

28.6.10. Запрос с Кодом

Вы можете использовать Код, чтобы запросить график. Для этого, используйте соответствие или запустите
команда. Вы можете также использовать, создают операторы, чтобы создать вершины и отношения
и используйте префикс ВЕРСИИ кода, чтобы выбрать определенную версию кода.

Подсказка

Запросы кода должны быть завершены точкой с запятой;.

Командам кода дают все переменные оболочки как параметрам и специальному предложению
сам параметр для текущей вершины или отношения.

  * запускают n = вершина (0) возврат n; даст Вам перечисление вершины с ID 0
  * кодируют 1.9, запускают n = вершина (0) возврат n; выполнит запрос с Кодом
    версия 1.9
  * ЗАПУСКАЮТ n = вершина ({сам}) СООТВЕТСТВИЕ (n) - [:KNOWS] → (друг) друг ВОЗВРАТА; будет
    возвратите вершины, соединенные с текущей вершиной.
  * ЗАПУСКАЮТСЯ, n=node ({меня}) СОЗДАЮТ друга = {опоры}, (я) - [r:KNOWS] → (друг); будет
    создайте друга и отношение согласно переменным
    доступный.

28.6.11. Перечисление Индексирует и Ограничения

Команда схемы позволяет перечислять, все существующие индексируют и ограничения вместе
с их текущим статусом.

Замечание

Эта команда не перечисляет наследство, индексирует. Для того, чтобы работать с наследством индексирует,
пожалуйста, см. Раздел 28.6.12, “Индексация Наследства”.

Перечислите все индексирует и ограничения:

схема

Список индексирует или ограничения на:Person вершины для имени свойства:

схема-l:Person-p имя

Команда схемы поддерживает следующие параметры:

  *-l:Label только перечисляют, индексирует или ограничения для данной метки:Label
  *-p propertyKey только перечисляют, индексирует или ограничения для данного ключа свойства
    propertyKey
  *-v, если индексирование находится в ОТКАЗАВШЕМ состоянии, печатайте многословную причину погрешности если
    доступный

Индексирует и ограничения могут быть созданы или переместили Код использования или Ядро Java
API. Они обновлены автоматически всякий раз, когда график изменен. См.
Раздел 3.7, "Схема" для получения дополнительной информации.

28.6.12. Индексация наследства

Возможно запросить и манипулировать наследство, индексирует через индексировать команду.

Пример: индексируйте-i имя людей (индексирует имя для текущей вершины или
отношение в наследстве "людей" индексирует).

  *-g сделает, точный поиск в наследстве индексирует и выводит на экран хиты. Вы можете
    предоставьте-c команду, которая будет выполняться для каждого хита.
  *-q попросит, чтобы наследство индексировало запрос и вывело на экран хиты. Вы можете предоставить-c
    с командой, которая будет выполнена для каждого хита.
  * - cd изменит текущее расположение на хит от запроса. Это только a
    удобство для того, чтобы использовать-c опцию.
  * - ls сделает перечисление содержания для каждого хита. Это только a
    удобство для того, чтобы использовать-c опцию.
  *-i индексирует пару значения ключа в наследство, индексируют для текущей вершины /
    отношение. Если никакому значению не дают значения свойства для того ключа для
    текущая вершина используется в качестве значения.
  *-r переместит пару значения ключа (если он будет существовать) от наследства, индексируют для
    текущая вершина/отношение. Ключ и значение являются дополнительными.
  *-t установит наследство, индексируют тип, чтобы работать с, например индексировать-t
    Отношение - стирает друзей, сотрет друзей, которых индексирует отношение.

28.6.13. Транзакции

Полезно быть в состоянии протестировать изменения, и затем возможность фиксировать или
откатывайте сказали изменения.

Транзакции могут быть вложены. С вложенной транзакцией не пишет фиксация
любые изменения, чтобы обработать почву дисковым культиватором, за исключением высокоуровневой транзакции. Откат, однако
работы независимо от уровня транзакции. Это будет откатывать, все открываются
транзакции.

  * начинаются, транзакция Запускает транзакцию.
  * фиксируют Фиксации транзакция.
  * откатывают Откаты все открытые транзакции.

28.6.14. Дамп базы данных или кода следует к операторам Cypher

Как простой способ экспортировать базу данных или подмножество этого, команду дампа
преобразовывает график результата Кода или целой базы данных в единственное
Код создает оператор.

Замечание

Ограничительный экспорт еще не поддерживается.

Примеры:

  * дамп выводит целую базу данных, поскольку единственный код создает оператор
  * дамп ЗАПУСКАЕТСЯ, n=node ({сам}) СООТВЕТСТВУЮТ, p = (n) - [r:KNOWS *] → (m) ВОЗВРАЩАЮТ n, r, м.; дампы
    переходный график дружбы текущей вершины.
  * neo4j-оболочка - путь db1-c дамп ЗАПУСКАЕТСЯ, n=node:node_auto_index (назовите =' Маттиаса \'),
    СООТВЕТСТВУЙТЕ p = (n) - [r:KNOWS] → (m) ВОЗВРАЩАЮТ p; | neo4j-оболочка - путь db2 импортирует
    подграф первой базы данных (db1) во второе (db2)

28.6.14.1. Сценарии Дампа в качестве примера

 # создают новую вершину и идут в это
 $ neo4j-sh(?) mknode - cd - np" {'называют':'Neo'}"

 # создают отношение
 neo4j-sh (Нео, 0) $ mkrel-c-d i-t НРАВИТСЯ - np" {'приложение':'foobar'}"

 # Экспорт результаты оператора кода
 neo4j-sh (Нео, 0) дамп $ ЗАПУСКАЕТ n=node ({сам}), СООТВЕТСТВИЕ (n) - [r] - (m) возвращает n, r, м.;
 начать
 создайте (_0 {`имя`: "Нео"})
 создайте (_1 {`приложение`: "foobar"})
 создайте _1-[: `ЛЮБИТ`]-> _0
 ;
 фиксация

 # создают индексирование
 $ neo4j-sh(?) создают, индексируют на:Person (имя);
 +-------------------+
 | Никакие данные не возвратились. |
 +-------------------+
 Индексирует прибавленный: 1
 1120 мс


 # создают тот маркированная вершина и отношение
 $ neo4j-sh(?) создают (m:Person:Hacker {называют:' Маттиаса}), (m) - [:KNOWS]-> (m);
 +-------------------+
 | Никакие данные не возвратились. |
 +-------------------+
 Вершины создали: 1
 Отношения создали: 1
 Свойства устанавливают: 1
 Метки добавлялись: 2
 268 мс


 # Экспорт целая база данных включая индексирует
 дамп $ neo4j-sh(?)
 начать
 создайте индексируют на: `Человек` (`называют`);
 создайте (_0: `Человек`: `Хакер` {`называет`: "Маттиас"})
 создайте _0-[: `ЗНАЕТ`]-> _0
 ;
 фиксация

28.7. Сеанс оболочки в качестве примера

 # Создают вершину
 $ neo4j-sh(?) mknode - cd

 #, где мы?
 neo4j-sh (0) $ pwd
 Ток (0)
 (0)


 # На текущей вершине, определенной ключевое "имя", чтобы оценить "Джона"
 neo4j-sh (0) $ определяют имя "Джон"

 # отправляют запрос кода
 neo4j-sh (Джон, 0) $ запускают n=node (0) возврат n;
 +---------------------+
 | n |
 +---------------------+
 | Вершина [0] {имя: "Джон"} |
 +---------------------+
 1 строка
 377 мс


 # делают входящее отношение типа, ЛЮБИТ, создайте конечный узел с определенными свойствами вершины.
 neo4j-sh (Джон, 0) $ mkrel-c-d i-t НРАВИТСЯ - np" {'приложение':'foobar'}"

 #, где мы?
 neo4j-sh (Джон, 0) $ ls
 *name = [Джон]
 (я) <-[:LIKES] - (1)


 # изменяются на недавно создаваемую вершину
 neo4j-sh (Джон, 0) cd $1

 # перечисляют отношения, включая идентификатор отношения
 neo4j-sh (1) $ ls-avr
 (я) - [:LIKES, 0]-> (Джон, 0)


 # создают еще один, ЗНАЕТ отношение и конечный узел
 neo4j-sh (1) $ mkrel-c-d i-t ЗНАЕТ - np" {'называют':' Боба'}"

 # печатают текущий штабель истории
 neo4j-sh (1) $ pwd
 Ток (1)
 (Джон, 0)-> (1)


 # многословные отношения списка
 neo4j-sh (1) $ ls-avr
 (я) - [:LIKES, 0]-> (Джон, 0)
 (я) <-[:KNOWS, 1] - (Боб, 2)

28.8. Матричный пример

Этот пример создает график символов в Матрице через оболочку
и затем выполнение Кода запрашивает против этого:

Рисунок 28.1. Пример Матрицы Shell

Shell-Example-graph.svg


Neo4j сконфигурирован для того, чтобы автоиндексировать, в этом случае со следующим в
Конфигурационный файл Neo4j:

node_auto_indexing=true
node_keys_indexable=name, возраст

relationship_auto_indexing=true
relationship_keys_indexable=ROOT,KNOWS,CODED_BY

Следующее - демонстрационный сеанс оболочки, создающий Матричный график и запросы
это.

 # Создают ссылочную вершину
 $ neo4j-sh(?) mknode - cd

 # создают вершину Томаса Андерсона
 neo4j-sh (0) $ mkrel-t БАЗИРУЮТСЯ-c-v
 Вершина (1) создаваемый
 Отношение [:ROOT, 0] создаваемый


 # идут в новую вершину
 neo4j-sh (0) cd $1

 # устанавливает свойство имени
 neo4j-sh (1) $ определяют имя "Томас Андерсон"

 # создают Томаса прямые друзья
 neo4j-sh (Томас Андерсон, 1) $ mkrel-t ЗНАЕТ - условная цена
 Вершина (2) создаваемый
 Отношение [:KNOWS, 1] создаваемый


 # идут в новую вершину
 neo4j-sh (Томас Андерсон, 1) cd $2

 # устанавливает свойство имени
 neo4j-sh (2) имя набора $ "Троица"

 # возвращаются в штабеле истории
 neo4j-sh (Троица, 2) cd $..

 # создают Томаса прямые друзья
 neo4j-sh (Томас Андерсон, 1) $ mkrel-t ЗНАЕТ - условная цена
 Вершина (3) создаваемый
 Отношение [:KNOWS, 2] создаваемый


 # идут в новую вершину
 neo4j-sh (Томас Андерсон, 1) cd $3

 # устанавливает свойство имени
 neo4j-sh (3) $ определяют имя "Морфей"

 # создают отношение к Троице
 neo4j-sh (Морфей, 3) $ mkrel-t ЗНАЕТ 2

 # перечисляют отношения вершины 3
 neo4j-sh (Морфей, 3) $ ls-rv
 (я) - [:KNOWS, 3]-> (Троица, 2)
 (я) <-[:KNOWS, 2] - (Томас Андерсон, 1)


 # изменяют текущую позицию на отношение #2
 neo4j-sh (Морфей, 3) cd $-r 2

 # устанавливает свойство возраста на отношении
 neo4j-sh [:KNOWS, 2] $ устанавливают-t международный возраст 3

 # назад Морфею
 neo4j-sh [:KNOWS, 2] cd $..

 # следующее отношение
 neo4j-sh (Морфей, 3) cd $-r 3

 # устанавливает свойство возраста на отношении
 neo4j-sh [:KNOWS, 3] $ устанавливают-t международный возраст 90

 # позиция к вершине запуска текущего отношения
 neo4j-sh [:KNOWS, 3] cd $ запускаются

 # новая вершина
 neo4j-sh (Морфей, 3) $ mkrel-t ЗНАЕТ-c

 # перечисляют отношения на текущей вершине
 neo4j-sh (Морфей, 3) $ ls-r
 (я) - [:KNOWS]-> (Троица, 2)
 (я) - [:KNOWS]-> (4)
 (я) <-[:KNOWS] - (Томас Андерсон, 1)


 # идут в Код
 neo4j-sh (Морфей, 3) cd $4

 # определяет имя
 neo4j-sh (4) Код имени набора $

 # создают новую вершину из Кода
 neo4j-sh (Код, 4) $ mkrel-ct ЗНАЕТ

 # перечисляют отношения
 neo4j-sh (Код, 4) $ ls-r
 (я) - [:KNOWS]-> (5)
 (я) <-[:KNOWS] - (Морфей, 3)


 # идут в Агент вершина Смита
 neo4j-sh (Код, 4) cd $5

 # определяет имя
 neo4j-sh (5) Агент "имени набора $ Смит"

 # исходящее отношение и новая вершина
 neo4j-sh (Агент Смит, 5) $ mkrel-cvt CODED_BY
 Вершина (6) создаваемый
 Отношение [:CODED_BY, 6] создаваемый


 # идут туда
 neo4j-sh (Агент Смит, 5) cd $6

 # определяет имя
 neo4j-sh (6) $ определяют имя "Архитектор"

 # идут в первую вершину в штабеле истории
 neo4j-sh (Архитектор, 6) cd $

 # друзья Морфея, ища Морфея по имени в Neo4j автоиндексируют
 $ neo4j-sh(?) запускаются, morpheus = node:node_auto_index (назовите =' Морфея), соответствуют morpheus - [:KNOWS] - сионист возвращает zionist.name;
 +--------------------+
 | zionist.name |
 +--------------------+
 | "Троица" |
 | "Код" |
 | "Томас Андерсон" |
 +--------------------+
 3 строки
 322 мс


 # друзья Морфея, ища Морфея по имени в Neo4j автоиндексируют
 $ neo4j-sh(?) кодируют 2.0, запускаются, morpheus = node:node_auto_index (назовите =' Морфея), соответствуют morpheus - [:KNOWS] - сионист возвращает zionist.name;
 +--------------------+
 | zionist.name |
 +--------------------+
 | "Троица" |
 | "Код" |
 | "Томас Андерсон" |
 +--------------------+
 3 строки
 289 мс

Часть VII. Сообщество

У проекта Neo4j есть сильное сообщество вокруг этого. Читайте о том, как получить справку
от сообщества и как способствовать этому.

Оглавление

29. Общественная поддержка
30. Содействие Neo4j

    30.1. Лицензионное соглашение спонсора
    30.2. Области для содействия
    30.3. Запись Документация Neo4j
    30.4. Преобразование Справочника Neo4j
    30.5. Содействие Кода к Neo4j
    30.6. Спонсоры

Глава 29. Общественная поддержка

Вы можете учиться много о Neo4j на различных событиях. Получить информацию о
предстоящие события Neo4j, взгляните здесь:

  * http://www.neo4j.org/ <http://www.neo4j.org/>
  * http://neo4j.meetup.com/ <http://neo4j.meetup.com/>

Получите справку от сообщества разработчиков ПО с открытым исходным кодом Neo4j; вот некоторые начальные точки.

  * neo4j тегируют в stackoverflow: http://stackoverflow.com/questions/tagged/
    neo4j <http://stackoverflow.com/questions/tagged/neo4j>
  * Обсуждения Сообщества Neo4j: https://groups.google.com/forum/#!forum/neo4j
    <https://groups.google.com/forum/#!forum/neo4j>
  * Twitter: https://twitter.com/neo4j <https://twitter.com/neo4j>
  * канал IRC: irc://irc.freenode.net/neo4j <irc://irc.freenode.net/neo4j>
    веб-чат <http://webchat.freenode.net/?randomnick=1&channels=neo4j>.

Сообщите об ошибке или прибавьте запрос новых функций:

  * https://github.com/neo4j/neo4j/issues <https://github.com/neo4j/neo4j/
    проблемы>

Вопросы относительно документации: Справочник Neo4j опубликован онлайн
с функцией комментария, пожалуйста, используйте это, чтобы отправить любые вопросы или комментарии
относительно документации. См. http://docs.neo4j.org/2.0.0 <http://
docs.neo4j.org/2.0.0>.

Глава 30. Содействие Neo4j

Проект Neo4j - усилие С открытым исходным кодом принести быстрое комплексное хранение данных
и обработка к сроку службы. Каждая форма справки чрезвычайно ценится
сообщество - и Вы не являетесь одними, видите Раздел 30.6, "Спонсоров"!

Один решающий аспект содействия проекту Neo4j - Раздел 30.1,
“Лицензионное соглашение спонсора”.

Вкратце: удостоверьтесь, что подписали CLA и передались в электронной почте, или проекте Neo4j
не будет в состоянии принять Ваше содействие.

Заметьте, что Вы можете способствовать Neo4j также, внося документацию или
предоставление обратной связи на текущей документации. В основном, во всех местах
где Вы можете получить справку, есть также комната для вкладов.

Если Вы хотите способствовать, есть некоторые хорошие области, чтобы запуститься с, особенно
для того, чтобы войти в контакт с сообществом, Главой 29, общественной поддержкой.

Чтобы задокументировать Ваши усилия, мы настоятельно рекомендуем считать Раздел 30.3, “Пишущий
Документация Neo4j”.

30.1. Лицензионное соглашение спонсора

30.1.1. Сводка
30.1.2. Общие вопросы
30.1.3. Как подписаться

30.1.1. Сводка

Мы требуем всего исходного кода, который размещен на инфраструктуре Neo4j, чтобы быть
внесенный через Лицензионное соглашение Спонсора Neo4j <http://
dist.neo4j.org/neo4j-cla.pdf> (CLA). Цель Спонсора Neo4j
Лицензионное соглашение должно предохранить целостность кодовой базы, который поочередно
предохраняет сообщество вокруг той кодовой базы: объект основания Нео
Технология, сообщество разработчиков Neo4j и пользователи Neo4j. Это отчасти
соглашение спонсора распространено среди бесплатного программного обеспечения и проектов с открытым исходным кодом
(это фактически очень подобно широко подписанному соглашению Спонсора Oracle
<http://www.oracle.com/technetwork/community/oca-486395.html>).

Пожалуйста, см. ниже или отправьте почту администраторам [в] neofourjay.org, если Вы имеете
любые другие вопросы о намерении CLA. Если у Вас есть юридический вопрос,
пожалуйста, спросите адвоката.

30.1.2. Общие вопросы

30.1.2.1. Я теряю права на свой собственный код?

Нет, CLA Neo4j <http://dist.neo4j.org/neo4j-cla.pdf> только просит, чтобы Вы совместно использовали
Ваши права, не оставляют их. В отличие от некоторых соглашений о содействии это
требуйте, чтобы Вы передали авторские права другому устройству, CLA не делает
уберите свои права на Вашу внесенную интеллектуальную собственность. Когда Вы соглашаетесь
к CLA Вы предоставляете нам совладение в авторском праве, и патентную лицензию для
Ваши вклады. Вы сохраняете все права, заголовок, и проценты в Вашем
вклады и могут использовать их для любой цели, которую Вы желаете. Кроме отмены
наши права, Вы можете все еще сделать то, что Вы хотите со своим кодом.

30.1.2.2. Что Вы можете сделать с моим содействием?

Мы можем осуществить все права, которые правообладатель имеет, так же как права
Вы предоставляете в CLA Neo4j <http://dist.neo4j.org/neo4j-cla.pdf> использовать любого
патенты Вы имеете в своих вкладах. Поскольку CLA предусматривает объединенное авторское право
владение, Вы можете осуществить те же самые права как мы в Ваших вкладах.

30.1.2.3. Каковы преимущества сообщества этого?

Ну, это позволяет нам спонсировать проекты Neo4j и обеспечивать инфраструктуру
для сообщества, удостоверяясь, что мы можем включать это в программное обеспечение это
мы поставляем нашим клиентам без любых противных неожиданностей. Без этой возможности, нас
поскольку небольшая компания была бы в затруднении, чтобы выпустить весь наш код как свободный
программное обеспечение.

Кроме того, CLA пускает нам предохранять члены сообщества (и разработчики и пользователи)
от враждебной интеллектуальной собственности тяжба должен потребность возникать. Это находится в
строка, с как другие стюарды бесплатного программного обеспечения как Фонд свободного программного обеспечения -
FSF <http://www.fsf.org> защищают проекты (кроме с FSF, есть нет
совместно используемое авторское право, но вместо этого Вы полностью подписываете это к FSF).
соглашение спонсора также включает “соглашение бесплатного программного обеспечения,” или обещание
то, что содействие останется доступным как бесплатное программное обеспечение.

В конце дня Вы все еще сохраняете все права к своему содействию и нам
может стоять уверенный, что мы можем предохранить сообщество Neo4j и Нео
Технологические клиенты.

30.1.2.4. Мы можем обсудить некоторые элементы в CLA?

Абсолютно! Пожалуйста, дайте нам обратную связь! Но пустите нам избегать юридический жаргон
списки рассылки. Пожалуйста, отправьте свою обратную связь по почте прямо к cla (@t) neotechnology точка
cöm и мы возвратимся к Вам.

30.1.2.5. Мне все еще не нравится этот CLA.

Это - мелкие частицы. Вы можете все еще разместить это где-либо еще, конечно. Пожалуйста, сделайте! Мы
только говоря здесь о правилах для инфраструктуры, что мы обеспечиваем.

30.1.3. Как подписаться

Когда Вы прочитали CLA, пожалуйста, отправьте почту cla (@t) neotechnology
точка cöm. Включайте следующую информацию:

  * Ваше полное имя.
  * Ваш адрес электронной почты.
  * присоединенная копия CLA Neo4j <http://dist.neo4j.org/neo4j-cla.pdf>.
  *, Что Вы соглашаетесь на его сроки.

Например:

Привет. Меня зовут Джон Доу (john@doe.com).
Я соглашаюсь на сроки в присоединенном Лицензионном соглашении Спонсора Neo4j.

30.2. Области для содействия

30.2.1. Проекты Ядра Neo4j
30.2.2. Поддержание Документация Neo4j
30.2.3. Драйверы и привязка к Neo4j

Neo4j - проект с обширной экосистемой и большим количеством пространства для вкладов.
То, где Вы можете и хотеть браться за дело, зависит, конечно, от Вашего времени, набора навыков
и проценты. Ниже некоторые из областей, которые могли бы интересовать Вас:

30.2.1. Проекты Ядра Neo4j

  * нерешенные вопросы Neo4j <https://github.com/neo4j/neo4j/issues> для некоторых
    начальные точки для содействия
  * См. GitHub область Neo4j <https://github.com/neo4j/> для списка
    проекты

30.2.2. Поддержание Документация Neo4j

Некоторые части документации нуждаются в дополнительной заботе от сообщества, чтобы не лечь спать
до настоящего времени. Они обычно обращаются к различным видам вкладов сообщества.
Самый легкий способ внести исправления состоит в том, чтобы прокомментировать в онлайновой версии HTML
<http://docs.neo4j.org/chunked/snapshot/>.

30.2.3. Драйверы и привязка к Neo4j

  * REST: см. Главу 6, Языки для списка активных проектов

30.3. Запись Документация Neo4j

30.3.1. Полный Поток
30.3.2. Структура файла в docs.jar
30.3.3. Направления движения и строение документа
30.3.4. Запись
30.3.5. Глюки
30.3.6. Ссылки
30.3.7. Текстовое Форматирование
30.3.8. Замечания
30.3.9. Изображения
30.3.10. Атрибуты
30.3.11. Комментарии
30.3.12. Фрагменты кода
30.3.13. Демонстрационный Java базировал тест документации
30.3.14. Привет мировая Демонстрационная Глава
30.3.15. Интегрированная Переменная Консоль
30.3.16. Toolchain

Замечание

Кроме записи документации, Вы можете выручить, обеспечивая комментарии - голова
к онлайновой версии HTML <http://docs.neo4j.org/chunked/snapshot/>, чтобы сделать
это!

Для того, как создать справочник, см.: readme <https://github.com/neo4j/neo4j/blob/
master/manual/README.asciidoc>

Документы используют формат asciidoc, видят:

  * Ссылка Aciidoc <http://www.methods.co.nz/asciidoc/>
  * AsciiDoc cheatsheet <http://powerman.name/doc/asciidoc>

cheatsheet действительно полезен!

30.3.1. Полный Поток

У каждого (sub) проекта есть своя собственная документация, которая произведет docs.jar
файл. По умолчанию этот файл собран от содержания в src/docs/.
У документов Asciidoc есть.asciidoc расширение файла.

Документы могут использовать фрагменты кода, которые извлекут код из проекта.
Соответствующий код должен быть развернут к sources.jar или тесту-sources.jar
файл.

Устанавливая тест модуля соответственно, документация может быть записана прямо в
комментарий JavaDoc.

Вышеупомянутые файлы все использованы создаванием из справочника (прибавляя их как
зависимости). Получить контент включало в справочник, это должно быть явно
включенный документом в справочник также.

Заметьте, что различные способы прибавить документацию работают лучше всего на различные случаи:

  * Для документации уровня детализации, это работает хорошо, чтобы записать документацию как
    часть тестов модуля (в комментарии JavaDoc). В этом случае, Вы обычно делаете
    не хочу соединиться с исходным кодом в документации.
  * Для учебной документации уровня, результат будет лучшим при записи a
    Файл.asciidoc, содержащий текст. Исходные отрывки и выходные примеры могут
    тогда будьте включены оттуда. В этом случае Вы обычно хотите соединиться с
    исходный код, и пользователи должны быть в состоянии выполнить это без любой специальной установки.

30.3.2. Структура файла в docs.jar

Содержание каталога
контент dev/нацеливался на разработчиков

изображения dev/images/используются dev документами

операция в секунду / контент нацеливалась на операции

изображения ops/images/используются документами операции в секунду

человек / страницы справочника

Дополнительные подкаталоги привыкли как необходимый к строению документы, как
dev/tutorial/, ops/tutorial/и т.д.

30.3.3. Направления движения и строение документа

Каждый документ запускается с направлений движения от нуля уровня (заголовок документа).
У каждого документа должен быть идентификатор. В некоторых случаях разделы в документе нуждаются к
имейте идентификатор также, это зависит от того, где они помещаются в полное строение. К
будьте в состоянии соединиться с контентом, у этого должен быть идентификатор. Отсутствие идентификатора в обязательном
места приведут создавание к сбою.

Это - то, как документ должен запуститься:

[[unique-id-verbose-is-ok]]
= Заголовок Документа =

Продвигать направления движения до правильного уровня в выводе, leveloffset
атрибут используется когда включая документ в другом документе.

Последовательные направления движения в документе должны использовать следующий синтаксис:

== Подзаголовок ==

... контент здесь...

=== Подподзаголовок ===

контент здесь...

Asciidoc идет с еще одним синтаксисом для направлений движения, но в этом проекте это не
используемый.

30.3.4. Запись

Поместите одно предложение в каждую строку. Это облегчает перемещать контент, и
также легкий установить (слишком) длинные предложения.

30.3.5. Глюки

  * глава не может быть пустой. (создавание приведет к сбою на docbook xml обоснованность
    проверьте),
  * Всегда оставляют пустую строку в конце документов (или заголовок следующего
    документ мог бы закончиться последнем абзаце документа),
  * Как {} используются для атрибутов Asciidoc, все внутри будет обработано
    как атрибут. То, что Вы должны сделать, должно выйти из вводной фигурной скобки: \{. Если
    Вы не делаете, фигурные скобки и текст в них будут удалены ни с кем
    предупреждение быть выпущенным!

30.3.6. Ссылки

Чтобы соединиться с другими частями справочника, идентификатор цели используется. Это то, как
такие ссылочные взгляды:

<<community-docs-overall-flow>>

Который представит как: Раздел 30.3.1, “Полный Поток”

Замечание

Только запишите, "видят <<целевой идентификатор>>" и подобный, который должен быть достаточным в большинстве случаев.

Если Вы должны соединиться с другим документом с Вашим собственным текстом ссылки, это что
сделать:

<<целевой идентификатор, соедините текст, который помещается в контекст>>

Замечание

Наличие большого количества соединенного текста может работать хорошо в веб-контексте, но является болью в
оттиск, и мы стремимся к обоим!

Внешние ссылки прибавлены как это:

http://neo4j.org/ [Текст ссылки здесь]

Который представляет как: текст Ссылки здесь <http://neo4j.org/>

Для коротких ссылок может быть лучше не прибавить текст ссылки, только сделать:

http://neo4j.org/

Который представляет как: http://neo4j.org/ <http://neo4j.org/>

Замечание

Нормально иметь точечное право после URL, это не будет часть ссылки.

30.3.7. Текстовое Форматирование

  * _Italics_ представлен как Курсив и используется для акцента.
  * *Bold* представлен как Полужирный и используемый экономно, для сильного акцента только.
  * +methodName () + представлен как methodName () и используется для литералов также
    (замечание: контент между + знаки будет проанализирован).
  * `команда` представлена как команда (обычно используемая для командной строки) (замечание:
    контент между `знаками не будет проанализирован).
  * Моно ++ пространство ++ d представлено как Моноширинное и использовано для моноширинного
    буквы.
  * 'мой/путь /' представлен как my/path/(используемый для имен файла и путей).
  * ``Двойное количество, заключенное в кавычки'' (который является двумя серьезными диакритическими знаками налево и два острый
    диакритические знаки направо), представляет как “Двойное количество, заключенное в кавычки”.
  * `Единственный заключенный в кавычки' (который является единственным серьезным диакритическим знаком налево и единственным
    акут направо), представляет как ‘Единственный заключенный в кавычки’.

30.3.8. Замечания

Они очень полезны и должны использоваться где необходимо. Выберите из
следующий (пишут все заглавные буквы и не, мы не можем легко прибавить новые):

Замечание

Замечание.

Подсказка

Подсказка.

Важный

Важный

Предостережение

Предостережение

Предупреждение

Предупреждение

Вот то, как это сделано:

ЗАМЕЧАНИЕ: Замечание.

Многострочная вариация:

[ПОДСКАЗКА]
Tiptext.
Строка 2.

Который представлен как:

Подсказка

Tiptext. Строка 2.

30.3.9. Изображения

Важный

Все изображения во всем справочнике совместно используют то же самое пространство имен. Вы знаете как к
обработайте это.

30.3.9.1. Файлы изображений

Чтобы включать файл изображения, удостоверьтесь, что это находится в изображениях / каталог
относительно документа Вы включаете это от. Затем пойдите:

изображение:: neo4j-logo.png []

Который представлен как:

neo4j-logo.png

30.3.9.2. Статический Graphviz/DOT

Мы используем язык Graphviz/DOT, чтобы описать графики. Поскольку документация видит
http://graphviz.org/ <http://graphviz.org/>.

Это - то, как включать простой график в качестве примера:

 ["точка", "community-docs-graphdb-rels.svg"]
 ----
 "Запустите вершину"-> "Конечный узел" [метка = "отношение"]
 ----

Который представлен как:

community-docs-graphdb-rels.svg

Вот пример, используя некоторые предопределенные переменные, доступные в создавании:

 ["точка", "community-docs-graphdb-rels-overview.svg", "meta"]
 ----
 "Отношение" [цвет заливки = "NODEHIGHLIGHT"]
 "Запустите вершину" [цвет заливки = "NODE2HIGHLIGHT"]
 "Отношение"-> "Запускает вершину" [метка = "имеет"]
 "Отношение"-> "Конечный узел" [метка = "имеет"]
 "Отношение"-> "Тип отношения" [метка = "имеет"]
 "Имя" [TEXTNODE]
 "Отношение вводит"-> "Имя" [метка = "однозначно определенный" цветом = "EDGEHIGHLIGHT" fontcolor = "EDGEHIGHLIGHT"]
 ----

Который представлен как:

community-docs-graphdb-rels-overview.svg

Дополнительный второй параметр, данный точечному фильтру, определяет стиль, чтобы использовать:

  * если не определенный: моделирование Значения по умолчанию для nodespace примеров.
  * neoviz: представление Nodespace сгенерировано Neoviz.
  * meta: Графики, которые не напоминают содержание дб, а скорее понятия.

Предостережение

Ключевые слова ТОЧЕЧНОГО языка должны быть окружены двойными кавычками когда использующийся
для других целей. Ключевые слова включают вершину, край, график, диграф, подграф,
и строгий.

30.3.10. Атрибуты

Общие атрибуты Вы можете использовать в документах:

  * {neo4j-версия} - представленный как "2.0.0"
  * {neo4j-git-tag} - представленный как "2.0.0"
  * {lucene-версия} - представленный как "3_6_2"

Они могут подставить часть URL, которые указывают на например APIdocs или источник
код. Заметьте, что neo4j-git-tag также обрабатывает случай снимка/ведущего устройства.

Демонстрационные атрибуты Asciidoc, которые могут использоваться:

  * {docdir} - корневой каталог документов
  * {nbsp} - неразрывный пробел

30.3.11. Комментарии

Есть отдельное, создают включая комментарии. Комментарии обнаруживаются с желтым
фон. Это создает, не работает по умолчанию, но после того, как нормаль создает, Вы
может использовать делают аннотируемым, чтобы создать это. Вы можете также использовать следующую страницу для
поиск контента, как полный справочник находится на единственной странице.

Вот то, как записать комментарий:

//это - комментарий

Комментарии не видимы в нормали, создают. Блоки комментария не будут
включенный в вывод любого создают вообще. Вот блок комментария:

////
Замечание, которое включает в здесь, будет все еще обработано, но не превратит это в вывод.
Таким образом, отсутствие включает, здесь все еще нарушит создавание!
////

30.3.12. Фрагменты кода

30.3.12.1. Явно определенный в документе

Предупреждение

Используйте этот вид фрагментов кода как можно меньше. Они известны
выйдите из синхронизации с действительностью через некоторое время.

Это - то, как сделать это:

 [источник, код]
 ----
 запустите n = (2, 1), куда (n.age <30 и n.name = "Тобиас") или не (n.name = "Тобиас") возвращают n
 ----

Который представлен как:

запустите n = (2, 1), куда (n.age <30 и n.name = "Тобиас") или не (n.name = "Тобиас") возвращают n

Если нет никакого соответствующего маркера синтаксиса, только опустите язык: [источник].

В настоящий момент следующие маркеры синтаксиса включены:

  * Bash
  * Код
  * Groovy
  * Java
  * JavaScript
  * Python
  * XML

Для других маркеров мы могли добавиться, см. http://alexgorbatchev.com/
SyntaxHighlighter/manual/brushes/<http://alexgorbatchev.com/SyntaxHighlighter/
справочник/кисти/>.

30.3.12.2. Выбранный от исходного кода

Код может быть автоматически выбран от исходных файлов. Вы должны определить:

  * компонент: artifactId координат Знатока,
  * источник: путь к файлу в толчке это развернуто к,
  * классификатор: источники или тестовые источники или любой другой классификатор, указывающий
    артефакт,
  * тег: имя тега, чтобы искать файл,
  * язык кода, если соответствующий маркер синтаксиса
    доступный.

Заметьте, что артефакт должен быть включен как зависимость Знатока Справочника
проект так, чтобы файлы могли быть найдены.

Знайте об этом, тег "abc" будет соответствовать "abcd" также. Это - простое вкл\выкл
переключатель, означая, что разнообразные возникновения будут собраны в единственный код
отрывок в выводе. Это поведение может быть пользователем, чтобы скрыть утверждения от
примеры кода получены от источника от тестов.

Это - то, как определить вложение фрагмента кода:

 [отрывок, java]
 ----
 component=neo4j-examples
 source=org/neo4j/examples/JmxDocTest.java
 classifier=test-sources
 tag=getStartTime
 ----

Это - то, как это представляет:

частная статическая Дата getStartTimeFromManagementBean (
        GraphDatabaseService graphDbService)
{
    GraphDatabaseAPI graphDb = (GraphDatabaseAPI) graphDbService;
    Имя объекта ObjectName = JmxUtils.getObjectName (graphDb, "Ядро");
    Дата даты = JmxUtils.getAttribute (имя объекта, "KernelStartTime");
    возвратите дату;
}

30.3.12.3. Результаты запроса

Есть специальный фильтр для результатов запроса Кода. Это - то, как тегировать запрос
результат:

 .Result
 [queryresult]
 ----
 +----------------------------------+
 | friend_of_friend.name | количество (*) |
 +----------------------------------+
 | Иэн | 2 |
 | Деррик | 1 |
 | Джилл | 1 |
 +----------------------------------+
 3 строки, 12 мс
 ----

Это - то, как это представляет:

Таблица 30.1. Результат

+-------------------------------+
|friend_of_friend.name |count (*) |
|-------------------------------|
|3 строки, 12 мс |
|-------------------------------|
|Ian |2 |
|----------------------+--------|
|Derrick |1 |
|----------------------+--------|
|Jill |1 |
+-------------------------------+


30.3.13. Демонстрационный Java базировал тест документации

Для Java есть несколько предварительно сделанных утилит, которые сохраняют код и
документация вместе в Javadocs и фрагментах кода, которые генерируют Asciidoc для
остальная часть toolchain.

Чтобы пояснять это, смотрите на следующую документацию, которая генерирует
Файл Asciidoc hello-world-title.asciidoc с контентом:

[[examples-hello-world-sample-chapter]]
Привет мировая Демонстрационная Глава
==========================

Это - демонстрационный тест документации, демонстрируя различные способы
обеспечение кода и других артефактов в форму Asciidoc. Заголовок
сгенерированный документ определен от имени метода, заменяя "+ _ +" с
" ".

Ниже Вас см. много различных способов генерировать текст из источника,
вставка этого в документацию JavaDoc (действительно являющийся разметкой Asciidoc)
через + @@ + маркеры отрывка и программируемое добавление с данными времени выполнения
в коде Java.

- Аннотируемый график как http://www.graphviz.org/ [GraphViz] - генерировал визуализацию:

График Мира.Hello
["точка", "Hello-World-Graph-hello-world-Sample-Chapter.svg", "neoviz", ""]
----
  N0 [
    маркируйте =" {Вершина \[0 \] имя = \'you \'\l}"
  ]
  N1 [
    маркируйте =" {Вершина \[1 \] имя = \'I \'\l}"
  ]
  N1-> N0 [
    покрасьте = "#2e3436"
    fontcolor = "#2e3436"
    маркируйте = "know\n"
  ]
----

- Демонстрационный запрос Кода:

[источник, код]
----
ЗАПУСТИТЕ n = вершина (1)
ВОЗВРАТИТЕ n
----

- Демонстрационный текст выводил отрывок:

[источник]
----
Привет мир graphy!
----

- сгенерированный источник соединяется с исходным источником GIThub для этого теста:

https://github.com/neo4j/neo4j/blob / {neo4j-git-tag} /community/embedded-examples/src/test/java/org/neo4j/examples/DocumentationDocTest.java [DocumentationDocTest.java]

- Полный источник для этого примера как исходный отрывок, выделенный как код Java:

[отрывок, java]
----
component=neo4j-examples
source=org/neo4j/examples/DocumentationDocTest.java
classifier=test-sources
tag=sampleDocumentation
----

Это - конец этой главы.

этот файл включен в эту документацию через

  :leveloffset: 3
  включайте:: {importdir} /neo4j-examples-docs-jar/dev/examples/hello-world-sample-chapter.asciidoc []

который представляет следующую главу:

30.3.14. Привет мировая Демонстрационная Глава

Это - демонстрационный тест документации, демонстрируя различные способы принести
код и другие артефакты в форму Asciidoc. Заголовок сгенерированного
документ определен от имени метода, заменяя "_" с "".

Ниже Вас см. много различных способов генерировать текст из источника,
вставка этого в документацию JavaDoc (действительно являющийся разметкой Asciidoc) через
@@ маркеры отрывка и программируемое добавление с данными времени выполнения в Java
код.

  * аннотируемый график как GraphViz <http://www.graphviz.org/>-generated
    визуализация:

Рисунок 30.1. Привет Мировой График

Hello-World-Graph-hello-world-Sample-Chapter.svg


  * демонстрационный запрос Кода:

ЗАПУСТИТЕ n = вершина (1)
ВОЗВРАТИТЕ n

  * демонстрационный текст выводил отрывок:

Привет мир graphy!

  * сгенерированная исходная ссылка к исходному источнику GIThub для этого теста:

DocumentationDocTest.java <https://github.com/neo4j/neo4j/blob/2.0.0/community/
embedded-examples/src/test/java/org/neo4j/examples/DocumentationDocTest.java>

  * полный источник для этого примера как исходный отрывок, выделенный как Java
    код:

//ЗАПУСТИТЕ ОТРЫВОК: _sampleDocumentation
пакет org.neo4j.examples;

импорт org.junit. Тест;

импорт org.neo4j.kernel.impl.annotations.Documented;
импорт org.neo4j.test. GraphDescription. График;

импортируйте статичный org.neo4j.visualization.asciidoc.AsciidocHelper.createGraphVizWithNodeId;
импортируйте статичный org.neo4j.visualization.asciidoc.AsciidocHelper.createOutputSnippet;

общедоступный класс DocumentationDocTest расширяет ImpermanentGraphJavaDocTestBase
{
    / **
     * Это - демонстрационный тест документации, демонстрируя различные способы
     * приносящий код и другие артефакты в форму Asciidoc. Заголовок
     * сгенерированный документ определен от имени метода, заменяя "+ _ +" с
     * " ".
     *
     * Ниже Вас см. много различных способов генерировать текст из источника,
     * вставка этого в документацию JavaDoc (действительно являющийся разметкой Asciidoc)
     * через + @@ + маркеры отрывка и программируемое добавление с данными времени выполнения
     * в коде Java.
     *
     * - аннотируемый график как http://www.graphviz.org/ [GraphViz] - генерировал визуализацию:
     *
     * @@ график
     *
     * - демонстрационный запрос Кода:
     *
     * @@ код
     *
     * - демонстрационный текст выводил отрывок:
     *
     * @@ вывод
     *
     * - сгенерированная исходная ссылка к исходному источнику GIThub для этого теста:
     *
     * @@ github
     *
     * - полный источник для этого примера как исходный отрывок, выделенный как код Java:
     *
     * @@ sampleDocumentation
     *
     * Это - конец этой главы.
     */
    @Test
    //сигнализация этого, чтобы быть тестом документации
    @Documented
    //данные графика устанавливают как простые операторы
    @Graph ("Я знаю Вас"),
    //заголовок определен от имени метода
    общественность освобождает hello_world_Sample_Chapter ()
    {
        //инициализируйте график с данными аннотации
        data.get ();
        gen.get ().addTestSourceSnippets (this.getClass (), "sampleDocumentation");
        gen.get ()
                .addGithubTestSourceLink ("github", this.getClass (),
                        "community/embedded-examples");

        gen.get ().addSnippet ("вывод",
                createOutputSnippet ("Привет graphy мир!"));

        gen.get ().addSnippet (
                "график",
                createGraphVizWithNodeId ("Привет Мировой График", graphdb (),
                        gen.get ().getTitle ()));
        //Отрывок кода, обращающийся к сгенерированному графику в пункте запуска
        gen.get ().addSnippet (
                "код",
                createCypherSnippet ("запускают n = вершина (" + data.get ().get ("I").getId ()
                                     +"), возвращают n"));
    }
}
//ОТРЫВОК КОНЦА: _sampleDocumentation

Это - конец этой главы.

30.3.15. Интегрированная Переменная Консоль

Интерактивная консоль может быть прибавлена и обнаружится в онлайновом HTML
версия. Дополнительный заголовок может быть прибавлен, который будет использоваться для текста
кнопка.

Это - то, как сделать это, используя Код, чтобы определить данные, с пустой строкой к
разделите это от запроса:

 Пример.Interactive
 [консоль]
 ----
 СОЗДАЙТЕ (n {имя: 'Neo4j'})

 СООТВЕТСТВИЕ (n)
 возвратите n
 ----

И это - результат:

30.3.16. Toolchain

Полезные ссылки, конфигурируя docbook toolchain:

  * http://www.docbook.org/tdg/en/html/docbook.html <http://www.docbook.org/tdg
    /en/html/docbook.html>
  * http://www.sagehill.net/docbookxsl/index.html <http://www.sagehill.net/
    docbookxsl/index.html>
  * http://docbook.sourceforge.net/release/xsl/1.76.1/doc/html/index.html
    <http://docbook.sourceforge.net/release/xsl/1.76.1/doc/html/index.html>
  * http://docbook.sourceforge.net/release/xsl/1.76.1/doc/fo/index.html <http:/
    /docbook.sourceforge.net/release/xsl/1.76.1/doc/fo/index.html>

30.4. Преобразование Справочника Neo4j

30.4.1. Предпосылки
30.4.2. Создайте расположение файла и поток
30.4.3. Добавление главы к файлу преобразования
30.4.4. Поток операций
30.4.5. Инструменты преобразования

Чтобы преобразовать Справочник Neo4j, есть специальная установка проекта, чтобы использовать. См.
Французский проект преобразования для примера: https://github.com/neo4j/
физический французский язык <https://github.com/neo4j/manual-french>

Проект делится без остатка:

  * conf /  -  конфигурация для проекта.
  * документы /  -  преобразованные файлы для контента обеспечили модулями Neo4j.
  * почтовый /  -  файлы преобразования и po4a конфигурационные файлы.
  * src /  -  преобразованные файлы для контента обеспечил исходным справочником.
  * Make-файл  -  make-файл со специфичной для проекта конфигурацией.
  * pom.xml  -  конфигурация сборки Знатока.

30.4.1. Предпосылки

  * Знаток Apache
  * GNU Делают
  * Python
  * Perl
  * модуль Perl: Unicode:: GCString

Проверять, есть ли у Вас Unicode:: модуль GCString устанавливал, Вы можете выйти
следующая команда:

perl-MUnicode:: GCString-e''

Если нет никакой погрешности, модуль был успешно установлен на Вашей системе.

Чтобы установить модуль, Вы можете использовать cpanminus <http://search.cpan.org/dist/
App-cpanminus/lib/App/cpanminus.pm>. Для удобного способа установить это, см.
http://cpanmin.us <http://cpanmin.us>. С установленным cpanminus, выполните это
команда:

Unicode cpanm:: GCString

Вы будете, вероятно, хотеть использовать.po редактор файлов также, видеть Раздел 30.4.5,
“Преобразование обрабатывает инструментом”.

30.4.2. Создайте расположение файла и поток

Создавание - по существу двухстворчатый процесс. Первый шаг генерирует или копирует
преобразованные документы, в то время как второй шаг - обыкновенный AsciiDoc, создают использование
вывод от первого шага как источники.

Кроме src/и документов / diirectories проекта, создавание генерирует
файлы с тем же самым расположением в еще двух местах:

 1. целевой/исходный / (src|docs) /   -  the содержание исходного справочника. Замечание
    вот именно легче искать контент здесь чем заесть в оригинал
    справочник непосредственно.
 2. предназначайтесь / (src|docs) /   -  the, преобразованный источник, чтобы использовать для AsciiDoc создают.

Преобразованные документы в цели / (src|docs) / сгенерированы в трех шагах:

 1. Это начинается как копия исходного справочника.
 2. Затем, любые статические преобразованные файлы fromt src/и документы / каталоги
    проект скопирован.
 3. Наконец, файлы преобразования в почтовом / каталоге используются, чтобы генерировать
    преобразованные документы.

Файлы, произведенные более поздними шагами, перезапишут существующие файлы от более ранних шагов.

30.4.3. Добавление главы к файлу преобразования

Преобразование разделено по разнообразным файлам преобразования, один на "часть"
справочник. Это - все о создании преобразования, легче управлять и инструменты к
выполните хорошо. Основное правило ползунка - это, если некоторый контент перемещен, это
должен, вероятно, все еще закончиться том же самом файле преобразования. В этом случае,
инструменты даже обнаружат это, и преобразование будет перемещено автоматически.

Чтобы прибавить документ файлу преобразования, действительно любите это:

сделайте прибавляют ДОКУМЕНТ = "src/introduction/the-neo4j-graphdb.asciidoc" ЧАСТЬ = "введение"

Если файл преобразования не будет уже существовать, то он будет создаваться.
документ будет прибавлен к файлу конфигурации сборки преобразования также.
(Конфигурация находится в соответствующем.conf файле в почтовом / каталоге.)

Если там существует преобразованная копия документа в расположении ДОКУМЕНТ
параметр указывает на, сценарий попытается заполнить файл преобразования
с преобразованными абзацами из того документа. Заметьте что строение
документ должен быть идеальной парой, или он перестанет работать. Однако, погрешность
сообщения полезны, так только фиксируют и попробовали еще раз, пока это не работает! Преобразование
файл и конфигурация только изменены, когда первая часть успешно выполняется.

Замечание

Только документы, которые должны быть преобразованы, должны быть прибавлены. Например Код
запросы и результаты запроса не должны быть преобразованы. Вообще, документы
нахожение в названном каталоге включает, не должен быть преобразован.

Также заметьте, что AsciiDoc включают:: строки обычно - не часть
преобразование вообще, но обработанный автоматически. В случае, если они должны быть обработаны
по-другому в документе, это должно быть сконфигурировано в соответствующем.conf
файл. Например нормальная запись документа в таком файле может быть похожей на это:

[введите: asciidoc] target/original/src/operations/index.asciidoc fr:target/src/operations/index.asciidoc

Чтобы сконфигурировать единственный документ, чтобы не обработать, включайте:: строки автоматически, добавиться
следующее в конце строки:

выберите: "-o definitions=target/tools/main/resources/conf/translate-includes"

30.4.4. Поток операций

Во-первых, используйте Знатока, чтобы установить среду и загрузить исходный справочник и
инструменты документации:

mvn чистят пакет

Чтобы обновить исходный справочник и инструменты, используйте команду знатока снова. Для
польза хранения в синхронизации с исходным справочником, ежедневным выполнением этого
команда рекомендуется.

Как только вещи установлены, использование делают во время работы.

  * делают  -  тем же самым, как делают предварительный просмотр.
  * делают, прибавляют, что  -  прибавляют документ файлу преобразования.
  * делают предварительный просмотр  - , обновляют и создают предварительный просмотр справочника.
  * делают обновление  -  файлы преобразования обновления из оригинала и сгенерированный
    преобразованные документы.

Предварительный просмотр преобразованного справочника найден в target/html/каталоге.

Фактическая работа над преобразованием сделана, редактируя файлы преобразования. Предложенный
инструменты для этого найдены ниже.

30.4.5. Инструменты преобразования

Есть различные редакторы для.po файлов, содержащих преобразования Ниже,
список редакторов.

  * Gtranslator <http://projects.gnome.org/gtranslator/>
  * Lokalize <http://userbase.kde.org/Lokalize>
  * Virtaal <http://translate.sourceforge.net/wiki/virtaal/index>
  * Poedit <http://www.poedit.net/>

30.5. Содействие Кода к Neo4j

30.5.1. Введение
30.5.2. Основные принципы управления
30.5.3. Роли спонсора
30.5.4. Поток операций содействия
30.5.5. Вытяните контрольный список запроса
30.5.6. Тесты модуля
30.5.7. Стиль кода
30.5.8. Сообщения о фиксации
30.5.9. Подписание CLA
30.5.10. Не объединяйте, используйте переоснову вместо этого!
30.5.11. Единственная фиксация

30.5.1. Введение

Сообщество Neo4j - бесплатное программное обеспечение и центрируемое сообщество разработчиков ПО с открытым исходным кодом
вокруг программного обеспечения и компонентов для Базы данных Графика Neo4j. Это спонсируется
Нео Технология <http://neotechnology.com>, который обеспечивает инфраструктуру
(различные виды хостинга, документации, и т.д.) так же как люди, чтобы управлять
это. Сообщество Neo4j - открытое сообщество, поскольку оно приветствует любого
элемент, который принимает основной criterias содействия и прилипает к
Нормы поведения сообщества.

Содействие может быть во многих формах (документация, обсуждения, отчеты об ошибках).
Этот документ выделяет правила управления для спонсора кода.

30.5.2. Основные принципы управления

Короче говоря Вы должны знать о следующих основных принципах, если Вы желаете
вносить код:

  * Все программное обеспечение, опубликованное проектом Neo4j, должно быть, было внесено
    в соответствии с Лицензионным соглашением Спонсора Кода Neo4j.
  * Neo4j - бесплатное программное обеспечение и сообщество разработчиков ПО с открытым исходным кодом. Как спонсор, Вы
    свободны разместить Вашу работу в соответствии с любой лицензией, которая была одобрена
    любой Фонд свободного программного обеспечения <http://www.fsf.org/> или Открытое
    Исходная Инициатива <http://opensource.org>. Вы все еще сохраняете авторское право, таким образом,
    в дополнение к той лицензии Вы можете, конечно, выпустить свою работу под любым
    другая лицензия (например полностью собственная лицензия), только не на
    Инфраструктура Neo4j.
  * программное обеспечение Neo4j разделено на компоненты. Репозитарий Литника содержит также
    единственные или разнообразные компоненты.
  * исходный код должен следовать за Стилем Кода Neo4j и "согласоваться" с
    Инфраструктура Neo4j столько, сколько разумна для определенного компонента.

30.5.3. Роли спонсора

Каждый единичный, который вносит код, делает так в контексте роли (a
у единственного единичного могут быть разнообразные роли). Роль определяет их
обязанности и полномочия:

  * патч submitter является человеком, который хочет внести патч к
    существующий компонент. См. Поток операций ниже.
  * committer может внести код прямо одному или более компонентам.
  * компонентный специалист по обслуживанию отвечает за определенный компонент. Они могут:

      o фиксируют код в репозитарии своего компонента,
      o управляют билетами для репозитария,
      o предоставляют права нажатия на репозитарий.
  * администратор Neo4j управляет инфраструктурой Neo4j. Они:

      o определяют новые компоненты и присваивают компонент maintainership,
      o диск, наставник и пассажирский вагон компонентная разработка Neo4j.

30.5.4. Поток операций содействия

Вклады кода Neo4j обычно делаются через Запросы Получения по запросу Github,
после потока операций, показанного ниже. Пожалуйста, проверьте контрольный список запроса получения по запросу
перед отсылкой получения по запросу запрашивают также.

 1. Разветвите соответствующий репозитарий Github.
 2. Создайте новое ответвление для своей определенной функции или фиксируйте.
 3. Запишите тесты модуля для своего кода.
 4. Запишите код.
 5. Запишите соответствующие записи Javadocs и Manual.
 6. Изменения фиксации.
 7. Отправьте запрос получения по запросу.

30.5.5. Вытяните контрольный список запроса

 1. Подпишите CLA.
 2. Гарантируйте, что Вы не прибавили фиксаций слияния.
 3. Выжмите все свои изменения в единственную фиксацию.
 4. Переоснова против самого последнего ведущего устройства.
 5. Выполните все соответствующие тесты.
 6. Отправьте запрос!

30.5.6. Тесты модуля

У Вас есть намного более высокий шанс получения Ваших изменений, принятых, если Вы предоставляете нас
с малой величиной читаемые тесты модуля, покрывающие код, Вы записали. Кроме того, сделайте
уверенный Ваш код не нарушает существующих тестов. Заметьте, что может быть
нисходящие компоненты, которые должны быть протестированы также, в зависимости от какой Вы
изменение.

Чтобы выполнить тесты, используйте Знатока, а не Ваш IDE, чтобы гарантировать, что другие могут тиражироваться
Ваш тестовый прогон. Команда для того, чтобы выполнить тесты Neo4j в любом данном компоненте
чистые mvn проверяют.

30.5.7. Стиль кода

Стиль Кода Neo4j сохраняется на GitHub в стилях для различных IDE
<https://github.com/neo4j/neo4j.github.com/tree/master/code-style>.

30.5.8. Сообщения о фиксации

Пожалуйста, проявите некоторую заботу в обеспечении хороших сообщений о фиксации. Используйте свой здравый смысл.
В особенности:

  * английский язык Использования. Это включает присущую пунктуацию и корректное написание. Фиксация
    сообщения, как предполагается, передают некоторую информацию сразу  - , они не
    чат-комната.
  * Помнят, что фиксация - changeset, который описывает когезионный набор
    изменения через потенциально много файлов. Попытайтесь сгруппировать каждую фиксацию как a
    логическое изменение. Объясните, что это изменяет. Если Вы должны восстановить работу, Вас
    мог бы хотеть очистить Ваш журнал фиксации прежде, чем сделать запрос получения по запросу.
  *, Если Вы исправляете ошибку или проблему, это связано с билетом, затем обратитесь к
    билет в сообщении. Например, `‘Прибавленный это и затем измененный это.
    Это исправления #14.’' Только упоминающий #xxx в фиксации соединит это с
    Проблема GitHub с тем номером, см. проблемы GitHub <https://github.com/blog/
    831-issues-2-0-the-next-generation>. Любой из этих синонимов будет также работать:

      o исправления #xxx
      o фиксированный #xxx
      o фиксируют #xxx
      o закрывается #xxx
      o закрываются #xxx
      o закрытый #xxx.
  * Не забывают передавать намерение. Не будьте слишком кратки, но не обеспечивайте слишком много
    деталь, также. Это - то, для чего разность литника.

30.5.9. Подписание CLA

Один решающий аспект содействия - Лицензионное соглашение Спонсора. В
краткость: удостоверьтесь, что подписали CLA, или проект Neo4j не будет в состоянии принять
Ваше содействие.

30.5.10. Не объединяйте, используйте переоснову вместо этого!

Поскольку мы хотели бы, чтобы каждое содействие содержалось в единственной фиксации,
фиксации слияния не позволены в запросе получения по запросу. Слияния грязны, и
должен только быть сделан когда необходимо, eg., объединяя ответвление в ведущее устройство к
помните, куда код прибыл из.

Если Вы хотите обновить свое ответвление разработки, чтобы включить самые последние изменения
от ведущего устройства, используйте переоснову литника. Для получения дополнительной информации на том, как использовать переоснову, см. справочник Литника
на переоснове: Справочник Литника <http://git-scm.com/book/en/Git-Branching-Rebasing>.

30.5.11. Единственная фиксация

Если у Вас есть разнообразные фиксации, Вы должны выжать их в единственный для
вытяните запрос, если нет некоторая экстраординарная причина не к. Хранение Ваш
изменения в единственной фиксации делают историю фиксации легче читать, это также
облегчает возвращаться и перемещать функции.

Один способ сделать это к, стоя на Вашем локальном ответвлении с Вашим
изменения, создайте новое ответвление и затем в интерактивном режиме повторно базируйте свои фиксации в a
выберите тот.

Интерактивное перебазирование с Литником.

# На ответвлении mychanges
контроль литника-b mychanges-чистый

# Принятие Вы имеете 4 фиксации, повторно базируете последние четыре фиксации в интерактивном режиме:
переоснова литника-i HEAD~4

# В диалоговом литнике дает Вам, сохраните свою первую фиксацию, и выжмите всех других в нее.
# Затем перефразируют описание фиксации, чтобы точно изобразить то, что делает Ваша фиксация.
# Если применимый, включайте любые номера выпуска как так: #760

Для получения дополнительной информации, см. справочник литника: http://git-scm.com/book/en/
Git-Tools-Rewriting-History#Changing-Multiple-Commit-Messages <http://
git-scm.com/book/en/Git-Tools-Rewriting-History#
Разнообразные сообщения о фиксации изменения>

Если Вас просят модифицировать части Вашего кода, вставьте свое исходное ответвление
(тот с разнообразными фиксациями), и следуют за вышеупомянутым процессом, чтобы создать фиксированный
единственная фиксация.

30.6. Спонсоры

Как Проект С открытым исходным кодом, Пользовательское сообщество Neo4j расширяет свое самое теплое спасибо
всем спонсорам, которые подписали Раздел 30.1, “Лицензия Спонсора
Соглашение” до настоящего времени и способствует этому коллективному усилию.

назовите ID GIThub
Йохан Свенсон johan-нео <https://github.com/johan-neo>

Эмиль Эифрем emileifrem <https://github.com/emileifrem>

Питер Неубоер peterneubauer <https://github.com/
                 peterneubauer>

Маттиас Персзон tinwelint <https://github.com/tinwelint>

Тобиас Линдакер thobe <https://github.com/thobe>

Андерс Норот nawroth <https://github.com/nawroth>

Андрес Тэйлор systay <https://github.com/systay>

Джейкоб Ханссон jakewins <https://github.com/jakewins>

Джим Уэббер jimwebber <https://github.com/jimwebber>

Джош Аделл jadell <https://github.com/jadell>

Андреас akollegger <https://github.com/akollegger>
Kollegger

Крис Джиорэн digitalstain <https://github.com/digitalstain>

Томас Баум tbaum <https://github.com/tbaum>

Алистер Джонс apcj <https://github.com/apcj>

Майкл Хунджер jexp <https://github.com/jexp>

Еспер Нильсон jespernilsson <https://github.com/
                 jespernilsson>

Том Салстон tomsulston <https://github.com/tomsulston>

Дэвид Монтэг dmontag <https://github.com/dmontag>

Марлон Рикэрт marlonrichert <https://github.com/
                 marlonrichert>

Хьюго Джозефсон hugojosefson <https://github.com/hugojosefson>

Vivek Prahlad vivekprahlad <https://github.com/vivekprahlad>

Адриано Альмейда adrianoalmeida7 <https://github.com/
                 adrianoalmeida7>

Бенджамин Джехрелс BGehrels <https://github.com/BGehrels>

Кристофер Фэкод <https://github.com/FaKod>
Шмидт

Паскаль Рефелдт prehfeldt <https://github.com/prehfeldt>

Бьорн Зедерквист cybear <https://github.com/cybear>

Абдул Азиз abdulazeezsk <https://github.com/abdulazeezsk>
Shaik

Джеймс Торнтон espeed <https://github.com/espeed>

Radhakrishna nrkkalyan <https://github.com/nrkkalyan>
Kalyan

Мишель van den promontis <https://github.com/promontis>
Айсберг

Брэндон bm3780 <https://github.com/bm3780>
Маккослин

Hendy Irawan ceefour <https://github.com/ceefour>

Luanne Misquitta luanne <https://github.com/luanne>

Джим Рэдфорд radford <https://github.com/radford>

Аксель Моргнер amorgner <https://github.com/amorgner>

Редактор Тэйлора Були <https://github.com/editor>

Алекс Смирнов alexsmirnov <https://github.com/alexsmirnov>

Иоганнес jotomo <https://github.com/jotomo>
Mockenhaupt

Пабло Пареха pablopareja <https://github.com/pablopareja>
Tobes

Бьорн Гранвик bjorngranvik <https://github.com/bjorngranvik>

Джулиан Симпсон simpsonjulian <https://github.com/
                 simpsonjulian>

Пабло Пареха pablopareja <https://github.com/pablopareja>
Tobes

Rickard Öberg rickardoberg <https://github.com/rickardoberg>

Штефан sarmbruster <https://github.com/sarmbruster>
Armbruster

Штефан Хагеман shageman <https://github.com/shageman>

Линэн Ван wangii <https://github.com/wangii>

Иэн Робинсон iansrobinson <https://github.com/iansrobinson>

Марко Родригес okram <https://github.com/okram>

Saikat Kanjilal skanjila <https://github.com/skanjila>

Крэйг Тавернер craigtaverner <https://github.com/
                 craigtaverner>

Дэвид Уинслоу dwins <https://github.com/dwins>

Патрик paddydub <https://github.com/paddydub>
Фицджеральд

Штефан Бердер hrbonz <https://github.com/hrbonz>

Майкл Кэннер Сепиэгруп <https://github.com/SepiaGroup>

Лин Жемин miaoski <https://github.com/miaoski>

Кристоф kwattro <https://github.com/kwattro>
Виллемсен

Тони Луи kooyeed <https://github.com/kooyeed>

Майкл Клишин michaelklishin <https://github.com/
                 michaelklishin>

Вез Фримен wfreeman <https://github.com/wfreeman>

Крис Леишмен cleishm <https://github.com/cleishm>

Брайан Левин blevine <https://github.com/blevine>

Бен Дей benday280412 <https://github.com/benday280412>

Давиде Савацци svzdvd <https://github.com/svzdvd>

Найджел Смол nigelsmall <https://github.com/nigelsmall>

Lasse lassewesth <https://github.com/lassewesth>
Вест-Нильсен

Wujek Srujek wujek-srujek <https://github.com/wujek-srujek>

Александр Александерястребов <https://github.com/
Ястребов Александерястребов>

Майк Брайант mikesname <https://github.com/mikesname>

Клаус Гроссман iKlaus <https://github.com/iKlaus>

Пабло Лаллони plalloni <https://github.com/plalloni>

Испуг Штефана Плантикова <https://github.com/boggle>

Трентонский Сильный trentonstrong <https://github.com/
                 trentonstrong>

Мацей Мэзур mamciek <https://github.com/mamciek>

Немецкий Borbolla germanborbolla <https://github.com/
                 germanborbolla>

Лорент Рофэйст lra <https://github.com/lra>

Томас Хэфел Перфект-Пиксель <https://github.com/
                 Совершенный пиксель>

Севки Азирчи Севки <https://github.com/Sevki>

Макс Де Марзи maxdemarzi <https://github.com/maxdemarzi>

Фургон Pieter-Яна PieterJanVanAeken <https://github.com/
Aeken PieterJanVanAeken>

Шэйн Гиббс sgibbs-kellermed <https://github.com/
                 sgibbs-kellermed>

Инь Ван yinwang0 <https://github.com/yinwang0>

Volker Lanting VolkerL <https://github.com/VolkerL>

Марк Нидхэм mneedham <https://github.com/mneedham>

Крис Вест chrisvest <https://github.com/chrisvest>

Бен Батлер-Коул benbc <https://github.com/benbc>

Tatham Oddie tathamoddie <https://github.com/tathamoddie>

Часть VIII. Усовершенствованное Использование

Эта часть содержит информацию об усовершенствованном использовании Neo4j. Среди тем
покрытый встраивают Neo4j в Ваше собственное программное обеспечение и пишут плагины для
Сервер Neo4j.

Оглавление

31. Расширение Сервера Neo4j

    31.1. Плагины сервера
    31.2. Неуправляемые Расширения
    31.3. Установка Плагинов и Расширений в Рабочем столе Neo4j

32. Используя Neo4j, встроенный в приложения Java

    32.1. Включайте Neo4j в свой проект
    32.2. Привет Мир
    32.3. Пользовательская база данных с наследством индексирует
    32.4. Пользовательская база данных с индексирует
    32.5. Управление ресурсами при использовании длинных рабочих транзакций
    32.6. Тестирование основной единицы
    32.7. Обход
    32.8. Объекты домена
    32.9. Примеры Алгоритма графика
    32.10. Чтение атрибута управления
    32.11. Как создать уникальные вершины
    32.12. Выполните Запросы Кода от Java
    32.13. Параметры запроса

33. Платформа Обхода

    33.1. Основные понятия
    33.2. API Java Платформы обхода

34. Индексация наследства

    34.1. Введение
    34.2. Создать
    34.3. Стереть
    34.4. Добавиться
    34.5. Перемещение
    34.6. Обновление
    34.7. Поиск
    34.8. Отношение индексирует
    34.9. Метки
    34.10. Конфигурация и fulltext индексируют
    34.11. Дополнительные функции для Lucene индексируют
    34.12. Автоматическая Индексация

35. Пакетная Вставка

    35.1. Пакетные Примеры Вставки
    35.2. Пакетная База данных Графика
    35.3. Индексируйте Пакетную Вставку

Глава 31. Расширение Сервера Neo4j

Сервер Neo4j может быть расширен или плагинами или неуправляемыми расширениями.

31.1. Плагины сервера

Быстрая информация

  * функциональность сервера может быть расширена, прибавляя плагины.
  * Плагины определены пользователем код, которые расширяют возможности
    база данных, вершины, или отношения.
  * neo4j сервер будет тогда рекламировать сменную функциональность в пределах
    представления как клиенты взаимодействуют через HTTP.

Плагины обеспечивают легкий способ расширить API REST Neo4j с помощью нового
функциональность, без потребности изобрести Ваш собственный API. Думайте о плагинах как
серверные сценарии, которые могут прибавить функции для получения и управления
вершины, отношения, пути, свойства или индексы.

Подсказка

Если Вы хотите иметь полный контроль над своим API, и готовы вставить
усилие, и понимает риски, тогда сервер Neo4j также обеспечивает рычаги для
неуправляемые расширения, основанные на JAX-РТС.

Необходимые классы находятся в org.neo4j:server-api <http://search.maven.org/
#search|gav|1|g%3A%22org.neo4j%22%20AND%20a%3A%22server-api%22> встряхивают файл. См.
соединенная страница для загрузок и инструкций по тому, как включать это использование
управление зависимостью. Для проектов Знатока, включите зависимости от API Сервера
Ваш pom.xml как это:

<зависимость>
  <groupId> org.neo4j </groupId>
  <artifactId> сервер-api </artifactId>
  <версия> $ {neo4j-версия} </версия>
</зависимость>

Где $ {neo4j-версия} является намеченной версией.

Чтобы создать плагин, Ваш код должен наследоваться от ServerPlugin <http://
components.neo4j.org/server-api/2.0.0/apidocs/org/neo4j/server/plugins/
ServerPlugin.html> класс. Ваш плагин должен также:

  * гарантируют, что это может произвести (Повторяемый из) Вершина, Отношение или Путь, любой
    Примитивный Java или Строка или экземпляр a
    org.neo4j.server.rest.repr.Representation
  * определяют параметры,
  * определяют точку расширения и конечно
  * содержат логику приложения.
  * удостоверяются, что точка открытия вводит @PluginTarget и
    Параметр @Source имеет тот же самый тип.

Пример плагина, который увеличивает базу данных (в противоположность вершинам или
отношения), следует:

Получите весь плагин вершин или отношений.

@Description ("Расширение Сервера Neo4j для того, чтобы получить все вершины или отношения")
общедоступный класс GetAll расширяет ServerPlugin
{
    @Name ("get_all_nodes")
    @Description ("Получают все вершины от базы данных графика Neo4j"),
    @PluginTarget (GraphDatabaseService.class)
    общественность, Повторяемая <Вершина> getAllNodes (@Source GraphDatabaseService graphDb)
    {
        возвратите GlobalGraphOperations.at (graphDb).getAllNodes ();
    }

    @Description ("Получают все отношения от базы данных графика Neo4j"),
    @PluginTarget (GraphDatabaseService.class)
    общественность, Повторяемая <Отношение> getAllRelationships (@Source GraphDatabaseService graphDb)
    {
        возвратите GlobalGraphOperations.at (graphDb).getAllRelationships ();
    }
}

Полный исходный код найден здесь: GetAll.java <https://github.com/neo4j/neo4j
/blob/2.0.0/community/server-examples/src/main/java/org/neo4j/examples/server/
plugins/GetAll.java>

Обнаружьте кратчайший путь между двумя плагинами вершин.

общедоступный класс ShortestPath расширяет ServerPlugin
{
    @Description ("Обнаруживают кратчайший путь между двумя вершинами.")
    @PluginTarget (Node.class)
    общественность, Повторяемая <Путь> shortestPath (
            Источник Вершины @Source,
            @Description ("Вершина, чтобы обнаружить кратчайший путь к.")
                @Parameter (называют = "цель"), цель Вершины,
            @Description ("Отношение вводит, чтобы следовать, ища кратчайший путь (и)." +
                    "Порядок является незначащим, если опущено, все типы сопровождаются.")
                @Parameter (называют = "типы", дополнительные = истина), Строка [] типы,
            @Description ("Максимальная длина пути до поиска, значение по умолчанию (если опущено) 4.")
                @Parameter (называют = "глубина", дополнительная = истина) Целочисленная глубина),
    {
        Расширитель расширителя;
        если (вводит == нуль),
        {
            расширитель = Traversal.expanderForAllTypes ();
        }
        еще
        {
            расширитель = Traversal.emptyExpander ();
            для (интервал i = 0; я <types.length; я ++)
            {
                расширитель = expander.add (DynamicRelationshipType.withName (типы [я]));
            }
        }
        PathFinder <Путь> shortestPath = GraphAlgoFactory.shortestPath (
                расширитель, глубина == нуль? 4: depth.intValue ());
        возвратите shortestPath.findAllPaths (источник, цель);
    }
}

Полный исходный код найден здесь: ShortestPath.java <https://github.com/neo4j
/neo4j/blob/2.0.0/community/server-examples/src/main/java/org/neo4j/examples/
server/plugins/ShortestPath.java>

Чтобы развернуть код, просто скомпилируйте это в.jar файл и разместите это на
путь к классу сервера (который условно является каталогом плагинов под Neo4j
корневой каталог сервера).

Подсказка

Удостоверьтесь, что списки каталогов сохранены в jarfile также
создание со Знатоком значения по умолчанию, или с толчком-cvf myext.jar *, удостоверяясь дребезжать
каталоги вместо того, чтобы определить единственные файлы.

.jar файл должен включать файл META-INF/services/
org.neo4j.server.plugins. ServerPlugin с полностью определенным именем
класс реализации. Это - пример с разнообразными записями, каждым на a
отдельная строка:

org.neo4j.examples.server.plugins. GetAll
org.neo4j.examples.server.plugins.DepthTwo
org.neo4j.examples.server.plugins.ShortestPath

Код выше делает расширение видимым в представлении базы данных (через
@PluginTarget аннотация) всякий раз, когда это обслужено от Сервера Neo4j.
Просто изменяя @PluginTarget параметр на Node.class или Relationship.class
позволяет нам предназначаться для тех частей модели данных, должен мы желать.
расширения функциональности, обеспеченные плагином, автоматически рекламируются в
представления на проводе. Например, клиенты могут обнаружить расширение
реализованный вышеупомянутым плагином легко, исследуя представления они
получите как реакции от сервера, например, выполняя GET на значении по умолчанию
URI базы данных:

завихритесь-v http://localhost:7474/db/data/

Реакция на ПОЛУЧИТЬ запрос будет содержать (по умолчанию) контейнер ДЖСОНА это
непосредственно делится без остатка, контейнер вызывал "расширения", где доступные плагины
перечисленный. В следующем случае нам только зарегистрировали плагин GetAll в
сервер, таким образом, только его функциональность расширения доступна. Имена расширения
будет автоматически присвоен, основан на именах методов, если не определенно
указанное использование @Name аннотации.

{
"информация расширений": "http://localhost:7474/db/data/ext",
"вершина": "http://localhost:7474/db/data/node",
"node_index": "http://localhost:7474/db/data/index/node",
"relationship_index": "http://localhost:7474/db/data/index/relationship",
"reference_node": "http://localhost:7474/db/data/node/0",
"extensions_info": "http://localhost:7474/db/data/ext",
"расширения": {
  "GetAll": {
    "get_all_nodes": "http://localhost:7474/db/data/ext/GetAll/graphdb/get_all_nodes",
    "get_all_relationships": "http://localhost:7474/db/data/ext/GetAll/graphdb/getAllRelationships"
  }
}

Выполнение GET на одном из двух URI расширения отдает meta
информация о службе:

завихрение http://localhost:7474/db/data/ext/GetAll/graphdb/get_all_nodes

{
  "расширяется": "graphdb",
  "описание": "Получите все вершины от базы данных графика Neo4j",
  "имя": "get_all_nodes",
  "параметры": []
}

Использовать это, только POST к этому URL, с параметрами как определено в
описание и закодированный как контент данных ДЖСОНА. F.ex для того, чтобы вызвать самое короткое
расширение пути (URI, погашенный от ПОЛУЧЕНИЯ до http://localhost:7474/db/data/node/123
<http://localhost:7474/db/data/node/123>):

завихритесь-X POST http://localhost:7474/db/data/ext/GetAll/node/123/shortestPath \
  -H "Тип контента: application/json" \
  -d' {"цель": "http://localhost:7474/db/data/node/456&depth=5"}'

Если все будет в порядке, то код реакции 200 и список нуля или большего количества элементов будет
быть возвращенным. Если ничто не возвращено (нуль возвратился из расширения), пустое
результат и реакция кодируют 204, будет возвращен. Если расширение бросает
реакция исключения кодирует 500, и детализированное сообщение об ошибке возвращено.

Расширения, которые делают любой вид работы записи, должны будут управлять своим собственным
транзакциями, то есть транзакциями не управляют автоматически.

Через эту модель любой плагин может естественно вписаться в общую гиперсреду
схема, что Neo4j поддерживает  -  подразумевать, что клиенты могут все еще использовать в своих интересах
отделения как Вершины, Отношения и Пути с прямым обновлением
путь как серверы обогащен плагинами (старые клиенты не ломаются).

31.2. Неуправляемые Расширения

Быстрая информация

  * Опасность: Мужчины на Работе! Неуправляемые расширения - способ развернуться
    произвольный код JAX-РТС в сервер Neo4j.
  * неуправляемые расширения состоят точно в том что: неуправляемый. Если Вы отбрасываете плохо
    протестированный код в сервер, очень вероятно, что Вы ухудшите
    производительность, так быть осторожным.

Некоторые проекты хотят чрезвычайно точную регулировку по своему серверному коду. Для этого
мы представили неуправляемый API расширения.

Предупреждение

Это - резкий инструмент, разрешая пользователям развернуть произвольную JAX-РТС <http://
en.wikipedia.org/wiki/JAX-RS> классы сервера и таким образом, Вы должны быть
осторожный, думая об использовании этого. В особенности Вы должны понять
то, что легко занимать много места "кучи" на сервере и препятствовать
производительность, если Вы не осторожны.

Однако, если Вы понимаете правовую оговорку, тогда Вы загружаете свои классы JAX-РТС в
сервер Neo4j просто, прибавляя @Context аннотацию к Вашему коду, компилируя
против толчка JAX-РТС и любые толчки Neo4j Вы используете. Затем прибавьте Ваш
классы пути к классу времени выполнения (только отбрасывают это в каталоге lib
Сервер Neo4j). Взамен Вы получаете доступ к размещенной среде Neo4j
сервер как журналирование через org.neo4j.server.logging. Регистратор.

В Вашем коде Вы получаете доступ к базовому GraphDatabaseService через
Аннотация @Context как так:

общедоступный MyCoolService (@Context база данных GraphDatabaseService)
{
  //Весело проведите время здесь, но быть безопасными!
}

Помните, неуправляемый API - очень резкий инструмент. Это - все к легкому к
поставите под угрозу сервер, развертывая код этот путь, так что думайте сначала и см. если Вы
не может использовать управляемые расширения в предпочтении. Однако, много контекстов
параметры могут быть автоматически предоставлены Вам, как ссылка на
база данных.

Чтобы определить точку монтирования Вашего расширения, полный класс похож
это:

Неуправляемый пример расширения.

@Path ("/helloworld")
общедоступный класс HelloWorldResource
{
    частная конечная база данных GraphDatabaseService;

    общедоступный HelloWorldResource (@Context база данных GraphDatabaseService)
    {
        this.database = база данных;
    }

    @GET
    @Produces (MediaType. TEXT_PLAIN)
    @Path ("/{nodeId}")
    общедоступная Реакция привет (@PathParam ("nodeId") долго nodeId)
    {
        //Действительно набейте с базой данных
        возвратите Response.status (Состояние. OK).entity (
                ("Привет Мир, nodeId =" + nodeId).getBytes (Charset.forName ("UTF-8"))).build ();
    }
}

Полный исходный код найден здесь: HelloWorldResource.java <https://github.com
/neo4j/neo4j/blob/2.0.0/community/server-examples/src/main/java/org/neo4j/
examples/server/unmanaged/HelloWorldResource.java>

Создайте этот код, и разместите следующий файл толчка (и любые пользовательские зависимости)
в каталог $NEO4J_SERVER_HOME/plugins, и включают этот класс в
файл neo4j-server.properties, как так:

Подсказка

Удостоверьтесь, что списки каталогов сохранены в jarfile также
создание со Знатоком значения по умолчанию, или с толчком-cvf myext.jar *, удостоверяясь дребезжать
каталоги вместо того, чтобы определить единственные файлы.

Подсказка

Вы должны будете включать зависимость в API JAX-РТС на Вашем пути к классу когда Вы
скомпилировать. В Знатоке это было бы достигнуто, прибавляя следующий к англичанину
файл:

<зависимость>
    <groupId> javax.ws.rs </groupId>
    <artifactId> javax.ws.rs-api </artifactId>
    <версия> 2.0 </версия>
    <контекст> обеспечил </контекст>
</зависимость>

#Comma разделенный список пакетов JAXRS, содержащих Ресурс JAXRS, одно имя пакета для каждого mountpoint.
org.neo4j.server.thirdparty_jaxrs_classes=org.neo4j.examples.server.unmanaged=/examples/unmanaged

Который обязывает привет метод реагировать, чтобы ПОЛУЧИТЬ запросы в URI: http://
{neo4j_server}: {neo4j_port}/examples/unmanaged/helloworld / {nodeId}

завихрение http://localhost:7474/examples/unmanaged/helloworld/123

который следует

Привет Мир, nodeId=123

31.3. Установка Плагинов и Расширений в Рабочем столе Neo4j

Рабочий стол Neo4j может также быть расширен с помощью плагинов сервера и расширений. Neo4j
Рабочий стол прибавит все толчки в %ProgramFiles %\Neo4j Community\plugins к
путь к классу, но, пожалуйста, заметьте, что вложенные каталоги для плагинов в настоящий момент
не поддерживаемый.

Иначе плагины сервера и расширения подчиняются тем же самым правилам как обычно.
Пожалуйста, заметьте, конфигурируя расширения сервера это neo4j-server.properties для
Рабочий стол Neo4j живет в %APPDATA %\Neo4j Сообщество.

Глава 32. Используя Neo4j, встроенный в приложения Java

Это - удобный Neo4j, встроенный в приложения Java. В этой главе Вы будете
обнаружьте, что все нуждалось в -  от установки среды к выполнению чего-то
полезный с Вашими данными.

32.1. Включайте Neo4j в свой проект

32.1.1. Прибавьте Neo4j к создавать пути
32.1.2. Выпуски
32.1.3. Прибавьте Neo4j как зависимость
32.1.4. Запуск и остановка

После выбора соответствующего выпуска для Вашей платформы, встройте Neo4j в Ваш
Приложение Java включением библиотеки Neo4j дребезжит в Вашем создавать.
следующие разделы покажут, как сделать это любым изменением создавать путь
прямо или при использовании управления зависимостью.

32.1.1. Прибавьте Neo4j к создавать пути

Получите библиотеки Neo4j из одного из этих источников:

  * Вытяжка загрузка Neo4j <http://neo4j.org/download/> zip/tarball, и использование
    файлы толчка, найденные в lib / каталог.
  * Использование файлы толчка, доступные от Знатока Центральный Репозитарий <http://
    search.maven.org/#search|ga|1|g%3A%22org.neo4j%22>

Прибавьте файлы толчка к своему проекту:

Инструменты JDK
    Добавьте к - путь к классу
Eclipse
      * Щелчок правой кнопкой по проекту и затем идет, Создают Путь →, Конфигурируют, Создают
        Путь. В диалоговом окне, выберите, Прибавляют Внешние JAR, обзор к lib Neo4j /
        каталог и избранный все файлы толчка.
      Опция * Another должна пользоваться Пользовательскими Библиотеками <http://help.eclipse.org/indigo
        /index.jsp?topic=/org.eclipse.jdt.doc.user/reference/preferences/java/
        buildpath/ref-preferences-user-libraries.htm>.
ИДЕЯ IntelliJ
    См. Библиотеки, Глобальные Библиотеки, и Сконфигурировать диалоговое окно Библиотеки <http://
    www.jetbrains.com/idea/webhelp/
    configuring-project-and-global-libraries.html>
NetBeans
      * Щелчок правой кнопкой по вершине Библиотек проекта, выберите, Прибавляют JAR/Прибор для испытания на излом
         просмотрите к lib Neo4j / каталог и избранный все файлы толчка.
      * Вы можете также обработать библиотеки от вершины проекта, видеть Управление a
        Путь к классу проекта <http://netbeans.org/kb/docs/java/
        project-setup.html#projects-classpath>.

32.1.2. Выпуски

Следующая таблица выделяет доступные выпуски и их имена для использования
с инструментами управления зависимости.

Подсказка

Следуйте за ссылками в таблице для деталей относительно конфигурации зависимости с
Знаток Apache, Apache Buildr, Плющ Apache, Виноград Groovy, Grails, Скала СБТ!

Табличные 32.1. Neo4j выпуски

Лицензия Описания Зависимости от выпуска
Сообщество org.neo4j:neo4j <http://search.maven.org/#search|gav|1| высокий GPLv3
           g%3A%22org.neo4j%22%20AND%20a%3A%22neo4j%22> производительность,
                                                                   полностью ACID
                                                                   транзакционный
                                                                   график
                                                                   база данных

Org.neo4j:neo4j-предприятие предприятия <http://search.maven.org/# прибавляющий AGPLv3
           search|gav|1 | совершенствовался
           g%3A%22org.neo4j%22%20AND%20a%3A%22neo4j-enterprise%22> контроль,
                                                                   онлайновое резервное копирование
                                                                   и Высоко
                                                                   Доступность
                                                                   кластеризация


Замечание

Перечисленные зависимости не содержат реализацию, но втягивает это
transitively.

Для получения дополнительной информации относительно лицензирования, см. Лицензирование Руководства <http://
www.neo4j.org/learn/licensing>.

32.1.3. Прибавьте Neo4j как зависимость

Вы можете или пойти с высокоуровневым артефактом от таблицы выше или включать
индивидуальные компоненты прямо. Примеры включали здесь использование
высокоуровневый подход артефакта.

32.1.3.1. Знаток

Зависимость знатока.

<проект>
...
 <зависимости>
  <зависимость>
   <groupId> org.neo4j </groupId>
   <artifactId> neo4j </artifactId>
   <версия> 2.0.0 </версия>
  </зависимость>
  ...
 </зависимости>
...
</проект>

Где artifactId найден в таблице выпусков.

32.1.3.2. Eclipse и Знаток

Для разработки в Eclipse <http://www.eclipse.org>, этому рекомендуют
установите m2e плагин <http://www.eclipse.org/m2e/> и пустите Знатоку управлять
проект создает путь к классу вместо этого, видит выше. Это также прибавляет возможность к
разработайте свой проект и через командную строку со Знатоком и имейте работу
Установка Eclipse для разработки.

32.1.3.3. Плющ

Удостоверьтесь, что разрешили зависимости от Центрального Знатока, например используя это
конфигурация в Вашем ivysettings.xml файл:

<ivysettings>
  <настройки defaultResolver = "основной"/>
  <преобразователи>
    <цепочка называют = "основной">
      <имя файловой системы = "локальный">
        <модель артефакта =" $ {ivy.settings.dir} / репозитарий / [артефакт] - [версия]. [расширение]"/>
      </файловая система>
      <ibiblio называют = "maven_central" корень = "http://repo1.maven.org/maven2/" m2compatible = "истина"/>
    </цепочка>
  </преобразователи>
</ivysettings>

С этим на месте Вы можете прибавить Neo4j к соединению при наличии чего-то вдоль них
строки к Вашему ivy.xml файл:

..
<зависимости>
  ..
  <зависимость org = "org.neo4j" называют = "neo4j" версия = "2.0.0"/>
  ..
</зависимости>
..

Где имя найдено в таблице выпусков выше

32.1.3.4. Gradle

Пример ниже показывает, что пример gradle создает сценарий для включения Neo4j
библиотеки.

определение neo4jVersion = "2.0.0"
примените плагин: 'java'
репозитарии {
   mavenCentral ()
}
зависимости {
   скомпилируйте "org.neo4j:neo4j: $ {neo4jVersion}"
}

Где координаты (org.neo4j:neo4j в примере) найдены в
таблица выпусков выше.

32.1.4. Запуск и остановка

Чтобы создать новую базу данных или ópen существующий, Вы инстанцируете
EmbeddedGraphDatabase <http://components.neo4j.org/neo4j/2.0.0/apidocs/org/
neo4j/kernel/EmbeddedGraphDatabase.html>.

graphDb = новый GraphDatabaseFactory ().newEmbeddedDatabase (DB_PATH);
registerShutdownHook (graphDb);

Замечание

Экземпляр EmbeddedGraphDatabase может быть совместно использован среди многозаходных резьб. Замечание
однако то, что Вы не можете создать разнообразные экземпляры, указывающие на ту же самую базу данных.

Чтобы остановить базу данных, вызовите завершение работы () метод:

graphDb.shutdown ();

Чтобы удостовериться Neo4j - выключение должным образом, Вы можете прибавить рычаг завершения работы:

частная статическая пустота registerShutdownHook (конечный GraphDatabaseService graphDb)
{
    //Регистрирует рычаг завершения работы для экземпляра Neo4j так, чтобы это
    //выключение приятно, когда VM выходит (даже если Вы "Ctrl-C"
    //запущение приложения).
    Runtime.getRuntime ().addShutdownHook (новая ветвь дискуссии ()
    {
        @Override
        общественность освобождает выполненный ()
        {
            graphDb.shutdown ();
        }
    } );
}

32.1.4.1. Запуск встроенной базы данных с настройками конфигурации

Чтобы запустить Neo4j с настроек конфигурации, файл свойств Neo4j может быть
загруженный как это:

GraphDatabaseService graphDb = новый GraphDatabaseFactory ()
    .newEmbeddedDatabaseBuilder (storeDir)
    .loadPropertiesFromFile (pathToConfig + "neo4j.properties")
    .newGraphDatabase ();

Или Вы могли, конечно, создать Вас собственная Карта <Строка, Строка> программно и
используйте это вместо этого, как так:

Карта <Строка, Строка> конфигурация = новый HashMap <Строка, Строка> ();
config.put ("neostore.nodestore.db.mapped_memory", "10M");
config.put ("string_block_size", "60");
config.put ("array_block_size", "300");
GraphDatabaseService graphDb = новый GraphDatabaseFactory ()
    .newEmbeddedDatabaseBuilder (storeDir)
    .setConfig (конфигурация)
    .newGraphDatabase ();

Для настроек конфигурации, см. Главу 22, Конфигурацию & Производительность.

32.1.4.2. Запуск встроенного экземпляра только для чтения

Если Вы хотите представление только для чтения базы данных, создаете экземпляр этот путь:

Карта <Строка, Строка> конфигурация = новый HashMap <> ();
config.put ("read_only", "истина");
graphDb = новый GraphDatabaseFactory ().newEmbeddedDatabaseBuilder (
        "target/read-only-db/location")
        .setConfig (конфигурация)
        .newGraphDatabase ();

Очевидно, база данных должна уже существовать в этом случае.

Замечание

Параллельный доступ к тем же самым файлам базы данных разнообразным (только для чтения или запись)
экземпляры не поддерживаются.

32.2. Привет Мир

32.2.1. Подготовьте базу данных
32.2.2. Операции обертки в транзакции
32.2.3. Создайте малый график
32.2.4. Печатайте результат
32.2.5. Переместите данные
32.2.6. Выключение сервер базы данных

Изучите, как создать и получить доступ к вершинам и отношениям. Для получения информации о
установка проекта, см. Раздел 32.1, “Включайте Neo4j в свой проект”.

Помните, от Раздела 2.1, “Какова База данных Графика?”, то, что график Neo4j
состав:

  * Вершины, которые соединены
  * Отношения, с
  * Свойства и на вершинах и на отношениях.

У всех отношений есть тип. Например, если график представляет социальное
сеть, тип отношения мог быть, ЗНАЕТ. Если отношение типа
ЗНАЕТ соединяет две вершины, который, вероятно, представляет двух человек, которые знают каждого
другой. Много семантики (который является значением) графика закодировано в
типы отношения приложения. И хотя отношения
направленный они одинаково хорошо пересечены, независимо от которого направления они
пересеченный.

Подсказка

Исходный код этого примера найден здесь: EmbeddedNeo4j.java <https://
github.com/neo4j/neo4j/blob/2.0.0/community/embedded-examples/src/main/java/org
/neo4j/examples/EmbeddedNeo4j.java>

32.2.1. Подготовьте базу данных

Типы отношения могут быть созданы при использовании перечисления. В этом примере мы только
нуждаюсь в единственном типе отношения. Это - то, как определить это:

частный статический перечислимый RelTypes реализует RelationshipType
{
    ЗНАЕТ
}

Мы также готовим некоторые переменные, чтобы использовать:

GraphDatabaseService graphDb;
Вершина firstNode;
Вершина secondNode;
Отношение отношения;

Следующий шаг должен запустить сервер базы данных. Заметьте что если данный каталог
поскольку база данных уже не существует, она будет создаваться.

graphDb = новый GraphDatabaseFactory ().newEmbeddedDatabase (DB_PATH);
registerShutdownHook (graphDb);

Заметьте, что запуск сервера базы данных является дорогой работой, не, запускаются - также
новый экземпляр каждый раз Вы должны взаимодействовать с базой данных!
экземпляр может быть совместно использован многозаходными резьбами. Транзакции - ограниченный поток.

Как замечено, мы регистрируем рычаг завершения работы, который удостоверится, что база данных закрывается
вниз, когда JVM выходит. Теперь пора взаимодействовать с базой данных.

32.2.2. Операции обертки в транзакции

Все операции должны быть выполнены в транзакции. Это - сознательное
проектное решение, так как мы полагаем, что разграничение транзакции важное
часть работы с реальной базой данных предприятия. Теперь, обработка транзакции в
Neo4j очень легок:

попробуйте (Транзакция tx = graphDb.beginTx ())
{
    //Операции базы данных идут сюда
    tx.success ();
}

Для получения дополнительной информации по транзакциям, см. Главу 16, управление Транзакцией
и API Java для Транзакции <http://components.neo4j.org/neo4j/2.0.0/apidocs/
org/neo4j/graphdb/Transaction.html>.

Замечание

Для краткости мы не обстоятельно объясняем обертывание операций в транзакции
всюду по справочнику.

32.2.3. Создайте малый график

Теперь, пустите нам создавать несколько вершин. API очень интуитивен. Не стесняйтесь иметь a
смотрите на JavaDocs в http://components.neo4j.org/neo4j/2.0.0/apidocs/ <http:
//components.neo4j.org/neo4j/2.0.0/apidocs/>. Они включены в
распределение, также. Вот то, как создать малое строение графика два
вершины, соединенные с одним отношением и некоторыми свойствами:

firstNode = graphDb.createNode ();
firstNode.setProperty ("сообщение", "Привет",);
secondNode = graphDb.createNode ();
secondNode.setProperty ("сообщение", "Мир!");

отношение = firstNode.createRelationshipTo (secondNode, RelTypes. ЗНАЕТ);
relationship.setProperty ("сообщение", "храбрый Neo4j");

У нас теперь есть график, который похож на это:

Рисунок 32.1. Привет Мировой График

Hello-World-Graph-java.svg


32.2.4. Печатайте результат

После того, как мы создали наш график, пустите нам читать из него и печатать результат.

System.out.print (firstNode.getProperty ("сообщение"));
System.out.print (relationship.getProperty ("сообщение"));
System.out.print (secondNode.getProperty ("сообщение"));

Который выведет:

Привет, храбрый Мир Neo4j!

32.2.5. Переместите данные

В этом случае мы переместим данные перед фиксацией:

//пустите нам перемещать данные
firstNode.getSingleRelationship (RelTypes. ЗНАЕТ, Направление. ВЫХОД).delete ();
firstNode.delete ();
secondNode.delete ();

Заметьте, что удаление вершины, у которой все еще есть отношения когда транзакция
фиксации перестанут работать. Это должно удостовериться, что у отношений всегда есть вершина запуска
и конечный узел.

32.2.6. Выключение сервер базы данных

Наконец, выключение сервер базы данных, когда приложение заканчивает:

graphDb.shutdown ();

32.3. Пользовательская база данных с наследством индексирует

Замечание

Пожалуйста, считайте Раздел 32.5, “Управляя ресурсами при использовании длинного выполнения
транзакции” на том, как должным образом закрыть ResourceIterators, возвратились из, индексируют
поиски.

Вы имеете пользовательскую базу данных, и хотите получить пользователей, по имени использующих наследство
индексация системы.

Подсказка

Исходный код, используемый в этом примере, найден здесь:
EmbeddedNeo4jWithIndexing.java <https://github.com/neo4j/neo4j/blob/2.0.0/
community/embedded-examples/src/main/java/org/neo4j/examples/
EmbeddedNeo4jWithIndexing.java>

Мы создали два метода помощника, чтобы обработать имена пользователя и добавляющихся пользователей к
база данных:

частная статическая Строка idToUserName (конечный международный идентификатор)
{
    возвратите "пользователя" + идентификатор + "@neo4j.org";
}

частная статическая Вершина createAndIndexUser (конечное Строковое имя пользователя)
{
    Вершина вершины = graphDb.createNode ();
    node.setProperty (USERNAME_KEY, имя пользователя);
    nodeIndex.add (вершина, USERNAME_KEY, имя пользователя);
    возвратите вершину;
}

Следующий шаг должен запустить сервер базы данных:

graphDb = новый GraphDatabaseFactory ().newEmbeddedDatabase (DB_PATH);
registerShutdownHook ();

Пора прибавить пользователей:

попробуйте (Транзакция tx = graphDb.beginTx ())
{
    nodeIndex = graphDb.index ().forNodes ("вершины");
    //Создайте некоторых пользователей и индексируйте их имена с IndexService
    для (международный идентификатор = 0; идентификатор <100; идентификатор ++)
    {
        createAndIndexUser (idToUserName (идентификатор));
    }

И вот то, как обнаружить пользователя Идентификатором:

интервал idToFind = 45;
Строковое имя пользователя = idToUserName (idToFind);
Вершина foundUser = nodeIndex.get (USERNAME_KEY, имя пользователя).getSingle ();

System.out.println ("Имя пользователя пользователя "+ idToFind +""
    + foundUser.getProperty (USERNAME_KEY));

32.4. Пользовательская база данных с индексирует

Вы имеете пользовательскую базу данных, и хотите получить пользователей, по имени использующих, индексирует.

Подсказка

Исходный код, используемый в этом примере, найден здесь:
EmbeddedNeo4jWithNewIndexing.java <https://github.com/neo4j/neo4j/blob/2.0.0/
community/embedded-examples/src/main/java/org/neo4j/examples/
EmbeddedNeo4jWithNewIndexing.java>

Для начала, мы запускаем сервер базы данных:

GraphDatabaseService graphDb = новый GraphDatabaseFactory ().newEmbeddedDatabase (DB_PATH);

Затем мы должны сконфигурировать базу данных, чтобы индексировать пользователей по имени. Это только нуждается
быть сделанным однажды.

IndexDefinition indexDefinition;
попробуйте (Транзакция tx = graphDb.beginTx ())
{
    Схема схемы = graphDb.schema ();
    indexDefinition = schema.indexFor (DynamicLabel.label ("Пользователь"))
            .on ("имя пользователя")
            .create ();
    tx.success ();
}

Индексирует заполнены асинхронно, когда они сначала создаются. Это
возможный использовать базовый API, чтобы ожидать индексируют совокупность, чтобы завершиться:

попробуйте (Транзакция tx = graphDb.beginTx ())
{
    Схема схемы = graphDb.schema ();
    schema.awaitIndexOnline (indexDefinition, 10, TimeUnit. СЕКУНДЫ);
}

Пора прибавить пользователей:

попробуйте (Транзакция tx = graphDb.beginTx ())
{
    Метка метки = DynamicLabel.label ("Пользователь");

    //Создайте некоторых пользователей
    для (международный идентификатор = 0; идентификатор <100; идентификатор ++)
    {
        Вершина userNode = graphDb.createNode (метка);
        userNode.setProperty ("имя пользователя", "пользователь" + идентификатор + "@neo4j.org");
    }
    System.out.println ("Пользователи создал");
    tx.success ();
}

И вот то, как обнаружить пользователя идентификатором:

Замечание

Пожалуйста, считайте Раздел 32.5, “Управляя ресурсами при использовании длинного выполнения
транзакции” на том, как должным образом закрыть ResourceIterators, возвратились из, индексируют
поиски.

Метка метки = DynamicLabel.label ("Пользователь");
интервал idToFind = 45;
Представьте nameToFind в виде строки = "пользователь" + idToFind + "@neo4j.org";
попробуйте (Транзакция tx = graphDb.beginTx ())
{
    попробуйте (ResourceIterator <Вершина> пользователи =
            graphDb.findNodesByLabelAndProperty (метка, "имя пользователя", nameToFind).iterator ())
    {
        ArrayList <Вершина> userNodes = новый ArrayList <> ();
        в то время как (users.hasNext)
        {
            userNodes.add (users.next);
        }

        для (Вершина вершины: userNodes)
        {
            System.out.println ("Имя пользователя пользователя" + idToFind + + node.getProperty ("имя пользователя"));
        }
    }
}

Обновляя имя пользователя, индексирование обновлено также:

попробуйте (Транзакция tx = graphDb.beginTx ())
{
    Метка метки = DynamicLabel.label ("Пользователь");
    интервал idToFind = 45;
    Представьте nameToFind в виде строки = "пользователь" + idToFind + "@neo4j.org";

    для (Вершина вершины: graphDb.findNodesByLabelAndProperty (метка, "имя пользователя", nameToFind))
    {
        node.setProperty ("имя пользователя", "пользователь" + (idToFind + 1) + "@neo4j.org");
    }
    tx.success ();
}

Стирая пользователя, это автоматически удалено от индексирования:

попробуйте (Транзакция tx = graphDb.beginTx ())
{
    Метка метки = DynamicLabel.label ("Пользователь");
    интервал idToFind = 46;
    Представьте nameToFind в виде строки = "пользователь" + idToFind + "@neo4j.org";

    для (Вершина вершины: graphDb.findNodesByLabelAndProperty (метка, "имя пользователя", nameToFind))
    {
        node.delete ();
    }
    tx.success ();
}

В случае, если мы изменяем нашу модель данных, мы можем отбросить индексирование также:

попробуйте (Транзакция tx = graphDb.beginTx ())
{
    Метка метки = DynamicLabel.label ("Пользователь");
    для (IndexDefinition indexDefinition: graphDb.schema ()
            .getIndexes (метка))
    {
        //Есть, только один индексирует
        indexDefinition.drop ();
    }

    tx.success ();
}

32.5. Управление ресурсами при использовании длинных рабочих транзакций

Необходимо всегда открыть транзакцию, получая доступ к базе данных.
В длинной рабочей транзакции это - хорошая практика, чтобы гарантировать что любой
ResourceIterator <http://components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/
graphdb/ResourceIterator.html> s полученный в транзакции закрыты как
рано насколько возможно. Это или достигнуто, только исчерпывая iterator или
явно вызывая его близкий метод.

То, что следует, является примером того, как работать с ResourceIterator. Поскольку мы не делаем
исчерпайте iterator, мы закроем его явно использование завершения () метод.

Метка метки = DynamicLabel.label ("Пользователь");
интервал idToFind = 45;
Представьте nameToFind в виде строки = "пользователь" + idToFind + "@neo4j.org";
попробуйте (Транзакция tx = graphDb.beginTx ();
      ResourceIterator <Вершина> пользователи = graphDb
            .findNodesByLabelAndProperty (метка, "имя пользователя", nameToFind)
            .iterator ())
{
    Вершина firstUserNode;
    если (users.hasNext)
    {
        firstUserNode = users.next ();
    }
    users.close ();
}

32.6. Тестирование основной единицы

Основная модель поблочного тестирования с Neo4j поясняется следующим
пример.

Чтобы получить доступ к средствам тестирования Neo4j, у Вас должно быть neo4j-ядро
tests.jar на пути к классу во время тестов. Вы можете загрузить это от Знатока
Центральный: org.neo4j:neo4j-ядро <http://search.maven.org/#search|ga|1|
g%3A%22org.neo4j%22%20AND%20a%3A%22neo4j-kernel%22>.

Используя Знатока как менеджер по зависимости Вы обычно прибавляли бы эту зависимость
вместе с JUnit и Hamcrest как так:

Зависимость знатока.

<проект>
...
 <зависимости>
  <зависимость>
   <groupId> org.neo4j </groupId>
   <artifactId> neo4j-ядро </artifactId>
   <версия> 2.0.0 </версия>
   <тип> тестовый толчок </тип>
   <контекст> тест </контекст>
  </зависимость>
  <зависимость>
   <groupId> junit </groupId>
   <artifactId> junit-отправление </artifactId>
   <версия> 4.11 </версия>
   <контекст> тест </контекст>
  </зависимость>
  <зависимость>
   <groupId> org.hamcrest </groupId>
   <artifactId> hamcrest-весь </artifactId>
   <версия> 1.3 </версия>
   <контекст> тест </контекст>
  </зависимость>
  ...
 </зависимости>
...
</проект>

Заметьте, что <тип> тестовый толчок </тип> крайне важен. Без этого Вы добрались бы
общий толчок neo4j-ядра, не тот, содержащий средства тестирования.

С этим на месте, мы готовы кодировать наши тесты.

Подсказка

Поскольку полный исходный код этого примера видит: Neo4jBasicDocTest.java <https://
github.com/neo4j/neo4j/blob/2.0.0/community/embedded-examples/src/test/java/org
/neo4j/examples/Neo4jBasicDocTest.java>

Перед каждым тестом, создайте новую базу данных:

@Before
общественность освобождает prepareTestDatabase ()
{
    graphDb = новый TestGraphDatabaseFactory ().newImpermanentDatabase ();
}

После того, как тест выполнился, база данных должна быть выключением:

@After
общественность освобождает destroyTestDatabase ()
{
    graphDb.shutdown ();
}

Во время теста, создайте вершины и проверку, чтобы видеть, что они там, в то время как
включение операций записи в транзакции.

Вершина n = нуль;
попробуйте (Транзакция tx = graphDb.beginTx ())
{
    n = graphDb.createNode ();
    n.setProperty ("имя", "Нэнси");
    tx.success ();
}

//У вершины должен быть допустимый идентификатор
assertThat (n.getId (), (greaterThan (-1l)));

//Получите вершину при использовании идентификатора создаваемой вершины. Идентификатор и
//свойство должно соответствовать.
попробуйте (Транзакция tx = graphDb.beginTx ())
{
    Вершина foundNode = graphDb.getNodeById (n.getId);
    assertThat (foundNode.getId (), (n.getId));
    assertThat ((Строка) foundNode.getProperty ("имя"), ("Нэнси"));
}

Если Вы хотите установить параметры конфигурации при создании базы данных, это сделано
как это:

Карта <Строка, Строка> конфигурация = новый HashMap <Строка, Строка> ();
config.put ("neostore.nodestore.db.mapped_memory", "10M");
config.put ("string_block_size", "60");
config.put ("array_block_size", "300");
Дб GraphDatabaseService = новый TestGraphDatabaseFactory ()
    .newImpermanentDatabaseBuilder ()
    .setConfig (конфигурация)
    .newGraphDatabase ();

32.7. Обход

32.7.1. Матрица
32.7.2. Уникальность Путей в обходах
32.7.3. Социальная сеть

Для того, чтобы читать об обходах, см. Главу 33, Платформу Обхода.

Для большего количества примеров обходов, см. Главу 5, Примеры Моделирования данных.

32.7.1. Матрица

Это - первый график, в который мы хотим пересечь:

Рисунок 32.2. Матричное представление пространства вершины

примеры-matrix.png


Подсказка

Исходный код этого примера найден здесь: NewMatrix.java <https://
github.com/neo4j/neo4j/blob/2.0.0/community/embedded-examples/src/main/java/org
/neo4j/examples/NewMatrix.java>

Друзья и друзья друзей.

частная статическая Траверса getFriends (
        конечный человек Вершины)
{
    TraversalDescription td = Traversal.description ()
            .breadthFirst ()
            .relationships (RelTypes. ЗНАЕТ, Направление. ВЫХОД)
            .evaluator (Evaluators.excludeStartPosition);
    возвратите td.traverse (человек);
}

Пустите нам выполнять фактический обход и печатать результаты:

интервал numberOfFriends = 0;
Строковый вывод = neoNode.getProperty ("имя") + "'s friends:\n";
Траверса friendsTraverser = getFriends (neoNode);
для (Путь friendPath: friendsTraverser)
{
    вывод + = "В глубине" + friendPath.length () + "=>"
              + friendPath.endNode ()
                      .getProperty ("имя") + "\n";
    numberOfFriends ++;
}
вывод + = "Номер друзей нашел: "+ numberOfFriends +" \n";

Который даст нам следующий вывод:

Друзья Томаса Андерсона:
В глубине 1 => Троица
В глубине 1 => Морфей
В глубине 2 => Код
В глубине 3 => Агент Смит
Номер друзей нашел: 4

Кто кодировал Матрицу?

частная статическая Траверса findHackers (конечная Вершина startNode)
{
    TraversalDescription td = Traversal.description ()
            .breadthFirst ()
            .relationships (RelTypes. CODED_BY, Направление. ВЫХОД)
            .relationships (RelTypes. ЗНАЕТ, Направление. ВЫХОД)
            .evaluator (
                    Evaluators.includeWhereLastRelationshipTypeIs (RelTypes. CODED_BY));
    возвратите td.traverse (startNode);
}

Распечатайте результат:

Строковый вывод = "Hackers:\n";
интервал numberOfHackers = 0;
Траверса траверсы = findHackers (getNeoNode);
для (Путь hackerPath: траверса)
{
    вывод + = "В глубине" + hackerPath.length () + "=>"
              + hackerPath.endNode ()
                      .getProperty ("имя") + "\n";
    numberOfHackers ++;
}
вывод + = "Номер хакеров нашел: "+ numberOfHackers +" \n";

Теперь мы знаем, кто кодировал Матрицу:

Хакеры:
В глубине 4 => Архитектор
Номер хакеров нашел: 1

32.7.1.1. Обход упорядоченного пути

Этот пример показывает, как использовать контекст пути, содержащий представление a
путь.

Подсказка

Исходный код этого примера найден здесь: OrderedPath.java <https://
github.com/neo4j/neo4j/blob/2.0.0/community/embedded-examples/src/main/java/org
/neo4j/examples/orderedpath/OrderedPath.java>

Создайте игрушечный график.

Вершина = db.createNode ();
Вершина B = db.createNode ();
Вершина C = db.createNode ();
Вершина D = db.createNode ();

A.createRelationshipTo (C, REL2);
C.createRelationshipTo (D, REL3);
A.createRelationshipTo (B, REL1);
B.createRelationshipTo (C, REL2);

example-ordered-path.svg

Теперь, порядок отношений (REL1 → REL2 → REL3) сохранен в ArrayList.
На обход Средство анализа может проверить по этому, чтобы гарантировать этому только пути
включены и возвратился, у которых есть предопределенный порядок отношений:

Определите, как обойти путь.

конечный ArrayList <RelationshipType> orderedPathContext = новый ArrayList <RelationshipType> ();
orderedPathContext.add (REL1);
orderedPathContext.add (withName ("REL2"));
orderedPathContext.add (withName ("REL3"));
TraversalDescription td = Traversal.description ()
        .evaluator (новое Средство анализа ()
        {
            @Override
            общедоступная Оценка находит значение величины (конечный путь Пути)
            {
                если (path.length () == 0)
                {
                    возвратите Оценку. EXCLUDE_AND_CONTINUE;
                }
                RelationshipType expectedType = orderedPathContext.get (path.length () - 1);
                булев isExpectedType = path.lastRelationship ()
                        .isType (expectedType);
                булев включенный = path.length () == orderedPathContext.size () && isExpectedType;
                булев продолжаемый = path.length () <orderedPathContext.size () && isExpectedType;
                возвратите Evaluation.of (включенный, продолжаемый);
            }
        } )
        .uniqueness (Уникальность. NODE_PATH);

Заметьте, что мы устанавливаем уникальность в Уникальность. NODE_PATH <http://
components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/kernel/Uniqueness.html#
NODE_PATH>, поскольку мы хотим быть в состоянии повторно посетить ту же самую вершину dureing
обход, но не тот же самый путь.

Выполните обход и печатайте результат.

Траверса траверсы = td.traverse (A);
PathPrinter pathPrinter = новый PathPrinter ("имя");
для (Путь пути: траверса)
{
    вывод + = Traversal.pathToString (путь, pathPrinter);
}

Который выведет:

(A) - [REL1]-> (B) - [REL2]-> (C) - [REL3]-> (D)

В этом случае мы используем пользовательский класс, чтобы отформатировать вывод пути. Это - то, как это
договорились:

статический класс PathPrinter реализует Обход. PathDescriptor <Путь>
{
    частная конечная Строка nodePropertyKey;

    общедоступный PathPrinter (Представляют nodePropertyKey в виде строки),
    {
        this.nodePropertyKey = nodePropertyKey;
    }

    @Override
    общедоступная Строка nodeRepresentation (Путь пути, вершина Вершины)
    {
        возвратитесь" (" + node.getProperty (nodePropertyKey, "") +")";
    }

    @Override
    общедоступная Строка relationshipRepresentation (Путь пути, Вершина от, отношение Отношения)
    {
        Строковый префикс = "-", снабдите суффиксом = "-";
        если (from.equals (relationship.getEndNode))
        {
            снабдите префиксом =" <-";
        }
        еще
        {
            снабдите суффиксом = "->";
        }
        возвратите префикс +" [" + relationship.getType ().name () +"]" + суффикс;
    }
}

Для опций относительно вывода Пути, см. Обход <http://
components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/kernel/Traversal.html>
класс.

32.7.2. Уникальность Путей в обходах

Этот пример демонстрирует использование уникальности вершины. Ниже комплексного числа
график домена с Принципалами, которым принадлежат домашние животные, которые являются потомком другим домашним животным.

Рисунок 32.3. График потомков В качестве примера

Descendants-Example-Graph-Uniqueness-of-Paths-in-traversals.svg


Чтобы возвратить всех потомков Pet0, у которых есть соотношение, имеет к
Principal1 (Pet1 и Pet3), Уникальность обхода должна быть установлена в
NODE_PATH, а не значение по умолчанию NODE_GLOBAL так, чтобы вершины могли быть пересечены
больше это однажды, и пути, которые имеют различные вершины, но могут иметь некоторые вершины в
распространенный (как запуск и конечный узел) может быть возвращен.

конечная цель Вершины = data.get ().get ("Principal1");
TraversalDescription td = Traversal.description ()
        .uniqueness (Уникальность. NODE_PATH)
        .evaluator (новое Средство анализа ()
{
    @Override
    общедоступная Оценка находит значение величины (Путь пути)
    {
        булев endNodeIsTarget = path.endNode ().equals (цель);
        возвратите Evaluation.of (endNodeIsTarget! endNodeIsTarget);
    }
} );

Результаты траверсы = td.traverse (запускаются);

Это возвратит следующие пути:

(2) - [потомку, 0]-> (0) <-[принадлежит, 3] - (4)
(2) - [потомку, 2]-> (3) <-[принадлежит, 5] - (4)

В значении по умолчанию path.toString () знает реализация, (1) - [2]-> (4) обозначает a
вершина с ID=1, имеющим отношение с ID 2 или тип, знает к вершине с
ID 4.

Пустите нам создавать новый TraversalDescription из старого, имея NODE_GLOBAL
уникальность, чтобы видеть разность.

Подсказка

Объект TraversalDescription является неизменным, таким образом, мы должны использовать новое
экземпляр возвратился с новой установкой уникальности.

TraversalDescription nodeGlobalTd = td.uniqueness (Уникальность. NODE_GLOBAL);
результаты = nodeGlobalTd.traverse (запускаются);

Теперь только один путь возвращен:

(2) - [потомку, 0]-> (0) <-[принадлежит, 3] - (4)

32.7.3. Социальная сеть

Замечание

Следующий пример использует новый улучшенный API обхода.

Социальные сети (знают как социальные графики в сети) являются естественными для модели
с графиком. Этот пример показывает очень простую социальную модель, которая соединяется
друзья и отслеживают корректировки данных.

Подсказка

Исходный код примера найден здесь: socnet <https://github.com/neo4j/
neo4j/tree/2.0.0/community/embedded-examples/src/main/java/org/neo4j/examples/
socnet>

32.7.3.1. Простая социальная модель

Рисунок 32.4. Модель данных социальной сети

socnet-model.png


Модель данных для социальной сети довольно проста: Люди с именами и
StatusUpdates с текстом с меткой времени. Эти объекты тогда соединены
определенные отношения.

  * Человек

      o друг: связывает два явных экземпляра Человека (никакая самоссылка)
      o состояние: соединяется с новым StatusUpdate
  * StatusUpdate

      o затем: точки к следующему StatusUpdate в цепочке, которая была отправлена
        перед текущим

32.7.3.2. Экземпляр графика состояния

Список StatusUpdate для Человека - связанный список. Голова списка (
новое состояние), найден следующим состоянием. Каждый последовательный StatusUpdate
соединен затем.

Вот пример, где Андреас Коллеггер микрозаносил свой способ в блог вставить
утро:

andreas-status-updates.svg

Чтобы считать корректировки данных, мы можем создать обход, как так:

Обход TraversalDescription = Traversal.description ().
        в глубину ().
        отношения (NEXT);

Это дает нам траверсу, которая запустится в одном StatusUpdate, и будет следовать
цепочка обновлений, пока они не заканчиваются. Траверсы - ленивая загрузка, таким образом, это
производительный, имея дело с тысячами состояний  -  они не загружены
пока мы фактически не используем их.

32.7.3.3. Поток действия

Как только у нас есть друзья, и у них есть сообщения о состоянии, мы могли бы хотеть считать наш
друзья сообщения состояния, в обратное время упорядочивают  -  самый последний сначала. Сделать это, нас
пройдите через эти шаги:

 1. Соберите корректировку данных всего друга iterators в списке  -  самая последняя дата сначала.
 2. Сортируйте список.
 3. Возвратите первый элемент в списке.
 4. Если первый iterator исчерпан, переместите его от списка. Иначе, добраться
    следующий элемент в этом iterator.
 5. Пойдите в шаг 2, пока нет никаких iterators, левой стороны в списке.

Анимированный, последовательность похожа на это <http://www.slideshare.net/systay/
поток действия модели>.

Код похож:

PositionedIterator <StatusUpdate> сначала = statuses.get (0);
StatusUpdate returnVal = first.current ();

если (! first.hasNext ())
{
    statuses.remove (0);
}
еще
{
    first.next ();
    вид ();
}

возвратите returnVal;

32.8. Объекты домена

Эта страница демонстрирует один способ обработать объекты домена при использовании Neo4j.
правило при использовании должно обернуть объекты вокруг вершины (тот же самый подход может
используйтесь с отношениями также).

Подсказка

Исходный код примеров найден здесь: Person.java <https://github.com/
neo4j/neo4j/blob/2.0.0/community/embedded-examples/src/main/java/org/neo4j/
examples/socnet/Person.java>

Прежде всего, сохраните вершину и сделайте ее доступной в пакете:

частная конечная Вершина underlyingNode;

Человек (Вершина personNode)
{
    this.underlyingNode = personNode;
}

предохраненная Вершина getUnderlyingNode ()
{
    возвратите underlyingNode;
}


Делегат приписывает вершине:

общедоступная Строка getName ()
{
    возвратитесь (Строка) underlyingNode.getProperty (ИМЯ);
}


Удостоверьтесь, что переопределили эти методы:

@Override
общедоступный интервал hashCode ()
{
    возвратите underlyingNode.hashCode ();
}

@Override
булева общественность приравнивает (Возразите o),
{
    возвратите o instanceof Человек &&
            underlyingNode.equals (((Человек) o).getUnderlyingNode ());
}

@Override
общедоступная Строка toString ()
{
    возвратите "Человека [" + getName () +"]";
}


32.9. Примеры Алгоритма графика

Подсказка

Исходный код, используемый в примере, найден здесь: PathFindingDocTest.java
<https://github.com/neo4j/neo4j/blob/2.0.0/community/embedded-examples/src/test
/java/org/neo4j/examples/PathFindingDocTest.java>

Вычисление кратчайшего пути (наименьшее количество номера отношений) между два
вершины:

Вершина startNode = graphDb.createNode ();
Вершина middleNode1 = graphDb.createNode ();
Вершина middleNode2 = graphDb.createNode ();
Вершина middleNode3 = graphDb.createNode ();
Вершина endNode = graphDb.createNode ();
createRelationshipsBetween (startNode, middleNode1, endNode);
createRelationshipsBetween (startNode, middleNode2, middleNode3, endNode);

//Обнаружит кратчайший путь между startNode и endNode через
//Отношения "MY_TYPE" (в ИСХОДЯЩЕМ направлении), как f.ex:
//
//(startNode)-> (middleNode1)-> (endNode)
//
PathFinder <Путь> средство обнаружения = GraphAlgoFactory.shortestPath (
        Traversal.expanderForTypes (ExampleTypes. MY_TYPE, Направление. ВЫХОД), 15);
Повторяемый <Путь> пути = finder.findAllPaths (startNode, endNode);

Используя алгоритм Диджкстры <http://en.wikipedia.org/wiki/
Dijkstra%27s_algorithm>, чтобы вычислить самый дешевый путь между вершиной A и B, где
каждое отношение может иметь вес (то есть стоить), и путь (и) с наименее стоимостью
найдены.

PathFinder <WeightedPath> средство обнаружения = GraphAlgoFactory.dijkstra (
        Traversal.expanderForTypes (ExampleTypes. MY_TYPE, Направление. ОБА), "стоимость");

Путь WeightedPath = finder.findSinglePath (nodeA, nodeB);

//Получите вес для найденного пути
path.weight ();

Используя A* <http://en.wikipedia.org/wiki/A*_search_algorithm>, чтобы вычислить
самый дешевый путь между вершиной A и B, где самый дешевый например путь в a
сеть путей, у которой есть самое короткое между вершиной A и B. Вот наш
график в качестве примера:

График алгоритма A* в качестве примера

Вершина nodeA = createNode ("имя", "A", "x", 0d, "y", 0d);
Вершина nodeB = createNode ("имя", "B", "x", 7d, "y", 0d);
Вершина nodeC = createNode ("имя", "C", "x", 2-ой, "y", 1d);
Перелаборатория отношения = createRelationship (nodeA, nodeC, "длина", 2-ая);
Отношение relBC = createRelationship (nodeC, nodeB, "длина", 3-ья);
Перекрасная смола отношения = createRelationship (nodeA, nodeB, "длина", 10d);

EstimateEvaluator <Двойное количество> estimateEvaluator = новый EstimateEvaluator <Двойное количество> ()
{
    @Override
    общедоступное Двойное количество getCost (конечная вершина Вершины, конечная цель Вершины)
    {
        удвойте дуплекс = (Двойное количество) node.getProperty ("x") - (Двойное количество) goal.getProperty ("x");
        удвойте dy = (Двойное количество) node.getProperty ("y") - (Двойное количество) goal.getProperty ("y");
        удвойте результат = Math.sqrt (Math.pow (дуплекс, 2) + Math.pow (dy, 2));
        возвратите результат;
    }
};
PathFinder <WeightedPath> astar = GraphAlgoFactory.aStar (
        Traversal.expanderForAllTypes (),
        CommonEvaluators.doubleCostEvaluator ("длина"), estimateEvaluator);
Путь WeightedPath = astar.findSinglePath (nodeA, nodeB);

32.10. Чтение атрибута управления

JmxUtils <http://components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/jmx/
JmxUtils.html> класс включает методы в доступ бобы управления Neo4j.
общая служба JMX может использоваться также, но от Вашего кода Вы, вероятно, скорее
хочу использовать подход, выделенный здесь.

Подсказка

Исходный код примера найден здесь: JmxDocTest.java <https://
github.com/neo4j/neo4j/blob/2.0.0/community/embedded-examples/src/test/java/org
/neo4j/examples/JmxDocTest.java>

Этот пример показывает, как получить время запуска базы данных:

частная статическая Дата getStartTimeFromManagementBean (
        GraphDatabaseService graphDbService)
{
    GraphDatabaseAPI graphDb = (GraphDatabaseAPI) graphDbService;
    Имя объекта ObjectName = JmxUtils.getObjectName (graphDb, "Ядро");
    Дата даты = JmxUtils.getAttribute (имя объекта, "KernelStartTime");
    возвратите дату;
}

В зависимости от которого выпуска Neo4j Вы используете различные наборы управления
бобы доступны.

  * Для всех выпусков, см. org.neo4j.jmx <http://компоненты neo4j.org/
    neo4j-jmx/2.0.0/apidocs/org/neo4j/jmx/package-summary.html> пакет.
  * Для Версии для предприятий, см. org.neo4j.management <http://
    components.neo4j.org/neo4j-management/2.0.0/apidocs/org/neo4j/management/
    пакет-summary.html> пакет также.

32.11. Как создать уникальные вершины

32.11.1. Получите или создайте уникальную вершину, используя Код и уникальные ограничения
32.11.2. Получите или создайте уникальную вершину, используя наследство, индексируют
32.11.3. Пессимистическая блокировка для создания вершины

Этот раздел о том, как гарантировать уникальность свойства, создавая
вершины. Для краткого обзора темы, см. Раздел 16.6, “Создавая уникальные вершины”.

32.11.1. Получите или создайте уникальную вершину, используя Код и уникальные ограничения

Создайте механизм выполнения Кода и уникальное ограничение.

попробуйте (Транзакция tx = graphdb.beginTx ())
{
    graphdb.schema ()
            .constraintFor (DynamicLabel.label ("Пользователь"))
            .assertPropertyIsUnique ("имя")
            .create ();
    tx.success ();
}

возвратите новый ExecutionEngine (graphdb);

Используйте СЛИЯНИЕ, чтобы создать уникальную вершину.

Результат вершины = нуль;
ResourceIterator <Вершина> resultIterator = нуль;
попробуйте (Транзакция tx = graphDb.beginTx ())
{
    Представьте queryString в виде строки = "СЛИЯНИЕ (n:User {имя: {имя}}), ВОЗВРАЩАЮТ n";
    Карта <Строка, Объект> параметры = новый HashMap <> ();
    parameters.put ("имя", имя пользователя);
    resultIterator = engine.execute (queryString, параметры).columnAs ("n");
    следуйте = resultIterator.next ();
    tx.success ();
    возвратите результат;
}

32.11.2. Получите или создайте уникальную вершину, используя наследство, индексируют

Важный

В то время как это - рабочее решение, пожалуйста, рассмотрите использование привилегированного
Раздел 32.11.1, “Получают или создают уникальную вершину, используя Код и уникальный
ограничения” вместо этого.

При использовании "помещенного, если отсутствующий" <http://components.neo4j.org/neo4j/2.0.0/apidocs/org/
neo4j/graphdb/index/Index.html#
putIfAbsent%28T,%20java.lang.String,%20java.lang.Object%29> функциональность,
уникальность объекта может быть гарантирована, используя индексирование.

Здесь индексировать действия как блокировка и только заблокируют самую малую часть, необходимую к
уникальность гарантии через потоки и транзакции. Добраться больше
высокоуровневая функциональность получать-или-создавать использует UniqueFactory <http://
components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/graphdb/index/
UniqueFactory.html> как замечено в примере ниже.

Создайте фабрику для уникальных вершин в приложении, запускаются.

попробуйте (Транзакция tx = graphDb.beginTx ())
{
    UniqueFactory. UniqueNodeFactory следуют = новый UniqueFactory. UniqueNodeFactory (graphDb, "пользователи")
    {
        @Override
        предохраненный пусто инициализируют (Создаваемая вершина, Карта <Строка, Объект> свойства)
        {
            created.addLabel (DynamicLabel.label ("Пользователь"));
            created.setProperty ("имя", properties.get ("имя"));
        }
    };
    tx.success ();
    возвратите результат;
}

Используйте уникальную фабрику вершины, чтобы получить или создать вершину.

попробуйте (Транзакция tx = graphDb.beginTx ())
{
    Вершина вершины = factory.getOrCreate ("имя", имя пользователя);
    tx.success ();
    возвратите вершину;
}

32.11.3. Пессимистическая блокировка для создания вершины

Важный

В то время как это - рабочее решение, пожалуйста, рассмотрите использование привилегированного
Раздел 32.11.1, “Получают или создают уникальную вершину, используя Код и уникальный
ограничения” вместо этого.

Можно было бы испытать желание использовать синхронизацию Java для пессимистической блокировки, но
это опасно. Смешиванием привязывает Neo4j и в Среде выполнения Java, это легко
произвести тупики, которые не обнаруживаемы Neo4j. Пока вся блокировка
сделан Neo4j, все тупики будут обнаружены и избегутся. Кроме того, решение
использование физической синхронизации не гарантирует уникальность в среде HA.

Этот пример использует единственную “вершину блокировки” для того, чтобы заблокировать. Мы создаем это только как a
разместите, чтобы поместить блокировки, ничто иное.

Создайте вершину блокировки в приложении, запускаются.

попробуйте (Транзакция tx = graphDb.beginTx ())
{
    конечная Вершина lockNode = graphDb.createNode ();
    tx.success ();
    возвратите lockNode;
}

Используйте вершину блокировки, чтобы гарантировать, что вершины не создаются одновременно.

попробуйте (Транзакция tx = graphDb.beginTx ())
{
    Индексируйте <Вершина> usersIndex = graphDb.index ().forNodes ("пользователи");
    Вершина userNode = usersIndex.get ("имя", имя пользователя).getSingle ();
    если (userNode! = нуль)
    {
        возвратите userNode;
    }

    tx.acquireWriteLock (lockNode);
    userNode = usersIndex.get ("имя", имя пользователя).getSingle ();
    если (userNode == нуль)
    {
        userNode = graphDb.createNode (DynamicLabel.label ("Пользователь"));
        usersIndex.add (userNode, "имя", имя пользователя);
        userNode.setProperty ("имя", имя пользователя);
    }
    tx.success ();
    возвратите userNode;
}

Заметьте, что окончательная отделка транзакции выпустит блокировку на вершине блокировки.

32.12. Выполните Запросы Кода от Java

Подсказка

Полный исходный код примера: JavaQuery.java <https://github.com/neo4j/
neo4j/blob/2.0.0/community/cypher/cypher-docs/src/test/java/org/neo4j/cypher/
javacompat/JavaQuery.java>

В Java Вы можете использовать язык запроса Кода согласно примеру ниже. Во-первых,
пустите нам прибавлять некоторые данные.

Дб GraphDatabaseService = новый GraphDatabaseFactory ().newEmbeddedDatabase (DB_PATH);

попробуйте (Транзакция tx = db.beginTx ();)
{
    Вершина myNode = db.createNode ();
    myNode.setProperty ("имя", "моя вершина");
    tx.success ();
}

Выполните запрос:

Механизм ExecutionEngine = новый ExecutionEngine (дб);

Результат ExecutionResult;
попробуйте (Транзакция, игнорируемая = db.beginTx ())
{
    следуйте = engine.execute ("запускают n=node (*), куда n.name = 'моя вершина' возвращают n, n.name");

Замечание

Имейте в наличии ExecutionEngine, не создавайте новый для каждого запроса!

Результат будет:

+-------------------------------------+
| n | n.name |
+-------------------------------------+
| Вершина [0] {имя: "моя вершина"} | "моя вершина" |
+-------------------------------------+
1 строка

Предостережение

Классы, используемые здесь, от org.neo4j.cypher.javacompat пакета, нет
org.neo4j.cypher, см. ссылку к API Java ниже.

Вы можете получить список столбцов в результате:

Список <Строка> столбцы = result.columns ();

Это делится без остатка:

[n, n.name]

Чтобы выбрать элементы результата от единственного столбца, действительно любите это:

Iterator <Вершина> n_column = result.columnAs ("n");
для (Вершина вершины: IteratorUtil.asIterable (n_column))
{
    //замечание: мы захватываем свойство имени от вершины,
    //не от n.name в этом случае.
    nodeResult = вершина + ":" + node.getProperty ("имя");
}

В этом случае в результате есть только одна вершина:

Вершина [0]: моя вершина

Чтобы получить все столбцы, действительно любите это вместо этого:

для (Карта <Строка, Объект> строка: результат)
{
    для (Запись <Строка, Объект> столбец: row.entrySet ())
    {
        строки + = column.getKey () + ": "+ column.getValue () +";";
    }
    строки + = "\n";
}

Это выводит:

n.name: моя вершина; n: Вершина [0];

Предостережение

на dumpToString (), columnAs () и iterator () нельзя вызвать не раз
тот же самый объект ExecutionResult. Вы должны вместо этого использовать только один и если Вы
нуждаюсь в средствах других методов на том же самом результате запроса вместо этого
создайте новый ExecutionResult.

Предостережение

При использовании ExecutionResult Вы должны будете исчерпать это при использовании любого из
итерация методов (columnAs () и iterator ()) на этом. Сбой сделать так не будет
должным образом очистите ресурсы, используемые ExecutionResult, приводя нежелательному
поведение, такое как протекающие транзакции.

Для получения дополнительной информации по интерфейсу Java, чтобы Кодировать, см. API Java <http://
components.neo4j.org/neo4j-cypher/2.0.0/apidocs/index.html>.

Для получения дополнительной информации и примеры для Кода, см. Часть III, “Запрос Кода
Язык” и Глава 5, Примеры Моделирования данных.

32.13. Параметры запроса

Для получения дополнительной информации по параметрам см. Раздел 7.5, "Параметры".

Ниже следует примеру того, как использовать параметры, выполняя запросы Кода
от Java.

Идентификатор вершины.

Карта <Строка, Объект> params = новый HashMap <Строка, Объект> ();
params.put ("идентификатор", 0);
Строковый запрос = "ЗАПУСКАЕТ n=node ({идентификатор}) ВОЗВРАТ n.name";
ExecutionResult следуют = engine.execute (запрос, params);

Объект вершины.

Карта <Строка, Объект> params = новый HashMap <Строка, Объект> ();
params.put ("вершина", andreasNode);
Строковый запрос = "ЗАПУСКАЕТ n=node ({вершина}) ВОЗВРАТ n.name";
ExecutionResult следуют = engine.execute (запрос, params);

Разнообразные идентификаторы вершины.

Карта <Строка, Объект> params = новый HashMap <Строка, Объект> ();
params.put ("идентификатор", Arrays.asList (0, 1, 2));
Строковый запрос = "ЗАПУСКАЕТ n=node ({идентификатор}) ВОЗВРАТ n.name";
ExecutionResult следуют = engine.execute (запрос, params);

Строковый литерал.

Карта <Строка, Объект> params = новый HashMap <Строка, Объект> ();
params.put ("имя", "Йохан");
Строковый запрос = "СООТВЕТСТВИЕ (n), ГДЕ n.name = {имя} ВОЗВРАТ n";
ExecutionResult следуют = engine.execute (запрос, params);

Индексируйте значение.

Карта <Строка, Объект> params = новый HashMap <Строка, Объект> ();
params.put ("значение", "Микаэла");
Строковый запрос = "ЗАПУСКАЕТ n=node:people (имя = {значение}) ВОЗВРАЩАЮТ n";
ExecutionResult следуют = engine.execute (запрос, params);

Индексируйте запрос.

Карта <Строка, Объект> params = новый HashMap <Строка, Объект> ();
params.put ("запрос", "name:Andreas");
Строковый запрос = "ЗАПУСКАЕТ n=node:people ({запрос}) ВОЗВРАТ n";
ExecutionResult следуют = engine.execute (запрос, params);

Числовые параметры для ПРОПУСКА и ПРЕДЕЛА.

Карта <Строка, Объект> params = новый HashMap <Строка, Объект> ();
params.put ("s", 1);
params.put ("l", 1);
Строковый запрос = "СООТВЕТСТВИЕ (n) ВОЗВРАЩАЕТ ПРОПУСК n.name {s} ПРЕДЕЛ {l}";
ExecutionResult следуют = engine.execute (запрос, params);

Регулярное выражение.

Карта <Строка, Объект> params = новый HashMap <Строка, Объект> ();
params.put ("regex", ".*h. *");
Строковый запрос = "СООТВЕТСТВИЕ (n), КУДА n.name = ~ {regex} ВОЗВРАЩАЮТ n.name";
ExecutionResult следуют = engine.execute (запрос, params);

Создайте вершину со свойствами.

Карта <Строка, Объект> поддерживает = новый HashMap <Строка, Объект> ();
props.put ("имя", "Андрес");
props.put ("позиция", "Разработчик");

Карта <Строка, Объект> params = новый HashMap <Строка, Объект> ();
params.put ("опоры", опоры);
Строковый запрос = "СОЗДАЕТ ({поддерживает})";
engine.execute (запрос, params);

Создайте разнообразные вершины со свойствами.

Карта <Строка, Объект> n1 = новый HashMap <Строка, Объект> ();
n1.put ("имя", "Андрес");
n1.put ("позиция", "Разработчик");
n1.put ("удивительный", истинный);

Карта <Строка, Объект> n2 = новый HashMap <Строка, Объект> ();
n2.put ("имя", "Майкл");
n2.put ("позиция", "Разработчик");
n2.put ("дочерние элементы", 3);

Карта <Строка, Объект> params = новый HashMap <Строка, Объект> ();
Список <Карта <Строка, Объект>> отображается = Arrays.asList (n1, n2);
params.put ("опоры", карты);
Строковый запрос = "СОЗДАЕТ (n:Person {опоры}) ВОЗВРАЩАЮТ n";
engine.execute (запрос, params);

Установка всех свойств на вершине.

Карта <Строка, Объект> n1 = новый HashMap <> ();
n1.put ("имя", "Андрес");
n1.put ("позиция", "Разработчик");

Карта <Строка, Объект> params = новый HashMap <> ();
params.put ("опоры", n1);

Строковый запрос = "СООТВЕТСТВИЕ (n), ГДЕ n.name =' Микаэла' УСТАНАВЛИВАЮТ n = {опоры}";
engine.execute (запрос, params);

Глава 33. Платформа Обхода

API Обхода Neo4j <http://components.neo4j.org/neo4j/2.0.0/apidocs/org/
neo4j/graphdb/traversal/package-summary.html> базируемый обратный вызов, лениво
выполняемый способ определить требовал перемещений через график в Java. Некоторые
примеры обхода собраны под Разделом 32.7, "Обходом".

Вы можете также использовать Язык Запроса Кода в качестве мощного декларативного пути к
запросите график.

33.1. Основные понятия

Здесь следует за коротким объяснением всех различных методов, которые могут модифицировать или
добавьтесь к описанию обхода.

  * Расширители  -  определяют, что пересечь, обычно с точки зрения отношения
    направление и тип.
  * Порядок  -  например в глубину или в ширину.
  * Уникальность  -  посещают вершины (отношения, пути) только однажды.
  * Средство анализа  -  решает, что возвратиться и остановить ли или продолжать обход
    вне текущей позиции.
  * Запускающиеся вершины, где обход начнется.

graphdb-traversal-description.svg

См. Раздел 33.2, “API Java Платформы Обхода” для большего количества деталей.

33.2. API Java Платформы обхода

33.2.1. TraversalDescription
33.2.2. Средство анализа
33.2.3. Траверса
33.2.4. Уникальность
33.2.5. Упорядочьте  - , Как переместиться посредством ответвлений?
33.2.6. BranchSelector
33.2.7. Путь
33.2.8. PathExpander/RelationshipExpander
33.2.9. Расширитель
33.2.10. Как использовать платформу Обхода

Составы платформы обхода нескольких основных интерфейсов в дополнение к Вершине
и Отношение: TraversalDescription, Средство анализа, Траверса и Уникальность
основные. У интерфейса Пути также есть особое назначение в обходах,
так как это используется, чтобы представить позицию в графике, оценивая это
позиция. Кроме того PathExpander (заменяющий RelationshipExpander) и
Интерфейсы расширителя являются центральными к обходам, но пользователи API редко нуждаются
реализовывать их. Есть также ряд интерфейсов для усовершенствованного использования, когда
явное управление порядком обхода требуется: BranchSelector,
BranchOrderingPolicy и TraversalBranch.

33.2.1. TraversalDescription

TraversalDescription <http://components.neo4j.org/neo4j/2.0.0/apidocs/org/
neo4j/graphdb/traversal/TraversalDescription.html> основной используемый интерфейс
для определения и инициализации обходов. Это не предназначено, чтобы быть реализованным
пользователи платформы обхода, а скорее быть обеспеченным
реализация платформы обхода как способ для пользователя описать
обходы. Экземпляры TraversalDescription являются неизменными и его методы
возвращает новый TraversalDescription, который модифицируется по сравнению с объектом
метод был вызван на с параметрами метода.

33.2.1.1. Отношения

Прибавляет тип отношения к списку типов отношения, чтобы пересечь.
значение по умолчанию, что список пуст и это означает, что это пересечет все отношения
, независимо от тип. Если одно или более отношений прибавлены к этому списку
только прибавленные типы будут пересечены. Есть два метода, один включая
направление <http://components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/graphdb/
traversal/TraversalDescription.html#relationships> и другой, исключая
направление <http://components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/graphdb/
traversal/TraversalDescription.html#relationships>, где последний пересекает
отношения в обоих направлениях <http://components.neo4j.org/neo4j/2.0.0/
apidocs/org/neo4j/graphdb/Direction.html#BOTH>.

33.2.2. Средство анализа

Средство анализа <http://components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/graphdb/
traversal/Evaluator.html> s используются для того, чтобы решить, в каждой позиции (представленный
как Путь): если обход продолжается, и/или если вершина включена
в результате. Учитывая Путь, это просит одно из четырех действий для того ответвления
обход:

  * Оценка. INCLUDE_AND_CONTINUE: Включайте эту вершину в результат и
    продолжайте обход
  * Оценка. INCLUDE_AND_PRUNE: Включайте эту вершину в результат, но не делайте
    продолжайте обход
  * Оценка. EXCLUDE_AND_CONTINUE: Исключите эту вершину из результата, но
    продолжайте обход
  * Оценка. EXCLUDE_AND_PRUNE: Исключите эту вершину из результата и не делайте
    продолжайте обход

Больше чем одно средство анализа может быть прибавлено. Заметьте, что средства анализа будут требоваться
все позиции траверса встречаются, даже для вершины запуска.

33.2.3. Траверса

Траверса <http://components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/
graphdb/traversal/Traverser.html> объект является результатом вызова траверза ()
<http://components.neo4j.org/neo4j-kernel/2.0.0/apidocs/org/neo4j/graphdb/
traversal/TraversalDescription.html#traverse (org.neo4j.graphdb. Вершина)> a
Объект TraversalDescription. Это представляет обход, расположенный в график,
и спецификация формата результата. Фактический обход
выполняемый лениво каждый раз следующее () - метод iterator Траверсы
вызван.

33.2.4. Уникальность

Устанавливает правила для того, как позиции можно повторно посетить во время обхода как утверждено
в Уникальности <http://components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/kernel
/Uniqueness.html>. Значение по умолчанию, если не набор - NODE_GLOBAL <http://
components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/kernel/Uniqueness.html#
NODE_GLOBAL>.

Уникальность может быть предоставлена TraversalDescription, чтобы продиктовать под какой
обстоятельства обход могут повторно посетить ту же самую позицию в графике.
различные уровни уникальности, которые могут использоваться в Neo4j:

  * НИ ОДИН: Любую позицию в графике можно повторно посетить.
  * уникальность NODE_GLOBAL: Никакую вершину во всем графике нельзя посетить больше
    чем однажды. Это могло потенциально использовать много памяти, так как она требует
    хранение структуры данных в памяти, помня все посещаемые вершины.
  * уникальность RELATIONSHIP_GLOBAL: никакое отношение во всем графике не может быть
    посещаемый не раз. По тем же самым причинам как уникальность NODE_GLOBAL,
    это могло израсходовать много памяти. Но так как у графиков обычно есть большее
    номер отношений чем вершины, издержки памяти этой уникальности
    уровень мог стать еще более быстрым.
  * уникальность NODE_PATH: вершина, возможно, не происходит ранее в достижении пути
    до этого.
  * уникальность RELATIONSHIP_PATH: отношение, возможно, не происходит ранее в
    путь, достигающий до этого.
  * уникальность NODE_RECENT: Подобный уникальности NODE_GLOBAL, в которой есть
    глобальный набор посещаемых вершин каждая позиция проверен по. Это
    у уровня уникальности действительно однако есть прописная буква на том, сколько памяти он может использовать
    в форме набора, который только делится без остатка последний раз посещаемый
    вершины. Размер этого набора может быть определен, обеспечивая номер
    как второй параметр TraversalDescription.uniqueness () - метод
    наряду с уровнем уникальности.
  * уникальность RELATIONSHIP_RECENT: Работы как уникальность NODE_RECENT, но с
    отношения вместо вершин.

33.2.4.1. Глубина Сначала / В ширину

Они - методы удобства для того, чтобы установить предварительный порядок, в глубину <http://
en.wikipedia.org/wiki/Depth-first_search>/ в ширину <http://
en.wikipedia.org/wiki/Breadth-first_search> политики BranchSelector|ordering.
Тот же самый результат может быть достигнут, вызывая порядок <http://
components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/graphdb/traversal/
Метод TraversalDescription.html#order> с упорядочиванием политик от
Обход <http://components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/kernel/
Traversal.html#preorderDepthFirst> фабрика <http://компоненты neo4j.org/
neo4j-kernel/2.0.0/apidocs/org/neo4j/kernel/Traversal.html#
preorderBreadthFirst>, или записать Ваш собственный BranchSelector/BranchOrderingPolicy
и передача в.

33.2.5. Упорядочьте  - , Как переместиться посредством ответвлений?

Более универсальная версия методов в глубину/в ширину, в которых это позволяет
произвольный BranchOrderingPolicy <http://components.neo4j.org/neo4j/2.0.0/apidocs
/org/neo4j/graphdb/traversal/BranchOrderingPolicy.html>, чтобы быть введенным в
описание.

33.2.6. BranchSelector

BranchSelector используется для того, чтобы выбрать который ответвление обхода попытаться
затем. Это используется для того, чтобы реализовать упорядочивания обхода. Обход
платформа обеспечивает несколько основных реализаций упорядочивания:

  * Traversal.preorderDepthFirst (): Полигонометрия глубины сначала, посещая каждую вершину
    прежде, чем посетить его дочерние вершины.
  * Traversal.postorderDepthFirst (): Полигонометрия глубины сначала, посещая каждую вершину
    после посещения его дочерних вершин.
  * Traversal.preorderBreadthFirst (): Полигонометрия, в ширину, посещая каждого
    вершина прежде, чем посетить ее дочерние вершины.
  * Traversal.postorderBreadthFirst (): Полигонометрия, в ширину, посещая каждого
    вершина после посещения ее дочерних вершин.

Замечание

Пожалуйста, заметьте, что у обходов вершин в ширину есть более высокие издержки памяти чем
глубина первые обходы.

Для состояния переносов BranchSelectors и следовательно нужно уникально инстанцировать
каждый обход. Поэтому это предоставлено TraversalDescription через a
Интерфейс BranchOrderingPolicy, который является фабрикой экземпляров BranchSelector.

Пользователь платформы Обхода редко должен реализовывать свое собственное
BranchSelector или BranchOrderingPolicy, это обеспечено, чтобы пустить алгоритму графика
конструкторы обеспечивают свои собственные заказы обхода. Алгоритмы Графика Neo4j
пакет содержит например порядок BestFirst BranchSelector/
BranchOrderingPolicy, который используется в алгоритмах Поиска по первому наилучшему совпадению, таких как A* и
Dijkstra.

33.2.6.1. BranchOrderingPolicy

Фабрика для того, чтобы создать BranchSelectors, чтобы решить в том, каковы ответвления порядка
возвращенный (где позиция ответвления представлена как Путь <http://
components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/graphdb/Path.html> от
запустите вершину к текущей вершине). Общая политика в глубину <http://
components.neo4j.org/neo4j-kernel/2.0.0/apidocs/org/neo4j/graphdb/traversal/
TraversalDescription.html#depthFirst ()> и в ширину <http://
components.neo4j.org/neo4j-kernel/2.0.0/apidocs/org/neo4j/graphdb/traversal/
TraversalDescription.html#breadthFirst ()> и именно поэтому есть удобство
методы для тех. Например, вызывая TraversalDescription#depthFirst ()
<http://components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/graphdb/traversal/
TraversalDescription.html#depthFirst ()> эквивалентно:

description.order (Traversal.preorderDepthFirst);

33.2.6.2. TraversalBranch

Объект, используемый BranchSelector, чтобы получить больше ответвлений от определенного
ответвление. В основном они - составной объект Пути и RelationshipExpander
это может использоваться, чтобы получить новый TraversalBranch <http://components.neo4j.org/neo4j/
2.0.0/apidocs/org/neo4j/graphdb/traversal/TraversalBranch.html>es от
ток один.

33.2.7. Путь

Путь <http://components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/graphdb/
Path.html> является общим интерфейсом, который является частью API Neo4j. В
API обхода Neo4j использование Путей является двукратным. Траверсы могут возвратиться
их результаты в форме Путей посещаемых позиций в графике
это отмечено для того, чтобы быть возвращенным. Объекты пути также используются в
оценка позиций в графике, для того, чтобы определить, должен ли обход
продолжайте от определенного момента или нет, и должна ли определенная позиция быть
включенный в набор результатов или нет.

33.2.8. PathExpander/RelationshipExpander

Платформа обхода использует PathExpanders (заменяющий RelationshipExpander) к
обнаружьте отношения, которые должны сопровождаться от определенного пути до
дальнейшие ответвления в обходе.

33.2.9. Расширитель

Более универсальная версия отношений, где RelationshipExpander
введенный, определяя все отношения, которые будут пересечены для любой данной вершины.
значение по умолчанию (и при использовании отношений) расширитель значения по умолчанию <http://
components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/kernel/Traversal.html#
emptyExpander> используется, где любой определенный порядок отношений не
гарантируемый. Есть другая реализация, которая гарантирует этому отношения
пересечены в порядке типа отношения <http://components.neo4j.org/neo4j/
2.0.0/apidocs/org/neo4j/kernel/OrderedByTypeExpander.html>, где типы
выполненный с помощью итераций в порядке они были прибавлены.

Интерфейс Расширителя - расширение интерфейса RelationshipExpander
это позволяет создать настроенные версии Расширителя.
реализация TraversalDescription использует это, чтобы обеспечить методы для
определяя, каких типов отношения пересечь, это является обычным путем пользователь
API определил бы RelationshipExpander  - , создавая это внутренне в
TraversalDescription.

Весь RelationshipExpanders, предоставленный платформой обхода Neo4j также
реализуйте интерфейс Расширителя. Для пользователя API обхода это легче
реализовывать интерфейс PathExpander/RelationshipExpander, начиная с этого только
содержит один метод  -  метод для того, чтобы получить отношения от пути /
вершина, методы, которые прибавляет интерфейс Расширителя, только для создания нового
Расширители.

33.2.10. Как использовать платформу Обхода

Описание обхода <http://components.neo4j.org/neo4j/2.0.0/apidocs/org/
neo4j/graphdb/traversal/TraversalDescription.html> создан, используя переменную величину
взаимодействуйте через интерфейс и такое описание может тогда метать икру траверсы <http://
components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/graphdb/traversal/
Traverser.html>.

Рисунок 33.1. График обхода В качестве примера

Traversal-Example-Graph-how-to-use-the-Traversal-framework.svg


С определением RelationshipTypes как

частные перечислимые Рэлы реализуют RelationshipType
{
    ЛЮБИТ, ЗНАЕТ
}

График может быть пересечен с например следующей траверсой, запускаясь
в вершине "Джо":

для (Позиция пути: Traversal.description ()
        .depthFirst ()
        .relationships (Рэлы. ЗНАЕТ),
        .relationships (Рэлы. ЛЮБИТ, Направление. ПОСТУПЛЕНИЕ)
        .evaluator (Evaluators.toDepth (5))
        .traverse (вершина))
{
    вывод + = позиция + "\n";
}

Обход выведет:

(6)
(6) <-[ЛЮБИТ, 1] - (3)
(6) <-[ЛЮБИТ, 1] - (3) - [ЗНАЕТ, 6]-> (0)
(6) <-[ЛЮБИТ, 1] - (3) - [ЗНАЕТ, 6]-> (0) - [ЗНАЕТ, 4]-> (5)
(6) <-[ЛЮБИТ, 1] - (3) - [ЗНАЕТ, 6]-> (0) - [ЗНАЕТ, 4]-> (5) - [ЗНАЕТ, 3]-> (4)
(6) <-[ЛЮБИТ, 1] - (3) - [ЗНАЕТ, 6]-> (0) - [ЗНАЕТ, 4]-> (5) - [ЗНАЕТ, 3]-> (4) - [ЗНАЕТ, 2]-> (1)
(6) <-[ЛЮБИТ, 1] - (3) - [ЗНАЕТ, 6]-> (0) <-[ЗНАЕТ, 5] - (2)

Начиная с TraversalDescription <http://components.neo4j.org/neo4j/2.0.0/apidocs/org
/neo4j/graphdb/traversal/TraversalDescription.html>s являются неизменными, это также
полезный, чтобы создать шаблонные описания, который содержит общие настройки, совместно использованные
различные обходы. Например, пустите нам запускать с этой траверсы:

конечный TraversalDescription FRIENDS_TRAVERSAL = Traversal.description ()
        .depthFirst ()
        .relationships (Рэлы. ЗНАЕТ),
        .uniqueness (Уникальность. RELATIONSHIP_GLOBAL);

Эта траверса привела бы к следующему выводу (мы продолжим запускать с
Вершина "Джо"):

(6)
(6) - [ЗНАЕТ, 0]-> (1)
(6) - [ЗНАЕТ, 0]-> (1) <-[ЗНАЕТ, 2] - (4)
(6) - [ЗНАЕТ, 0]-> (1) <-[ЗНАЕТ, 2] - (4) <-[ЗНАЕТ, 3] - (5)
(6) - [ЗНАЕТ, 0]-> (1) <-[ЗНАЕТ, 2] - (4) <-[ЗНАЕТ, 3] - (5) <-[ЗНАЕТ, 4] - (0)
(6) - [ЗНАЕТ, 0]-> (1) <-[ЗНАЕТ, 2] - (4) <-[ЗНАЕТ, 3] - (5) <-[ЗНАЕТ, 4] - (0) <-[ЗНАЕТ, 5] - (2)
(6) - [ЗНАЕТ, 0]-> (1) <-[ЗНАЕТ, 2] - (4) <-[ЗНАЕТ, 3] - (5) <-[ЗНАЕТ, 4] - (0) <-[ЗНАЕТ, 6] - (3)

Теперь пустите нам создавать новую траверсу из этого, ограничивая глубину три:

для (Путь пути: FRIENDS_TRAVERSAL
        .evaluator (Evaluators.toDepth (3))
        .traverse (вершина))
{
    вывод + = путь + "\n";
}

Это даст нам следующий результат:

(6)
(6) - [ЗНАЕТ, 0]-> (1)
(6) - [ЗНАЕТ, 0]-> (1) <-[ЗНАЕТ, 2] - (4)
(6) - [ЗНАЕТ, 0]-> (1) <-[ЗНАЕТ, 2] - (4) <-[ЗНАЕТ, 3] - (5)

Или как об от глубины два - четыре? Это сделано как это:

для (Путь пути: FRIENDS_TRAVERSAL
        .evaluator (Evaluators.fromDepth (2))
        .evaluator (Evaluators.toDepth (4))
        .traverse (вершина))
{
    вывод + = путь + "\n";
}

Этот обход дает нам:

(6) - [ЗНАЕТ, 0]-> (1) <-[ЗНАЕТ, 2] - (4)
(6) - [ЗНАЕТ, 0]-> (1) <-[ЗНАЕТ, 2] - (4) <-[ЗНАЕТ, 3] - (5)
(6) - [ЗНАЕТ, 0]-> (1) <-[ЗНАЕТ, 2] - (4) <-[ЗНАЕТ, 3] - (5) <-[ЗНАЕТ, 4] - (0)

Для различных полезных средств анализа, см. Средства анализа <http://компоненты neo4j.org/
neo4j/2.0.0/apidocs/org/neo4j/graphdb/traversal/Evaluators.html> API Java или
просто реализуйте Средство анализа <http://components.neo4j.org/neo4j/2.0.0/apidocs
/org/neo4j/graphdb/traversal/Evaluator.html> соединяют интерфейсом с собой.

Если Вы не интересуетесь Путем <http://components.neo4j.org/neo4j/2.0.0/
apidocs/org/neo4j/graphdb/Path.html> s, но Вершина <http://
components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/graphdb/Node.html>s Вы можете
преобразуйте траверсу в повторяемую из вершин <http://компоненты neo4j.org/
neo4j/2.0.0/apidocs/org/neo4j/graphdb/traversal/Traverser.html#nodes ()> как
это:

для (Вершина currentNode: FRIENDS_TRAVERSAL
        .traverse (вершина)
        .nodes ())
{
    вывод + = currentNode.getProperty ("имя") + "\n";
}

В этом случае мы используем это, чтобы получить имена:

Джо
Сара
Питер
Дирк
Ларс
Эд
Лайза

Отношения <http://components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/
graphdb/traversal/Traverser.html#relationships ()> мелкие частицы также, вот то, как
получить их:

для (Отношение отношения: FRIENDS_TRAVERSAL
        .traverse (вершина)
        .relationships ())
{
    вывод + = relationship.getType () + "\n";
}

Здесь типы отношения записаны, и мы добираемся:

RelationshipTypeToken [name:KNOWS, id:0]
RelationshipTypeToken [name:KNOWS, id:0]
RelationshipTypeToken [name:KNOWS, id:0]
RelationshipTypeToken [name:KNOWS, id:0]
RelationshipTypeToken [name:KNOWS, id:0]
RelationshipTypeToken [name:KNOWS, id:0]

Подсказка

Исходный код для траверс в этом примере доступен в:
TraversalExample.java <https://github.com/neo4j/neo4j/blob/2.0.0/community/
embedded-examples/src/main/java/org/neo4j/examples/TraversalExample.java>

Глава 34. Индексация наследства

Замечание

Это не то же самое, как индексирует определенный в схеме, документации ниже
для индексации наследства в Neo4j.

Эта глава сосредотачивается, как использовать Справочник, Индексирует и Автоиндексирует. С
Neo4j 2.0, это не привилегированный метод индексации данных в Neo4j, вместо этого мы
рекомендуйте определить, индексирует в схеме базы данных.

Однако, поддержка наследства индексирует, остается, потому что определенные функции, такой как
ограничения уникальности, еще не обработаны новым, индексирует.

34.1. Введение

Операции Индексации наследства - часть Neo4j, индексируют API <http://
components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/graphdb/index/
пакет-summary.html>.

Каждый индексирует, связан к уникальному, пользовательскому указанному имени (например "first_name"
или "книги"), и может индексировать любой вершины <http://components.neo4j.org/neo4j/2.0.0
/apidocs/org/neo4j/graphdb/Node.html> или отношения <http://
components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/graphdb/Relationship.html>.

Значение по умолчанию индексирует реализацию, обеспечен neo4j-lucene-index
компонент, который включен в стандартную загрузку Neo4j. Это может также быть
загруженный отдельно с http://repo1.maven.org/maven2/org/neo4j/
neo4j-lucene-index/<http://repo1.maven.org/maven2/org/neo4j/neo4j-lucene-index
/>. Для пользователей Знатока у neo4j-lucene-index компонента есть координаты
org.neo4j:neo4j-lucene-index и должен использоваться с той же самой версией
org.neo4j:neo4j-ядро. Различные версии индексирования и компонентов ядра
не являются совместимыми в общем случае. Включены оба компонента
transitively org.neo4j:neo4j:pom артефактом, который делает простым сохранить
версии в синхронизации.

Поскольку начальный импорт использования данных индексирует, см. Раздел 35.3, “Индексируйте Пакет
Вставка”.

Замечание

Все изменение индексирует операции, должен быть выполнен в транзакции, как с
любая работа изменения в Neo4j.

34.2. Создать

Индексирование создается, если оно не существует, когда Вы просите его. Если Вы не даете это
пользовательская конфигурация, это будет создаваться с конфигурацией значения по умолчанию и
бэкэнд.

Чтобы готовить почву для наших примеров, пустите нам создавать, некоторые индексируют для начала:

IndexManager индексируют = graphDb.index ();
Индексируйте <Вершина> агентов = index.forNodes ("агенты");
Индексируйте <Вершина> фильмы = index.forNodes ("фильмы");
Роли RelationshipIndex = index.forRelationships ("роли");

Это создаст две вершины, индексирует, и одно отношение индексируют со значением по умолчанию
конфигурация. См. Раздел 34.8, “Отношение индексирует” для получения дополнительной информации
определенный для отношения индексирует.

См. Раздел 34.10, “Конфигурация и fulltext индексируют” для того, как создать
fulltext индексирует.

Вы можете также проверить, существует ли индексирование как это:

IndexManager индексируют = graphDb.index ();
булев indexExists = index.existsForNodes ("агенты");

34.3. Стереть

Индексирует может быть стерт. Стирая, все содержание индексирования будет
удаленный так же как его связанная конфигурация. Индексирование может быть создано с
то же самое имя позже вовремя.

IndexManager индексируют = graphDb.index ();
Индексируйте <Вершина> агентов = index.forNodes ("агенты");
actors.delete ();

Заметьте, что фактическое удаление индексирования сделано во время фиксации
окружающая транзакция. Вызовы, выполненные к такому индексировать экземпляр после, стирают ()
<http://components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/graphdb/index/
Index.html#delete%28%29> был вызван, недопустимы в той транзакции как
хорошо как снаружи (если транзакция успешна), но станет допустимым снова
если транзакция откатывается.

34.4. Добавиться

Каждый индексирует, поддерживает соединение любого номера пар значения ключа с любым номером
из объектов (вершины или отношения), где каждая ассоциация между объектом и
пара значения ключа выполняется индивидуально. Для начала, пустите нам прибавлять несколько вершин
к индексированию:

//Агенты
Надсмотрщики вершины = graphDb.createNode ();
reeves.setProperty ("имя", "Киану Ривз");
actors.add (надсмотрщики, "имя", reeves.getProperty ("имя"));
Вершина bellucci = graphDb.createNode ();
bellucci.setProperty ("имя", "Моника Беллучи");
actors.add (bellucci, "имя", bellucci.getProperty ("имя"));
//разнообразные значения для поля, в этом случае для поиска только
//и не сохраненный как свойство.
actors.add (bellucci, "имя", "Ла Беллучи");
//Фильмы
Вершина theMatrix = graphDb.createNode ();
theMatrix.setProperty ("заголовок", "Матрица");
theMatrix.setProperty ("год", 1999);
movies.add (theMatrix, "заголовок", theMatrix.getProperty ("заголовок"));
movies.add (theMatrix, "год", theMatrix.getProperty ("год"));
Вершина theMatrixReloaded = graphDb.createNode ();
theMatrixReloaded.setProperty ("заголовок", "Матрица: Перезагрузка");
theMatrixReloaded.setProperty ("год", 2003);
movies.add (theMatrixReloaded, "заголовок", theMatrixReloaded.getProperty ("заголовок"));
movies.add (theMatrixReloaded, "год", 2003);
Вершина malena = graphDb.createNode ();
malena.setProperty ("заголовок", "Malèna");
malena.setProperty ("год", 2000);
movies.add (malena, "заголовок", malena.getProperty ("заголовок"));
movies.add (malena, "год", malena.getProperty ("год"));

Заметьте, что могут быть разнообразные значения, связанные с тем же самым объектом и ключом.

Затем, мы создадим отношения и индексируем их также:

//мы нуждаемся в типе отношения
DynamicRelationshipType ACTS_IN = DynamicRelationshipType.withName ("ACTS_IN");
//создайте отношения
Отношение role1 = reeves.createRelationshipTo (theMatrix, ACTS_IN);
role1.setProperty ("имя", "Нео");
roles.add (role1, "имя", role1.getProperty ("имя"));
Отношение role2 = reeves.createRelationshipTo (theMatrixReloaded, ACTS_IN);
role2.setProperty ("имя", "Нео");
roles.add (role2, "имя", role2.getProperty ("имя"));
Отношение role3 = bellucci.createRelationshipTo (theMatrixReloaded, ACTS_IN);
role3.setProperty ("имя", "Персефон");
roles.add (role3, "имя", role3.getProperty ("имя"));
Отношение role4 = bellucci.createRelationshipTo (malena, ACTS_IN);
role4.setProperty ("имя", "Malèna Scordia");
roles.add (role4, "имя", role4.getProperty ("имя"));

После этих операций наш график в качестве примера похож на это:

Рисунок 34.1. Фильм и График Агента

Movie-and-Actor-Graph-initial.svg


34.5. Перемещение

Передвижение <http://components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/graphdb/
index/Index.html#remove%28T,%20java.lang.String,%20java.lang.Object%29> от
индексируйте подобно добавлению, но может быть сделан, предоставляя один из следующих
комбинации параметров:

  * объект
  * объект, ключ
  * объект, ключ, значение

//полностью переместите bellucci от агентов, индексируют
actors.remove (bellucci);
//перемещение любая запись "имени" bellucci от агентов индексирует
actors.remove (bellucci, "имя");
//переместите "имя"-> запись "Ла Беллучи" bellucci
actors.remove (bellucci, "имя", "Ла Беллучи");

34.6. Обновление

Важный

Чтобы обновить индексировать запись, старый должен быть удален, и новый прибавлен. Для
детали относительно передвижения индексируют записи, видят Раздел 34.5, "Перемещение".

Помните, что вершина или отношение могут быть связаны с любым номером
пары значения ключа в индексировании. Это означает, что Вы можете индексировать вершину или
отношение со многими парами значения ключа, у которых есть тот же самый ключ. В случае
где значение свойства изменяется, и Вы хотели бы обновить индексирование, это не
достаточно, чтобы только индексировать новое значение  -  Вы должны будете переместить старое значение как
хорошо.

Вот пример кода, который демонстрирует, как он сделан:

//создайте вершину со свойством
//таким образом, у нас есть что-то, чтобы обновить позже
Вершина fishburn = graphDb.createNode ();
fishburn.setProperty ("имя", "Fishburn");
//индексируйте это
actors.add (fishburn, "имя", fishburn.getProperty ("имя"));
//обновите индексировать запись
//когда значение свойства изменяется
actors.remove (fishburn, "имя", fishburn.getProperty ("имя"));
fishburn.setProperty ("имя", "Лоуренс Фишберн");
actors.add (fishburn, "имя", fishburn.getProperty ("имя"));

34.7. Поиск

34.7.1. Добраться
34.7.2. Запрос

Индексирование может искаться двумя способами, добраться <http://components.neo4j.org/neo4j/
2.0.0/apidocs/org/neo4j/graphdb/index/Index.html#
get%28java.lang.String,%20java.lang.Object%29> и запрос <http://
components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/graphdb/index/Index.html#
query%28java.lang.String,%20java.lang.Object%29>. Получить метод возвратится
точные совпадения данной паре значения ключа, тогда как запрос представляет запросы
возможности прямо от бэкэнда используются индексированием. Например
Lucene запрашивают синтаксис <http://lucene.apache.org/core/3_6_2/
queryparsersyntax.html> может использоваться прямо с бэкэндом индексации значения по умолчанию.

34.7.1. Добраться

Это - то, как искать единственное точное совпадение:

IndexHits <Вершина> совершает нападки = actors.get ("имя", "Киану Ривз");
Надсмотрщики вершины = hits.getSingle ();

IndexHits <http://components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/graphdb/
index/IndexHits.html> является Повторяемым с некоторыми дополнительными полезными методами. Для
пример getSingle () <http://components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/
graphdb/index/IndexHits.html#getSingle%28%29> возвращает первый и единственный элемент
от результата iterator, или нуля, если нет никакого хита.

Вот то, как получить единственное отношение точным соответствием и получить
запустите и конечные узлы:

Отношение persephone = roles.get ("имя", "Персефон").getSingle ();
Агент вершины = persephone.getStartNode ();
Фильм вершины = persephone.getEndNode ();

Наконец, мы можем выполнить итерации по всем точным совпадениям от отношения, индексируйте:

для (Роль отношения: roles.get ("имя", "Нео"))
{
    //это даст нам Надсмотрщиков дважды
    Надсмотрщики вершины = role.getStartNode ();
}

Важный

В случае, если Вы не выполняете итерации посредством всех хитов, IndexHits.close () <http://
components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/graphdb/index/IndexHits.html
#close%28%29> должен быть вызван явно.

34.7.2. Запрос

Есть два метода запроса, тот, который использует подпись значения ключа где
значение представляет запрос для значений с данным ключом только. Другой метод
более универсально и поддерживает запросы больше чем для одной пары значения ключа в
тот же самый запрос.

Вот пример, используя опцию ключевого запроса:

для (Агент вершины: actors.query ("имя", "*e *"))
{
    //Это возвратит Надсмотрщиков и Беллучи
}

В следующем примере запрос использует разнообразные ключи:

для (Фильм вершины: movies.query ("title:*Matrix* И year:1999"))
{
    //Это возвратит "Матрицу" с 1999 только.
}

Замечание

Начало подстановочного знака ищет с "*" или"?" обескуражен Lucene, но будет
однако работа.

Предостережение

У Вас не может быть никакого пробела в критерии поиска с этим синтаксисом. См.
Раздел 34.11.3, “Запросы с Запросом Lucene возражает” для того, как сделать это.

34.8. Отношение индексирует

Индексирование для отношений точно так же как индексирование для вершин, расширенных
оказывание поддержки, чтобы ограничить поиск к отношениям с определенным запуском
и/или конечные узлы Эти дополнительные методы находятся в RelationshipIndex <http://
components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/graphdb/index/
RelationshipIndex.html> интерфейс, который расширяется, Индексируют <Отношение> <http://
components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/graphdb/index/Index.html>.

Пример запросов отношения индексирует:

//фильтрация отношений нового месторождения на вершине запуска
//использование точных совпадений
IndexHits <Отношение> reevesAsNeoHits;
reevesAsNeoHits = roles.get ("имя", "Нео", надсмотрщики, нуль);
Отношение reevesAsNeo = reevesAsNeoHits.iterator ().next ();
reevesAsNeoHits.close ();
//фильтрация отношений нового месторождения на конечном узле
//использование запроса
IndexHits <Отношение> matrixNeoHits;
matrixNeoHits = roles.query ("имя", "*eo", нуль, theMatrix);
Отношение matrixNeo = matrixNeoHits.iterator ().next ();
matrixNeoHits.close ();

И вот пример для особого случая поиска определенного
тип отношения:

//фильтрация отношений нового месторождения на конечном узле
//использование типа отношения.
//это - то, как прибавить это к индексированию:
roles.add (reevesAsNeo, "введите", reevesAsNeo.getType ().name ());
//Заметьте, что, чтобы использовать составной запрос, мы не можем объединиться фиксировавший
//и незафиксированный индексируют записи, таким образом, мы будем фиксировать перед запросами:
tx.success ();
tx.finish ();

//и теперь мы можем искать это:
попробуйте (Транзакция tx = graphDb.beginTx ())
{
    IndexHits <Отношение> typeHits = roles.query ("type:ACTS_IN И name:Neo", нуль, theMatrix);
    Отношение typeNeo = typeHits.iterator ().next ();
    typeHits.close ();

Такой индексировать может быть полезным, если у Вашего домена есть вершины с очень большим количеством
из отношений между ними, так как это понижает время поиска для a
отношение между двумя вершинами. Хороший пример, где этот подход травит
дивиденды находятся в данных временного ряда, где нам представляли чтения как a
отношение на возникновение.

34.9. Метки

Интерфейс IndexHits представляет выигрыш <http://components.neo4j.org/neo4j/
2.0.0/apidocs/org/neo4j/graphdb/index/IndexHits.html#currentScore%28%29> так
то, что индексирование может передать метки для хитов. Заметьте, что результат не
сортированный меткой, если Вы явно не определяете это. См. Раздел 34.11.2,
"Сортировка" для того, как сортировать меткой.

IndexHits <Вершина> совершает нападки = movies.query ("заголовок", "*");
для (Фильм вершины: хиты)
{
    System.out.println (movie.getProperty ("заголовок") + "" + hits.currentScore ());
}

34.10. Конфигурация и fulltext индексируют

Во время создания дополнительная конфигурация может быть определена, чтобы управлять
поведение индексирования и который бэкэнд использовать. Например создать Lucene
fulltext индексируют:

IndexManager индексируют = graphDb.index ();
Индексируйте <Вершина> fulltextMovies = index.forNodes ("фильмы-fulltext",
        MapUtil.stringMap (IndexManager. ПРОВАЙДЕР, "lucene", "вводит", "fulltext"));
fulltextMovies.add (theMatrix, "заголовок", "Матрица");
fulltextMovies.add (theMatrixReloaded, "заголовок", "Матрица: Перезагрузка");
//поиск в fulltext индексирует
Вершина, найденная = fulltextMovies.query ("заголовок", "перезагруженный").getSingle ();

Вот пример того, как создать точное, индексируют, который является нечувствительным к регистру:

Индексируйте <Вершина>, индексируют = graphDb.index ().forNodes ("точно-нечувствительный к регистру",
        stringMap ("тип", "точный", "to_lower_case", "истина"));
Вершина вершины = graphDb.createNode ();
index.add (вершина, "имя", "Томас Андерсон");
assertContains (index.query ("имя", "\"Томас Андерсон \""), вершина);
assertContains (index.query ("имя", "\"томасовский ANDerson \""), вершина);

Подсказка

Чтобы искать маркируемые слова, метод запроса должен использоваться.
доберитесь метод будет только соответствовать полное строковое значение, не маркеры.

Конфигурация индексирования сохранена, как только индексирование было создано.
Ключ конфигурации провайдера интерпретируется Neo4j, но любым другим
конфигурацию передают на бэкэнд, индексируют (например. Lucene), чтобы интерпретировать.

Таблица 34.1. Lucene, индексирующий параметры конфигурации

Параметр Возможный Эффект значений
введите точный, fulltext точный значение по умолчанию и использует a
                                          Ключевое слово Lucene анализатор <http://
                                          lucene.apache.org/core/3_6_2/api/core
                                          /org/apache/lucene/analysis/
                                          KeywordAnalyzer.html>. использование fulltext
                                          пробельный токенизатор в
                                          анализатор.

истина to_lower_case, ложь Этот параметр идет вместе с
                                          введите: fulltext и преобразовывает значения в
                                          нижний регистр во время обоих прибавлений и
                                          запросы, делая индексировать случай
                                          нечувствительный. Значения по умолчанию к истине.

анализатор полное имя класса Переопределения тип так, чтобы пользовательское
              Анализатор <http://анализатор может использоваться. Замечание:
              lucene.apache.org/core/ to_lower_case все еще влияет
              Печатание строчными литерами 3_6_2/api/core/org/apache/строковых запросов. Если
              lucene/analysis/пользовательские верхние регистры анализатора
              Analyzer.html> индексированные маркеры, строковые запросы будут
                                          не соответствуют как ожидалось.


34.11. Дополнительные функции для Lucene индексируют

34.11.1. Числовые диапазоны
34.11.2. Сортировка
34.11.3. Запросы с объектами Запроса Lucene
34.11.4. Составные запросы
34.11.5. Оператор значения по умолчанию
34.11.6. Кэширование

34.11.1. Числовые диапазоны

Lucene поддерживает умную индексацию номеров, запросы для диапазонов и сортировку такой
результаты, и так делают его бэкэнд для Neo4j. Отметить значение так, чтобы это было
индексированный как числовое значение, мы можем использовать ValueContext <http://
components.neo4j.org/neo4j-lucene-index/2.0.0/apidocs/org/neo4j/index/lucene/
ValueContext.html> класс, как это:

movies.add (theMatrix, "числовой годом", новый ValueContext (1999).indexNumeric ());
movies.add (theMatrixReloaded, "числовой годом", новый ValueContext (2003).indexNumeric ());
movies.add (malena, "числовой годом", новый ValueContext (2000).indexNumeric ());

интервал от = 1997;
интервал к = 1999;
хиты = movies.query (QueryContext.numericRange ("числовой годом", от, до));

Замечание

Тот же самый тип должен использоваться для индексации и запросов. Таким образом, Вы не можете индексировать
значение как Лонг и затем запрашивает индексировать использование Целого числа.

Давая нуль как из/в параметр, открытый законченный запрос создается. В
следование примеру мы делаем это, и прибавили сортировку к запросу как
хорошо:

хиты = movies.query (
        QueryContext.numericRange ("числовой годом", от, нуль)
                .sortNumeric ("числовой годом", ложный));

Из/в в значениях по умолчанию диапазонов, чтобы быть содержащими, но Вы можете изменить это
поведение при использовании двух дополнительных параметров:

movies.add (theMatrix, "метка", новый ValueContext (8.7).indexNumeric ());
movies.add (theMatrixReloaded, "метка", новый ValueContext (7.1).indexNumeric ());
movies.add (malena, "метка", новый ValueContext (7.4).indexNumeric ());

//включайте 8.0, исключите 9.0
хиты = movies.query (QueryContext.numericRange ("метка", 8.0, 9.0, истина, ложь));

34.11.2. Сортировка

Lucene выполняет сортировку очень хорошо, и это также представлено в индексировании
бэкэнд, через QueryContext <http://компоненты neo4j.org/
neo4j-lucene-index/2.0.0/apidocs/org/neo4j/index/lucene/QueryContext.html>
класс:

хиты = movies.query ("заголовок", новый QueryContext ("*").sort ("заголовок"));
для (Вершина совершала нападки: хиты)
{
    //все фильмы с заголовком в индексировании, упорядоченный заголовком
}
//или
хиты = movies.query (новый QueryContext ("title: *").sort ("год", "заголовок"));
для (Вершина совершала нападки: хиты)
{
    //все фильмы с заголовком в индексировании, упорядоченный за год, тогда заголовок
}

Мы сортируем результаты уместностью (метка) как это:

хиты = movies.query ("заголовок", новый QueryContext ("*").sortByScore ());
для (Фильм вершины: хиты)
{
    //хиты сортированы уместностью (метка)
}

34.11.3. Запросы с объектами Запроса Lucene

Вместо того, чтобы передать в Lucene запрашивают запросы синтаксиса, Вы можете инстанцировать такого
запросы программно и передача в как параметр, например:

//TermQuery даст точные совпадения
Агент вершины = actors.query (новый TermQuery (новый Термин ("имя", "Киану Ривз"))).getSingle ();

Заметьте что TermQuery <http://lucene.apache.org/core/3_6_2/api/core/org/
apache/lucene/search/TermQuery.html> является в основном той же самой вещью как использование
наденьте метод индексирование.

Это - то, как выполнить подстановочные поискы, используя Объекты Запроса Lucene:

хиты = movies.query (новый WildcardQuery (новый Термин ("заголовок", "Матрица *")));
для (Фильм вершины: хиты)
{
    System.out.println (movie.getProperty ("заголовок"));
}

Заметьте, что это учитывает пробел в строке поиска.

34.11.4. Составные запросы

Lucene поддерживает запросы для разнообразных сроков в том же самом запросе, как так:

хиты = movies.query ("title:*Matrix* И year:1999");

Предостережение

Составные запросы не могут искать через фиксировавший, индексируют записи и тех кто
не фиксировали еще одновременно.

34.11.5. Оператор значения по умолчанию

Оператор значения по умолчанию (это или И или ИЛИ используется промежуточный отличающийся
сроки) в запросе ИЛИ. Изменение того поведения также сделано через
QueryContext <http://components.neo4j.org/neo4j-lucene-index/2.0.0/apidocs/org/
neo4j/index/lucene/QueryContext.html> класс:

QueryContext запрашивают = новый QueryContext ("title:*Matrix* year:1999")
        .defaultOperator (Оператор. И);
хиты = movies.query (запрос);

34.11.6. Кэширование

Если Ваш индексировать поиски становится горлышком бутылки производительности, кэширование может быть включено
для определенных ключей в бесспорном индексирует (ключевые расположения), чтобы убыстриться получают запросы.
Кэширование реализовано с LRU <http://en.wikipedia.org/wiki/
Cache_algorithms#Least_Recently_Used> кэш так, чтобы только последний раз
результаты, к которым получают доступ, кэшируются (с "результатами", означающими результат запроса получения
запрос, ни один объект). Вы можете управлять размером кэша (
максимальное число результатов) на индексируют ключ.

Индексируйте <Вершина>, индексируют = graphDb.index ().forNodes ("агенты");
((LuceneIndex <Вершина>) индексируют).setCacheCapacity ("имя", 300000);

Предостережение

Эта установка не сохранена после выключения база данных. Это означает: набор
это значение после каждого запуска базы данных, если Вы хотите сохранить это.

34.12. Автоматическая Индексация

34.12.1. Конфигурация
34.12.2. Поиск
34.12.3. Конфигурация времени выполнения
34.12.4. Обновление Автоматического Индексирует

Neo4j обеспечивает, единственное индексируют для вершин и один для отношений в каждом
база данных, которые автоматически следуют за значениями свойств, поскольку они прибавлены, стерты
и измененный на примитивах базы данных. Эту функциональность вызывают автоматической индексацией
и управляется и из Карты конфигурации базы данных и через его собственное
API.

34.12.1. Конфигурация

По умолчанию Автоматическая Индексация выключена и для Вершин и для Отношений. Сконфигурировать
это в neo4j.properties файле, используйте ключи конфигурации
node_auto_indexing и relationship_auto_indexing. Для встроенного режима, используйте
параметры конфигурации GraphDatabaseSettings.node_auto_indexing и
GraphDatabaseSettings.relationship_auto_indexing. В обоих случаях, установите значение
к истине. Это включит автоматической индексации на запуске. Только заметьте, что мы
не сделанный все же, см. ниже!

К фактически автоматическому индексируют что-то, Вы должны установить, какие свойства должны добраться
индексированный. Вы делаете это, перечисляя ключи свойства, чтобы индексировать на. В
конфигурационный файл, используйте node_keys_indexable и relationship_keys_indexable
ключи конфигурации. При использовании встроенного режима, используйте
GraphDatabaseSettings.node_keys_indexable и
GraphDatabaseSettings.relationship_keys_indexable ключи конфигурации. Всего
случаи, значение должно быть списком разделенных запятой значений ключей свойства, чтобы индексировать на.

Кодируя в Java, это сделано как это:

/*
 * Создание конфигурации, добавляясь nodeProp1 и nodeProp2 как
 * автоматические индексированные свойства для Вершин и relProp1 и relProp2 как
 * автоматические индексированные свойства для Отношений. Только те будут
 * индексированный. Мы также должны включить автоматической индексации для обоих они
 * примитивы явно.
 */
GraphDatabaseService graphDb = новый GraphDatabaseFactory ().
    newEmbeddedDatabaseBuilder (storeDirectory).
    setConfig (GraphDatabaseSettings.node_keys_indexable, "nodeProp1, nodeProp2").
    setConfig (GraphDatabaseSettings.relationship_keys_indexable, "relProp1, relProp2").
    setConfig (GraphDatabaseSettings.node_auto_indexing, "истина").
    setConfig (GraphDatabaseSettings.relationship_auto_indexing, "истина").
    newGraphDatabase ();

Вершина node1 = нуль, node2 = нуль;
Рэл отношения = нуль;
попробуйте (Транзакция tx = graphDb.beginTx ())
{
    //Создайте примитивы
    node1 = graphDb.createNode ();
    node2 = graphDb.createNode ();
    рэл = node1.createRelationshipTo (node2,
            DynamicRelationshipType.withName ("ДИНАМИЧЕСКИЙ ГРОМКОГОВОРИТЕЛЬ"));

    //Прибавьте индексируемые и неиндексируемые свойства
    node1.setProperty ("nodeProp1", "nodeProp1Value");
    node2.setProperty ("nodeProp2", "nodeProp2Value");
    node1.setProperty ("неиндексированный", "nodeProp2NonIndexedValue");
    rel.setProperty ("relProp1", "relProp1Value");
    rel.setProperty ("relPropNonIndexed", "relPropValueNonIndexed");

    //Сделайте вещи персистентными
    tx.success ();
}

34.12.2. Поиск

Полноценность автоматической функциональности индексации прибывает, конечно, из
возможность фактически запросить индексирование и получить результаты. С этой целью, Вы можете
получите объект ReadableIndex от AutoIndexer, который представляет весь запрос
и доберитесь, методы полного Индексируют <http://components.neo4j.org/neo4j/2.0.0/
apidocs/org/neo4j/graphdb/index/Index.html> с точно тем же самым
функциональность. Продолжение от предыдущего примера, получая доступ к индексированию
сделанный как это:

попробуйте (Транзакция tx = graphDb.beginTx ())
{
    //Доберитесь автоматическая Вершина индексируют
    ReadableIndex <Вершина> autoNodeIndex = graphDb.index ()
            .getNodeAutoIndexer ()
            .getAutoIndex ();
    //у node1 и node2 оба были автоматические индексированные свойства, получите их
    assertEquals (node1,
            autoNodeIndex.get ("nodeProp1", "nodeProp1Value").getSingle ());
    assertEquals (node2,
            autoNodeIndex.get ("nodeProp2", "nodeProp2Value").getSingle ());
    //у node2 также было свойство, которое должно игнорироваться.
    assertFalse (autoNodeIndex.get ("неиндексированный",
            "nodeProp2NonIndexedValue").hasNext ());

    //Доберитесь автоматическое отношение индексируют
    ReadableIndex <Отношение> autoRelIndex = graphDb.index ()
            .getRelationshipAutoIndexer ()
            .getAutoIndex ();
    //Одно свойство было установлено для автоматической индексации
    assertEquals (рэл,
            autoRelIndex.get ("relProp1", "relProp1Value").getSingle ());
    //Остальные должны игнорироваться
    assertFalse (autoRelIndex.get ("relPropNonIndexed",
            "relPropValueNonIndexed").hasNext ());
}

34.12.3. Конфигурация времени выполнения

Те же самые опции, которые доступны во время создания базы данных через
конфигурация может также быть установлена во время времени выполнения через API AutoIndexer.

Получение доступа к API AutoIndexer и прибавляя две Вершины и одно Отношение
свойства к автоматическому индексируют, сделан как так:

//Запустите без любой конфигурации
GraphDatabaseService graphDb = новый GraphDatabaseFactory ().
        newEmbeddedDatabase (storeDirectory);

//Получите Вершину AutoIndexer, установите nodeProp1 и nodeProp2 как автоматический
//индексированный.
AutoIndexer <Вершина> nodeAutoIndexer = graphDb.index ()
        .getNodeAutoIndexer ();
nodeAutoIndexer.startAutoIndexingProperty ("nodeProp1");
nodeAutoIndexer.startAutoIndexingProperty ("nodeProp2");

//Получите Отношение AutoIndexer
AutoIndexer <Отношение> relAutoIndexer = graphDb.index ()
        .getRelationshipAutoIndexer ();
relAutoIndexer.startAutoIndexingProperty ("relProp1");

//Ни одному из AutoIndexers до сих пор не включают. Сделайте это теперь
nodeAutoIndexer.setEnabled (истина);
relAutoIndexer.setEnabled (истина);


Замечание

Параметры к AutoIndexers проходили через Конфигурацию и настройки
сделанный через API являются кумулятивными. Таким образом, Вы можете установить некоторых заранее известных
настройки, сделайте проверки на этапе выполнения, чтобы увеличить начальную конфигурацию и затем
включите требуемым автоматическим индексаторам - конечная конфигурация - то же самое
независимо от метода, используемого, чтобы достигнуть этого.

34.12.4. Обновление Автоматического Индексирует

Обновления к автоматическим индексированным свойствам происходят, конечно, автоматически как Вы
обновите их. Перемещение свойств от автоматического индексирует, происходит по двум причинам.
Каждый - это, Вы фактически переместили свойство. Другой то, что Вы остановились
автоиндексация на свойстве. Когда последний происходит, любой примитив, Вы затрагиваете
и у этого есть то свойство, это удалено от автоматического, индексируют, независимо от любого
операции на свойстве. Когда Вы запускаете или останавливаете автоматическую индексацию на свойстве,
никакая автоматическая работа обновления не происходит в настоящий момент. Если Вы должны изменить набор
автоматическим индексированным свойствам и повторно индексировали их, Вы в настоящий момент должны сделать это
вручную. Пример будет пояснять вышеупомянутое лучше:

/*
 * Создание конфигурации
 */
GraphDatabaseService graphDb = новый GraphDatabaseFactory ().
    newEmbeddedDatabaseBuilder (storeDirectory).
    setConfig (GraphDatabaseSettings.node_keys_indexable, "nodeProp1, nodeProp2").
    setConfig (GraphDatabaseSettings.node_auto_indexing, "истина").
    newGraphDatabase ();

Вершина node1 = нуль, node2 = нуль, node3 = нуль, node4 = нуль;
попробуйте (Транзакция tx = graphDb.beginTx ())
{
    //Создайте примитивы
    node1 = graphDb.createNode ();
    node2 = graphDb.createNode ();
    node3 = graphDb.createNode ();
    node4 = graphDb.createNode ();

    //Прибавьте индексируемые и неиндексируемые свойства
    node1.setProperty ("nodeProp1", "nodeProp1Value");
    node2.setProperty ("nodeProp2", "nodeProp2Value");
    node3.setProperty ("nodeProp1", "nodeProp3Value");
    node4.setProperty ("nodeProp2", "nodeProp4Value");

    //Сделайте вещи персистентными
    tx.success ();
}

/*
 * Здесь обе вершины индексированы. Чтобы демонстрировать перемещение, мы останавливаемся
 * автоиндексирующий nodeProp1.
 */
AutoIndexer <Вершина> nodeAutoIndexer = graphDb.index ().getNodeAutoIndexer ();
nodeAutoIndexer.stopAutoIndexingProperty ("nodeProp1");

попробуйте (Транзакция tx = graphDb.beginTx ())
{
    /*
     * nodeProp1 больше не автоматический индексированный. Это будет
     * удаленный независимо. Заметьте, что node3 останется.
     */
    node1.setProperty ("nodeProp1", "nodeProp1Value2");
    /*
     * node2 будет автоматический обновленный
     */
    node2.setProperty ("nodeProp2", "nodeProp2Value2");
    /*
     * перемещают node4 свойство nodeProp2 от, индексируют.
     */
    node4.removeProperty ("nodeProp2");
    //Сделайте вещи персистентными
    tx.success ();
}

попробуйте (Транзакция tx = graphDb.beginTx ())
{
    //Проверить
    ReadableIndex <Вершина> nodeAutoIndex = nodeAutoIndexer.getAutoIndex ();
    //node1 полностью не стало
    assertFalse (nodeAutoIndex.get ("nodeProp1", "nodeProp1Value").hasNext ());
    assertFalse (nodeAutoIndex.get ("nodeProp1", "nodeProp1Value2").hasNext ());
    //node2 обновлен
    assertFalse (nodeAutoIndex.get ("nodeProp2", "nodeProp2Value").hasNext ());
    assertEquals (node2,
            nodeAutoIndex.get ("nodeProp2", "nodeProp2Value2").getSingle ());
    /*
     * node3 все еще там, несмотря на его nodeProp1 свойство, не контролируемое
     * больше, потому что это не было затронуто, в отличие от node1.
     */
    assertEquals (node3,
            nodeAutoIndex.get ("nodeProp1", "nodeProp3Value").getSingle ());
    //Наконец, node4 удален, потому что свойство было удалено.
    assertFalse (nodeAutoIndex.get ("nodeProp2", "nodeProp4Value").hasNext ());
}

Предостережение

Если Вы запускаете базу данных с автоматической индексации, включенной но отличающейся автоматический индексированный
свойства чем последнее выполнение, тогда уже автоиндексированные свойства будут
стертый из индексирования, когда значение записано им (принятие свойства
не присутствует в новой конфигурации). Удостоверьтесь, что контролируемый набор
что Вы хотите прежде, чем добавить функциональность.

Глава 35. Пакетная Вставка

У Neo4j есть пакетное средство вставки, имеемое в виду для начального импорта, который
транзакции обходов и другие проверки в пользу производительности. Это полезно
когда у Вас есть большой набор данных, который должен быть загружен однажды.

Пакетная вставка включена в neo4j-ядро <http://search.maven.org/#
search|ga|1|neo4j-ядро> компонент, который является частью всех дистрибутивов Neo4j
и выпуски.

Знайте о следующих моментах при использовании пакетной вставки:

  * намеченное использование для начального импорта данных.
  * Пакетная вставка не безопасный поток.
  * Пакетная вставка является нетранзакционной.
  * Пакетная вставка повторно заполнит, все существующие индексируют и индексируют создаваемый
    во время пакетной вставки на завершении работы.
  *, Если завершение работы успешно не вызвано в конце импорта,
    файлы базы данных будут повреждены.

Предупреждение

Всегда выполняйте пакетную вставку в единственном потоке (или используйте синхронизацию для
заставьте только один поток во время получить доступ к пакетной вставке), и вызовите завершение работы
когда обработано начисто.

35.1. Пакетные Примеры Вставки

Создание пакетной вставки подобно тому, как Вы обычно создаете данные в
база данных, но в этом случае BatchInserter низкого уровня <http://
components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/unsafe/batchinsert/
BatchInserter.html> интерфейс используется. Поскольку мы уже указали, Вы
не может иметь многозаходных резьб, используя пакетную вставку одновременно без
внешняя синхронизация.

Подсказка

Исходный код примеров найден здесь: BatchInsertDocTest.java <https:/
/github.com/neo4j/neo4j/blob/2.0.0/community/kernel/src/test/java/examples/
BatchInsertDocTest.java>

Чтобы овладеть BatchInseter, используйте BatchInserters <http://компоненты neo4j.org/
neo4j/2.0.0/apidocs/org/neo4j/unsafe/batchinsert/BatchInserters.html> и затем
пойдите оттуда:

Вставка BatchInserter = BatchInserters.inserter ("target/batchinserter-example", файловая система);
Маркируйте personLabel = DynamicLabel.label ("Человек");
inserter.createDeferredSchemaIndex (personLabel).on ("имя").create ();
Карта <Строка, Объект> свойства = новый HashMap <> ();
properties.put ("имя", "Маттиас");
долго mattiasNode = inserter.createNode (свойства, personLabel);
properties.put ("имя", "Крис");
долго chrisNode = inserter.createNode (свойства, personLabel);
RelationshipType знает =, DynamicRelationshipType.withName ("ЗНАЕТ");
//Чтобы установить свойства на отношении, используйте карту свойств
//вместо нуля как последний параметр.
inserter.createRelationship (mattiasNode, chrisNode, знает, нуль);
inserter.shutdown ();

Чтобы получить хорошую производительность, Вы, вероятно, хотите установить некоторые настройки конфигурации
для пакетной вставки. Считайте Раздел 22.11.3, “Пакетный пример вставки” для
информация о конфигурировании пакетной вставки. Это - то, как запустить пакет
вставка с параметрами конфигурации:

Карта <Строка, Строка> конфигурация = новый HashMap <> ();
config.put ("neostore.nodestore.db.mapped_memory", "90M");
Вставка BatchInserter = BatchInserters.inserter (
        "target/batchinserter-example-config", файловая система, конфигурация);
//Вставьте данные здесь... и затем выключение:
inserter.shutdown ();

В случае, если Вы сохранили конфигурацию в файле, Вы можете загрузить ее как это:

попробуйте (ввод InputStream = fileSystem.openAsInputStream (новый Файл ("target/batchinsert-config")))
{
    Карта <Строка, Строка> конфигурация = MapUtil.load (введен);
    Вставка BatchInserter = BatchInserters.inserter (
            "target/batchinserter-example-config", файловая система, конфигурация);
    //Вставьте данные здесь... и затем выключение:
    inserter.shutdown ();
}

35.2. Пакетная База данных Графика

В случае, если у Вас уже есть код для импорта данных, записанного против нормального Neo4j
API, Вы могли рассмотреть использование пакетной вставки, представляющей тот API.

Замечание

Это не будет выполнять столь же хороший как использование API BatchInserter прямо.

Также знайте о следующем:

  * Запуск транзакции или вызов Transaction.finish () / близко () или
    Transaction.success () ничего не сделает.
  * Вызов Transaction.failure () метод генерирует NotInTransaction
    исключение.
  * Node.delete () и Node.traverse () не поддерживаются.
  * Relationship.delete () не поддерживается.
  * Обработчики событий и индексируют, не поддерживаются.
  * GraphDatabaseService.getRelationshipTypes (), getAllNodes () и
    getAllRelationships () не поддерживаются.

С этими предосторожностями в памяти, это - то, как сделать это:

GraphDatabaseService batchDb =
        BatchInserters.batchDatabase ("target/batchdb-example", файловая система);
Маркируйте personLabel = DynamicLabel.label ("Человек");
Вершина mattiasNode = batchDb.createNode (personLabel);
mattiasNode.setProperty ("имя", "Маттиас");
Вершина chrisNode = batchDb.createNode ();
chrisNode.setProperty ("имя", "Крис");
chrisNode.addLabel (personLabel);
RelationshipType знает =, DynamicRelationshipType.withName ("ЗНАЕТ");
mattiasNode.createRelationshipTo (chrisNode, знает);
batchDb.shutdown ();

Подсказка

Исходный код примера найден здесь: BatchInsertDocTest.java <https://
github.com/neo4j/neo4j/blob/2.0.0/community/kernel/src/test/java/examples/
BatchInsertDocTest.java>

35.3. Индексируйте Пакетную Вставку

35.3.1. Лучшая практика

Для общих сведений на пакетной вставке, см. Главу 35, Пакетную Вставку.

Индексация во время пакетной вставки сделана, используя BatchInserterIndex <http://
components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/unsafe/batchinsert/
BatchInserterIndex.html>, которые обеспечены через BatchInserterIndexProvider
<http://components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/unsafe/batchinsert/
BatchInserterIndexProvider.html>. Пример:

Вставка BatchInserter = BatchInserters.inserter ("target/neo4jdb-batchinsert");
BatchInserterIndexProvider indexProvider =
        новый LuceneBatchInserterIndexProvider (вставка);
Агенты BatchInserterIndex =
        indexProvider.nodeIndex ("агенты", MapUtil.stringMap ("тип", "точный"));
actors.setCacheCapacity ("имя", 100000);

Карта <Строка, Объект> свойства = MapUtil.map ("имя", "Киану Ривз");
длинная вершина = inserter.createNode (свойства);
actors.add (вершина, свойства);

//делайте изменения видимыми для того, чтобы читать, использование это редко, требует IO!
actors.flush ();

//Удостоверьтесь к выключению индексировать провайдер также
indexProvider.shutdown ();
inserter.shutdown ();

Параметры конфигурации - то же самое как упомянуто в Разделе 34.10,
“Конфигурация и fulltext индексируют”.

35.3.1. Лучшая практика

Вот некоторые указатели, чтобы вытащить большинство производительности из BatchInserterIndex:

  * Попытка избежать сбрасывать <http://components.neo4j.org/neo4j/2.0.0/apidocs/org/
    neo4j/unsafe/batchinsert/BatchInserterIndex.html#flush%28%29> слишком часто
    потому что каждый сброс будет следовать всеми прибавлениями (так как длятся сброс) быть
    видимый к методам запросов, и публикации тех изменений может быть a
    потеря производительности.
  * Имеют (настолько большой насколько возможно) фазы, где одна фаза - или только записи или
    только чтения, и не забывают сбрасывать после фазы записи так, чтобы те
    изменения становятся видимыми к методам запросов.
  * Позволяют кэшироваться <http://components.neo4j.org/neo4j/2.0.0/apidocs/org/neo4j/
    unsafe/batchinsert/BatchInserterIndex.html#
    setCacheCapacity%28java.lang.String,%20int%29> для ключей Вы знаете, что Вы
    продвижение сделать поиски для позже, чтобы увеличить производительность значительно
    (хотя производительность вставки может ухудшиться немного).

Замечание

Изменения к индексированию доступны для чтения сначала после того, как они сброшены к
диск. Таким образом, для оптимальной производительности, читайте, и операции поиска должны быть сохранены
к минимуму во время batchinsertion, так как они включают IO и плотно сжимают скорость
негативно.


-------------------------------------------------------------------------------

Приложение A. Страницы справочника

-------------------------------------------------------------------------------

Страницы руководства Unix Neo4j включены в следующее, нумерует страницу.

  * neo4j
  * neo4j-установщик
  * neo4j-оболочка
  * neo4j-резервное-копирование
  * neo4j-арбитр

Имя

neo4j - управление Сервером Neo4j

Резюме

neo4j <команда>

ОПИСАНИЕ

Neo4j - база данных графика, совершенная для того, чтобы работать с чрезвычайно соединенными данными.
команда neo4j используется, чтобы управлять Сервером Neo4j.

Привилегированный способ установить Neo4j на системах Linux при использовании предварительно созданного
пакеты установки, но есть также возможность использовать
команда neo4j-установщика, чтобы установить или переместить это как системную службу. Для
информация относительно Windows, см. ниже.

КОМАНДЫ

консоль
    Запустите сервер как приложение, работая как приоритетный процесс. Остановиться
    сервер, используя CTRL-C.
запустить
    Запустите сервер как демона, работая как фоновый процесс.
остановиться
    Останавливает выполнение daemonized сервер.
запустить снова
    Запускает снова сервер.
состояние
    Текущее состояние выполнения сервера.
информация
    Информация о конфигурации дисплеев, такая как текущий NEO4J_HOME и
    ПУТЬ К КЛАССУ.

Использование - Windows

Neo4j.bat

Двойной щелчок по Neo4j.bat сценарию запустит сервер в консоли. К
выход, только нажмите Ctrl-C в консоли.

Для того, чтобы установить Сервер Neo4j как сервис, используйте Neo4jInstaller.bat
команда.

  * Neo4j.bat запускаются - запустит службу Neo4j

      o запустит службу Neo4j если установлено или консоль
      o сеанс иначе.
  * Neo4j.bat останавливаются - останавливают службу Neo4j, работая
  * Neo4j.bat запускают снова - запускают снова службу Neo4j если установлено
  * Neo4j.bat состояние - сообщают относительно состояния службы Neo4j

      o ВЫПОЛНЕНИЕ возвратов, ОСТАНОВЛЕННОЕ или НЕ УСТАНОВЛЕННЫЙ

ФАЙЛЫ

conf/neo4j-server.properties
    Конфигурация сервера.
conf/neo4j-wrapper.conf
    Конфигурация для обертки службы.
conf/neo4j.properties
    Настраивание конфигурации для базы данных.

-------------------------------------------------------------------------------

Имя

neo4j-установщик - установка Сервера Neo4j и перемещение

Резюме

neo4j-установщик <команда>

ОПИСАНИЕ

Neo4j - база данных графика, совершенная для того, чтобы работать с чрезвычайно соединенными данными.

Привилегированный способ установить Neo4j на системах Linux при использовании предварительно созданного
пакеты установки, но есть также возможность использовать
команда neo4j-установщика, чтобы установить или переместить это как системную службу. Для
информация относительно Windows, см. ниже.

Используйте neo4j команду, чтобы управлять Сервером Neo4j.

КОМАНДЫ

установка
    Устанавливает сервер как соответствующую платформе системную службу.
перемещение
    Удаляет системную службу.

Использование - Windows

Чтобы только управлять Сервером Neo4j, используйте команду Neo4j.bat.

Neo4jInstaller.bat установка/перемещение

Neo4j может быть установлен и выполнен как служба Windows, работающая без консоли
окно. Вы должны будете выполнить сценарии с полномочиями Администратора. Только используйте
Neo4jInstaller.bat сценарий с присущим параметром:

  * Neo4jInstaller.bat устанавливают - установка как служба Windows

      o установит службу
  * Neo4jInstaller.bat перемещают - перемещают службу Neo4j

      o остановит и переместит службу Neo4j

ФАЙЛЫ

conf/neo4j-server.properties
    Конфигурация сервера.
conf/neo4j-wrapper.conf
    Конфигурация для обертки службы.
conf/neo4j.properties
    Настраивание конфигурации для базы данных.

-------------------------------------------------------------------------------

Имя

neo4j-оболочка - инструмент командной строки для исследования и управления графика
база данных

Резюме

neo4j-оболочка [ОТДАЛЯЕТ ОПЦИИ]

neo4j-оболочка [ЛОКАЛЬНЫЕ ОПЦИИ]

ОПИСАНИЕ

Оболочка Neo4j - оболочка командной строки для того, чтобы выполнить запросы Кода. Есть также
команды, чтобы получить информацию о базе данных. Кроме того, Вы можете просмотреть
график, очень как то, как оболочка Unix наряду с командами как cd, ls и pwd может
используйтесь, чтобы просмотреть Вашу локальную файловую систему. Оболочка может соединиться прямо с a
база данных графика на файловой системе. Получить доступ локальный локальная база данных, используемая
другие процессы, используйте режим только для чтения.

УДАЛЕННЫЕ ОПЦИИ

- ПОРТ порта
    Порт узла, чтобы соединить с (значение по умолчанию: 1337).
- УЗЕЛ узла
    Доменное имя или IP узла, чтобы соединить с (значение по умолчанию: localhost).
- ИМЯ имени
    Имя RMI, то есть rmi://<узел>: <порт> / <имя> (значение по умолчанию: оболочка).
- только для чтения
    Получите доступ к базе данных в режиме только для чтения.

ЛОКАЛЬНЫЕ ОПЦИИ

- ПУТЬ пути
    Путь к каталогу базы данных. Если нет никакой базы данных в
    расположение, новый будет создаваемый e.
- изодромный с предварением PID
    ID процесса, чтобы соединиться с.
- только для чтения
    Получите доступ к базе данных в режиме только для чтения.
КОМАНДА-c
    Командная строка, чтобы выполниться. После выполнения этого выходы оболочки.
- ФАЙЛ файла
    Файл, чтобы читать и выполниться. После выполнения этого выходы оболочки. Если -
    предоставленный, поскольку данные имени файла считаны из stdin вместо этого.
- КОНФИГУРАЦИЯ конфигурации
    Путь к конфигурационному файлу Neo4j, который будет использоваться.

ПРИМЕРЫ

Примеры для удаленного:

  neo4j-оболочка
  neo4j-оболочка - порт 1337
  neo4j-оболочка - размещает 192.168.1.234 - порт 1337 - оболочка имени
  neo4j-оболочка - размещает localhost - только для чтения

Примеры для локального:

  neo4j-оболочка - путь/path/to/db
  neo4j-оболочка - путь/path/to/db - конфигурация/path/to/neo4j.properties
  neo4j-оболочка - путь/path/to/db - только для чтения

-------------------------------------------------------------------------------

Имя

neo4j-резервное-копирование - Резервный Инструмент Neo4j

Резюме

neo4j-резервное-копирование - от SourceURI - к Каталогу

ОПИСАНИЕ

Инструмент, чтобы выполнить переменные резервные копии по сети от выполнения график Neo4j
база данных на локальную файловую систему. Резервные копии могут быть или полными или инкрементными.
Первое резервное копирование должно быть полным резервным копированием, после которого инкрементные резервные копии могут быть
выполняемый.

Источник (и) дан как URI в специальном формате, цель - файловая система
расположение.

ТИП РЕЗЕРВИРОВАНИЯ

- полный
    копирует всю базу данных в каталог.
- инкрементный
    копирует изменения, которые имели место начиная с последнего полного или инкрементного
    сделайте копию к существующему резервному хранилищу.

Резервный инструмент автоматически обнаружит, должен ли он сделать полное или
инкрементное резервное копирование.

ИСХОДНЫЙ URI

Резервные источники даны в следующем формате:

<рабочий режим>://<узел> [: <порт>] [<узел> [: <порт>]] …

Заметьте, что могут быть определены разнообразные узлы.

рабочий режим
    'единственный' или 'ха'. 'ха' для экземпляров в Высоконадежном режиме, 'единственном'
    для автономных баз данных.
узел
    В единственном режиме, узле исходной базы данных; в ха режиме, кластере
    адрес элемента кластера. Заметьте, что разнообразные узлы могут быть даны когда
    использование Высоконадежного режима.
порт
    В единственном режиме порт исходной базы данных делает копию службы; в ха режиме,
    порт экземпляра кластера. Если не данный, значение по умолчанию 6362 будет
    используйтесь для единственного режима, 5001 для HA

ВАЖНЫЙ

Резервные копии могут только быть выполнены на базах данных, у которых есть конфигурация
параметр enable_online_backup=true набор. Это сделает резервную службу
доступный на порту значения по умолчанию (6362). Включать резервной службе на a
различное использование порта например enable_online_backup=port=9999 вместо этого.

Использование - Windows

Neo4jBackup.bat сценарий используется таким же образом.

ПРИМЕРЫ

# Выполнение резервного копирования в первый раз: создайте пустой каталог и выполните резервный инструмент
mkdir/mnt/backup/neo4j-backup
neo4j-резервное-копирование - от single://192.168.1.34 - к/mnt/backup/neo4j-backup

# Последовательные резервные копии, используя тот же самый _target_-каталог будут инкрементными и поэтому быстро
neo4j-резервное-копирование - от single://freja - к/mnt/backup/neo4j-backup

# Выполнение резервного копирования, где служба зарегистрирована на пользовательском порту
neo4j-резервное-копирование - от single://freja:9999 - к/mnt/backup/neo4j-backup

# Выполнение резервного копирования от кластера HA, определяя только один элемент кластера
./neo4j-backup - от ha://oden:5002 - к/mnt/backup/neo4j-backup

# Выполнение резервного копирования от кластера HA, определяя два элемента кластера
./neo4j-backup - от ha://oden:5001, loke:5002 - к/mnt/backup/neo4j-backup

ВОССТАНОВЛЕНИЕ ОТ РЕЗЕРВНОГО КОПИРОВАНИЯ

Резервные копии Neo4j - полностью функциональные базы данных. Чтобы использовать резервное копирование, замените Ваш
каталог базы данных с резервным копированием.

-------------------------------------------------------------------------------

Имя

neo4j-арбитр - Арбитр Neo4j для Кластеров высокой доступности

Резюме

neo4j-арбитр <команда>

ОПИСАНИЕ

Арбитр Neo4j - служба, которая может помочь сломаться, связывает кластеры Neo4j, которые имеют
четное число элементов кластера.

КОМАНДЫ

консоль
    Запустите сервер как приложение, работая как приоритетный процесс. Остановиться
    сервер, используя CTRL-C.
запустить
    Запустите сервер как демона, работая как фоновый процесс.
остановиться
    Останавливает выполнение daemonized сервер.
запустить снова
    Запускает снова рабочий сервер.
состояние
    Текущее состояние выполнения сервера
установка
    Устанавливает сервер как соответствующую платформе системную службу.
перемещение
    Удаляет системную службу

ФАЙЛЫ

conf/arbiter.cfg
    Конфигурация сервера арбитра.
conf/arbiter-wrapper.cfg
    Конфигурация для обертки службы.

