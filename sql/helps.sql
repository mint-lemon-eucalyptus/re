
insert into help_chapters(id,name,author,content,pos,published) values(11,'Теория: графовая модель данных',23,'<p>&nbsp;</p><p>Графовая модель данных - это набор данных, представленных в виде графовой структуры, в узлах которой находятся записи, связанные между собой отношениями один-к-одному или один-ко-многим.Графовой подход к организации данных является расширением иерархического подхода. В иерархических структурах запись-потомок должна иметь в точности одного предка; в графовой структуре данных у потомка может иметься любое число предков.</p><p>Базовыми объектами модели являются:<strong>&nbsp;элемент данных,агрегат данных,запись,набор данных.</strong></p><p>&nbsp;</p><ul><li>Элемент данных &mdash; минимальная информационная единица, доступная пользователю с использованием СУБД.</li><li>Агрегат данных соответствует следующему уровню обобщения в модели(например, агрегатом данных можно назвать массив или некоторый сложный тип данных, определенный пользователем СУБД). Агрегат данных имеет имя, и в системе допустимо обращение к агрегату по имени.</li><li>Записью называется совокупность агрегатов или элементов данных, моделирующая некоторый класс объектов реального мира.</li><li>Набором называется двухуровневый граф, связывающий отношением &laquo;одии-комногим&raquo; два типа записи, т.е отражает иерархическую связь между двумя типами записей. Родительский тип записи в данном наборе называется владельцем набора, а дочерний тип записи &mdash; членом того же набора.</li></ul><p>&nbsp;</p><p>Для любых двух типов записей может быть задано любое количество наборов, которые их связывают. Фактически наличие подобных возможностей позволяет промоделировать отношение &laquo;многие-ко-многим&raquo; между двумя объектами реального мира, что выгодно отличает графовую модель от иерархической. В рамках набора возможен последовательный просмотр экземпляров членов набора, связанных с одним экземпляром владельца набора.Между двумя типами записей может быть определено любое количество наборов: например, можно построить два взаимосвязанных набора. Существенным ограничением набора является то, что один и тот же тип записи не может быть одновременно владельцем и членом набора.</p><p>В отличие от реляционной модели, связи в ней моделируются наборами, реализованными с помощью указателей. Набор - именованная двухуровневая иерархическая структура, которая содержит запись-владельца и запись-потомка (1 или несколько). Наборы отражают связи &laquo;один ко многим&raquo; и &laquo;один к одному&raquo; между этими двумя типами записей.</p>',2,true);
insert into help_chapters(id,name,author,content,pos,published) values(12,'Начало работы с СУБД Neo4j',23,'<h4>Установка и настройка</h4><p>Для установки сервера Neo4j на вашем компьютере потребуется JRE 1.7, а также дистрибутив, который можно скачать с&nbsp;<a href="http://www.neo4j.org/" target="_blank">официального сайта</a>. Для выполнения упражнений потребуется версия не ниже 1.9.5, совместимая с вашей ОС.Для запуска потребуется распаковать архив, перейти в каталог с распакованными файлами и выполнить команду bin/neo4j start. Список возможных режимов запуска сервера выводится при выполнении bin/neo4j help.После успешного старта сервер будет доступен на 7474 порту. Вместе с сервером запускается web-интерфейс, в котором также можно в интерактивном режиме выполнять запросы и видеть результаты их выполнения.</p><p>&nbsp;</p><h5>Типы данных и их истинностные значения:</h5><ul><li><strong>boolean</strong>&nbsp;&mdash; булевское значение [true:false];</li><li><strong>byte</strong>&nbsp;&mdash; целое, 1 байт [-128:127];</li><li><strong>short</strong>&nbsp;&mdash; целое, 2 байт [32768:32767];</li><li><strong>int</strong>&nbsp;&mdash; целое, 4 байт [-2147483648 : 2147483647];</li><li><strong>long</strong>&nbsp;&mdash; целое, 8 байт [-9223372036854775808 : 9223372036854775807];</li><li><strong>float</strong>&nbsp;&mdash; 4-х байтовое число с плавающей точкой;</li><li><strong>double</strong>&nbsp;&mdash; 8-х байтовое число с плавающей точкой;</li><li><strong>char</strong>&nbsp;&mdash; 2-х байтовое безнаковое целое [0 : 65535], представляет символ Unicode;</li><li><strong>String</strong>&nbsp;&mdash; последовательность unicode символов, в том числе и escape-последовательности.</li></ul><p>&nbsp;</p><p>&nbsp;</p><h5>Термины языка Cypher:</h5><ul><li>узел (Node)&mdash; запись, моделирующая некоторую сущность из предметной области, может содержать свойства;</li><li>свойство (Property) &mdash; пара &laquo;ключ-значение&raquo;, где ключом является строковое значение, а значением &mdash; любой из вышеперечисленных типов данных, а также массив на их основе;</li><li>связи или отношения (Relationships) позволяют моделировать логическую связь между объектами из предметной области, также могут иметь свойства;</li><li>метка(Label) &mdash; именованная совокупность узлов графа(подграф). В качестве имени метки может использоваться непустая строка unicode. В дальнейшем по имени метки можно быстро найти узлы;</li><li>путь (Path) &mdash; несколько узлов, соединенных отношениями. Используются в сложных запросах, требующих найти данные по некоторому структурному шаблону;</li></ul><p>&nbsp;</p><p>СУБД Neo4j поддерживает описания схем для повышения производительности, но, в общем случае, применение схем необязательно. Приведение типов работает по правилам Си-подобных языков программирования.</p><h4>Индексы и ограничения</h4><p>В Neo4j начиная с версии 1.8 появились индексы и ограничения &mdash; они полностью аналогичны функционально индексам и ограничениям в реляционных СУБД. Но отличие от них, Neo4j позволяет создавать именованные индексы для свойств узлов выборочно по именам, что позволяет повысить скорость операций модификации.</p>',4,true);
insert into help_chapters(id,name,author,content,pos,published) values(13,'Синтаксис Cypher',23,'<p>Cypher - это декларативный язык запросов, позволяющий эффективно манипулировать данными графовой СУБД. Структурой запросов сильно похож на SQL. Кроме запросов на выборку позволяет также изменять, обновлять данные, добавлять ограничения и т.д. Также как в SQL, есть набор основных функций, например, для работы с датами, массивами, коллекциями и строками. Кроме того, СУБД поддерживает транзакции а также построение индексов по выбранным свойствам узлов.</p><hr /><h4>Операторы языка Cypher</h4><p>&nbsp;</p><ul><li>Математические операторы: +, -, *, /, %, ^. При выполнении операций над операндами разных типов будет происходить неявное преобразование типов в сторону увеличения точности.</li><li>Операторы сравнения: =, &lt;&gt;, &lt;, &gt;, &lt;=, &gt;=.</li><li>Логические операторы: AND, OR, XOR, NOT.</li><li>Операции над строками: строки конкатенируются оператором +.</li><li>Операции над коллекциями: оператор + объединяет 2 коллекции, для проверки наличия элемена в коллекции используется оператор IN.</li><li>Так как СУБД Neo4j не требует описания схемы, в запросе возможна ситуация сравнения со свойством узла, которого не существует. Для предотвращения ошибки рекомендуется проверять наличие свойства у узла, например:<br /><p class="code">WHERE n.some_property? = "something"&nbsp;<span class="comment">//вернет false, если у узла n существует свойство с именем some_property</span></p><p class="code">WHERE n.some_property! = "something"&nbsp;<span class="comment">//вернет true, если у узла n существует свойство с именем some_property</span></p><p class="warning">Замечание: пробел после &laquo;!&raquo; Во втором примере обязателен.</p>Предикат HAS(prop_name) является аналогом оператора &laquo;!&raquo;.<p class="warning">Примечание: в Cypher 2.0 операторы ! B ? не поддерживаются. Проверка значения свойства возвращает null, а синтаксис выглядит следующим образом:</p><p class="code">has(n.some_property)</p></li></ul><p>&nbsp;</p><hr /><p>&nbsp;</p><h4>Выражением в Cypher могут быть:</h4><ul><li>истинностные значения любых простых типов данных</li><li>идентификаторы переменных (a,b,n,some_node и т.д.)</li><li>обращения к свойствам узлов( n.prop, x.prop)</li><li>параметры, подставляемые в запрос( {param}, {0})</li><li>коллекции: ["a", "b"], [1,2,3], ["a", 2, n.property, {param}], [ ]</li><li>вызовы функций: length(some_collection), nodes(node_set)</li><li>шаблоны пути в графе: (a)--&gt;(f)&lt;--(b)</li><li>предикаты: a.prop = "Hello", length(p) &gt; 10, has(a.name)</li></ul><p>Для добавления однострочного комментария к запросу используйте &laquo;//&raquo;.</p>',18,true);
insert into help_chapters(id,name,author,content,pos,published) values(14,'Коллекции',23,'<p>В Cypher коллекции являются аналогом наборов записей в SQL. Их главное отличие состоит в отсутствии типизации, что позволяет инициализировать коллекцию разными типами элементов, будь то целые числа, строки, коллекции или объекты графа.</p><p class="code">RETURN [0,1.3,"str",n.prop, [1, 5.8]] AS my_collection</p><p>Результат:</p><p class="result">my_collection</p><p class="result">1 row</p><p class="result">[0,1.3,"str","sample", [1, 5.8]]</p><p>Для обращения к отдельным элементам коллекции используются индексы, взятые в квадратные скобки:</p><p class="code">RETURN [1,2,3,4,5][3]</p><p>Результат:</p><p class="result">4</p><p>если в качестве индекса задать отрицательное число, то отсчет позиции элемента идет с конца коллекции:</p><p class="code">RETURN [1,2,3,4,5][-1]</p><p>Результат:</p><p class="result">5</p><p>Функция RANGE(a,b[,s]) создает пустую коллекцию и заполняет ее целыми числами от a до b с шагом s.</p><p>также можно получить часть коллекции:</p><p class="code">RETURN range(0,10)[2..5]</p><p>Результат:</p><p class="result">[2,3,4]</p><p>результатом выполнения выражения будет коллекция.</p><p class="code">RETURN range(0,10)[-3..]</p><p>Результат:</p><p class="result">[8,9,10]</p><p>При обращении к одиночному элементу за границей коллекции результатом будет null:</p><p class="code">RETURN range(0,10)[100]</p><p>Результат</p><p class="result">null</p><p>Если при обращении к группе элементов коллекции окажется, что часть из них не существует, в результирующей коллекции null выведены не будут:</p><p class="code">RETURN range(0,10)[5..15]</p><p>Результат</p><p class="result">[5,6,7,8,9,10]</p><p>В Cypher 2.0 появилась возможность создавать коллекции на основе существующих колекций.Пример: Вывести все целые числа от 0 до 10, такие что их квадрат находится в диапазоне [50-90].Решение:</p><p class="code">RETURN [x IN range(0,10) WHERE x^2&gt;50 and x^2&lt;90 | x] AS result</p><p class="code">RETURN [x IN range(0,10) WHERE x^2&gt;50 and x^2&lt;90] AS result</p><p>Результат</p><p class="result">[8,9]</p><hr /><p>В Cypher также возможно создавать объекты типа &laquo;ключ-значение&raquo; в формате JSON:</p><p class="code">RETURN { key : "Value", arr: [{ a: "val1" }, { ab: "val2" }]}</p><p>Результат</p><p class="result">{ key : "Value", arr: [{ a: "val1" }, { ab: "val2" }]}</p><hr /><p>Функция LENGTH возвращает длину коллекции:</p><p class="code">RETURN LENGTH(range(0,10))</p><p>Результат</p><p class="result">10</p>',4,false);
insert into help_chapters(id,name,author,content,pos,published) values(15,'Пути в графе',23,'<p>Шаблоны путей в графе позволяют отбирать в результирующую коллекцию только те узлы и отношения, которые можно сопоставить с этим шаблоном. Поэтому для понимания работы шаблонов пути необходимо хорошо понимать структуру моддели предметной области.</p><p>При описании шаблонов фактически задается форма данных, и программисту не нужно знать, каким образом СУБД построит результирующую коллекцию.</p><p>Шаблоны могут применяться в нескольких местах запроса: в предложениях<strong>MATCH, CREATE и MERGE</strong>.</p><h4>Шаблоны для поиска узлов</h4><p>Самым простым примером даного типа является шаблон выбора одного узла:</p><p class="code">match (n) return n</p><p>Результатом будет коллекция всех узлов в графе(аналог * в предложении SELECT из SQL)</p><p>Для выбора узлов, связанных отношением, применяется синтаксис:</p><p><span class="syntax">(a)--&gt;(b)</span>, где (a) - узел-предок, (b) - узел-потомок, --&gt; - направленное отношение от a к b. идентификаторы a и b можно будет использовать в запросе. Если некоторый узел в шаблоне пути использоваться не будет, идентификатор можно опустить</p><p><span class="syntax">(a)--()</span>&nbsp;&mdash; ненаправленное отношение между a и любым другим узлом.</p><p>Необходимо понимать, что использование очень длинных шаблонов требует больших затрат памяти, особенно при поиске на больших графах.</p>',5,true);
insert into help_chapters(id,name,author,content,pos,published) values(16,'Метки и индексы',23,'<p>Метки позволяют объединить несколько узлов в графе. При указании имени метки в запросе, СУБД будет искать узлы только в той части графа, которая закреплена за этой меткой.</p><p>Поиск по шаблону с указанием метки:</p><p class="code">match (n:myLabel) return n</p><p class="result">возвращаемым значением будет коллекция из 2 узлов, созданных ранее.</p><p>Cypher позволяет создавать индексы на свойствах узлов, обозначенных ранее описанной меткой. В процессе работы СУБД эти индексы будут поддерживаться и обновляться. При выполнении запроса, если СУБД встретит имя метки с индексом, план выполнения запроса будет построен на его основе.</p><p>Создание индекса на свойстве some_property для узлов с меткой myLabel:</p><p class="code">CREATE INDEX ON :myLabel(some_property)</p><p>Индексы уникальны, поэтому повторная попытка выполнения запроса ни к чему не приведет.</p><p>Удаление созданного ранее индекса:</p><p class="code">DROP INDEX ON :myLabel(some_property)</p><p>Необходимо понимать, что использование индексов на часто обновляемых свойствах узлов будет существенно тормозить систему.</p>',6,true);
insert into help_chapters(id,name,author,content,pos,published) values(17,'Операции над узлами, отношениями и их свойствами',23,'<p>С помощью оператора CREATE можно создавать узлы и связывать их отношениями.</p><p>Общий синтаксис при создании узлов:</p><p class="code">CREATE [UNIQUE] (n:myLabel[:my_label_N] [{ [property_name : property_value][, ... ]}])</p><p>Оператор CREATE не имеет возвращаемого значения.</p><p>Использование ключа UNIQUE заставит СУБД сначала проверить наличие узла, и, если его нет, создать новый.</p><p>Общий синтаксис при создании отношений между узлами:</p><p><span class="code">CREATE [UNIQUE] (node_a)-[r:RELTYPE[{[param:value][, ...]}]-&gt;(node_b)</span>, node_a, node_b &mdash; узлы, которые необходимо связать</p><p>Отношения НЕ являются уникальными (если не использовать ключ UNIQUE)</p><p>Пример: Создать отношение между узлами, отмеченными как myLabel и myAnotherLabel со свойствами name="simple" и weight=23, вернуть созданные отношения:</p><p class="code">MATCH (node_a:myLabel),(node_b:myAnotherLabel)</p><p class="code">CREATE (node_a)-[r:myRelType{name:"simple", weight:23}]-&gt;(node_b) return r;</p><p class="result">Будут возвращены не только отношения, но и узлы, непосредственно связанные ими</p><p>Использование ключа UNIQUE заставит СУБД сначала проверить наличие узла или отношения, и, если его нет, создать новый.</p><p>Также оператор CREATE позволяет в одном запросе создать путь в графе:</p><p><span class="code">CREATE UNIQUE (a:TESTLABEL { name:"Alex" })-[:CHILD_OF]-&gt;(b:TESTLABEL{name:"John"})&lt;-[:CHILD_OF]-(c:TESTLABEL { name:"Anna" })</span>, node_a, node_b &mdash; узлы, которые необходимо связать</p><p class="result">будут созданы 3 узла с заданными свойствами, соединенные отношениями CHILD_OF</p><p>Пример: к центральному узлу графа из последнего примера добавить узел, связанный с ним отношением KNOWS:</p><p class="code">MATCH ()-[CHILD_OF]-&gt;(n)</p><p class="code">CREATE [unique] (n)-[:KNOWS]-&gt;({name:"Jack"})</p><p class="code">return r</p><p>Оператор SET позволяет создавать, удалять и модифицировать свойства объектов графа, задавать метки узлов и отношений.</p><p>Синтаксис:</p><p><span class="code">SET obj.property_name = property_value;</span>&nbsp;obj &mdash; узел или отношение, property_name &mdash; имя свойства</p><p>Свойства уникальны в пределах узла, повторное выполнение запроса приведет к замещению значения свойства.</p><p>Для удаления свойства достаточно присвоить ему&nbsp;<strong>null</strong>.</p><p>Присвоение метки узлу:</p><p><span class="code">SET my_node :LABEL_NAME[:ANOTHER_LABEL_NAME]</span>&nbsp;my_node &mdash; узел или коллекция узлов, с которыми будут ассоциированы одна или несколько меток</p>',7,false);
insert into help_chapters(id,name,author,content,pos,published) values(18,'Условные операторы',23,'<p>В качестве оператора условных переходов применяется CASE С помощью оператора CREATE можно создавать узлы и связывать их отношениями.</p><p>Общий синтаксис:</p><p class="code">CASE expr</p><p class="code">WHEN value1 THEN result1</p><p class="code">[WHEN value2 THEN result1]</p><p>Выражение expr вычисляется и сравнивается с каждым значением из предложения WHEN до тех пор, пока не будеьИспользование ключа UNIQUE заставит СУБД сначала проверить наличие узла, и, если его нет, создать новый.</p><p>Общий синтаксис при создании отношений между узлами:</p><p><span class="code">CREATE (node_a)-[r:RELTYPE]-&gt;(node_b)</span>, node_a, node_b &mdash; узлы, которые необходимо связать</p><p class="result">запрос ничего не возвращает</p><p>Отношения являются уникальными, повторное выполнение запроса приведет к замещению созданных ранее отношений</p><p>Пример: Создать отношение между узлами, отмеченными как myLabel и myAnotherLabel со свойствами name="simple" и weight=23, вернуть созданные отношения:</p><p class="code">MATCH (node_a:myLabel),(node_b:myAnotherLabel)</p><p class="code">CREATE (node_a)-[r:myRelType{name:"simple", weight:23}]-&gt;(node_b) return r;</p><p class="result">Будут возвращены не только отношения, но и узлы, непосредственно связанные ими</p><p>Использование ключа UNIQUE заставит СУБД сначала проверить наличие узла, и, если его нет, создать новый.</p><p>Оператор SET позволяет создавать, удалять и модифицировать свойства объектов графа, задавать метки узлов и отношений.</p><p>Синтаксис:</p><p><span class="code">SET obj.property_name = property_value;</span>&nbsp;obj &mdash; узел или отношение, property_name &mdash; имя свойства</p><p>Свойства уникальны в пределах узла, повторное выполнение запроса приведет к замещению значения свойства.</p><p>Для удаления свойства достаточно присвоить ему&nbsp;<strong>null</strong>.</p><p>Синтаксис:</p><p><span class="code">SET obj.property_name = property_value;</span>&nbsp;obj &mdash; узел или отношение, property_name &mdash; имя свойства</p><p class="result">запрос ничего не возвращает</p>',8,true);
insert into help_chapters(id,name,author,content,pos,published) values(19,'Предикаты ALL, ANY, NONE, SINGLE',23,'<h4>Предикат ALL</h4><p>Синтаксис:</p><p class="code">ALL(elem_id in coll WHERE expr)</p><ul><li>elem_id - переменная, которая хранит в себе элемент коллекции</li><li>coll - идентификатор коллекции или выражение, возвращающее коллекцию</li><li>expr - предикат, применяемый к каждому элементу коллекции coll</li></ul><p>Возвращает true, если все элементы коллекции обращают expr в true.</p><h4>Предикат ANY</h4><p>Синтаксис:</p><p class="code">ANY(elem_id in coll WHERE expr)</p><ul><li>elem_id - переменная, которая хранит в себе элемент коллекции</li><li>coll - идентификатор коллекции или выражение, возвращающее коллекцию</li><li>expr - предикат, применяемый к каждому элементу коллекции coll</li></ul><p>Возвращает true, если хотя бы один элемент из коллекции обращает expr в true.</p><h4>Предикат NONE</h4><p>Синтаксис:</p><p class="code">NONE(elem_id in coll WHERE expr)</p><ul><li>elem_id - переменная, которая хранит в себе элемент коллекции</li><li>coll - идентификатор коллекции или выражение, возвращающее коллекцию</li><li>expr - предикат, применяемый к каждому элементу коллекции coll</li></ul><p>Возвращает true, если ни для одного элемента из коллекции expr не выполняется.</p><h4>Предикат SINGLE</h4><p>Синтаксис:</p><p class="code">SINGLE(elem_id in coll WHERE expr)</p><ul><li>elem_id - переменная, которая хранит в себе элемент коллекции</li><li>coll - идентификатор коллекции или выражение, возвращающее коллекцию</li><li>expr - предикат, применяемый к каждому элементу коллекции coll</li></ul><p>Возвращает true, если точно один элемент из коллекции обращает expr в true.</p>',9,false);
insert into help_chapters(id,name,author,content,pos,published) values(20,'Скалярные функции',23,'<h4>LENGTH</h4><p>Синтаксис:</p><p class="code">LENGTH(coll)</p><p>Возвращает количество элементов коллекции, если аргумент - коллекция, или длину пути, если аргумент - путь в графе.</p><h4>ID</h4><p>Синтаксис:</p><p class="code">ID(arg)</p><p>Возвращает уникальный идентификатор сущности, если аргумент - узел или отношение, в противном случае - ошибка.</p><h4>HEAD</h4><p>Синтаксис:</p><p class="code">HEAD(arg)</p><p>Возвращает первый элемент из коллекции, если аргумент - коллекция, в противном случае - ошибка.</p><h4>LAST</h4><p>Синтаксис:</p><p class="code">LAST(arg)</p><p>Возвращает последний элемент из коллекции, если аргумент - коллекция, в противном случае - ошибка.</p><h4>TYPE</h4><p>Синтаксис:</p><p class="code">TYPE(arg)</p><p>Возвращает имя типа отношения, переданного через аргумент.</p><h4>COALESCE</h4><p>Синтаксис:</p><p class="code">COALESCE( expr1 [, expr2, ...] )</p><p>Возвращает первое не-null значение из перечисленных в аргументах.</p><h4>STARTNODE</h4><p>Синтаксис:</p><p class="code">STARTNODE(arg)</p><p>Возвращает узел, являющийся началом отношения arg.</p><h4>ENDNODE</h4><p>Синтаксис:</p><p class="code">ENDNODE(arg)</p><p>Возвращает узел, являющийся концом отношения arg.</p><h4>TIMESTAMP</h4><p>Синтаксис:</p><p class="code">TIMESTAMP()</p><p>Возвращает количество миллисекунд, прошедшее с 1 января 1970 года.</p>',10,false);
insert into help_chapters(id,name,author,content,pos,published) values(21,'Функции для работы с коллекциями',23,'<p>Функция HEAD(coll) возвращает начальный элемент коллекции:</p><p class="code">RETURN HEAD(range(0,10))</p><p>Результат</p><p class="result">0</p><p>Функция TAIL возвращает все элементы коллекции, начиная со второго:</p><p class="code">RETURN TAIL(range(0,10))</p><p>Результат</p><p class="result">[1,2,3,4,5,6,7,8,9,10]</p><h4>NODES</h4><p>Синтаксис:</p><p class="code">NODES(p)</p><p>Возвращает все узлы, входящие в путь на графе p.</p><h4>RELATIONSHIPS</h4><p>Синтаксис:</p><p class="code">RELATIONSHIPS(p)</p><p>Возвращает все отношения, входящие в путь на графе p.</p><h4>LABELS</h4><p>Синтаксис:</p><p class="code">LABELS(n)</p><p>Возвращает коллекцию из всех меток, ассоциированных с узлом n.</p><h4>EXTRACT</h4><p>Синтаксис:</p><p class="code">EXTRACT( identifier in coll | expr )</p><ul><li>identifier - переменная, которая хранит в себе элемент коллекции</li><li>coll - идентификатор коллекции или выражение, возвращающее коллекцию</li><li>expr - предикат, применяемый к каждому элементу коллекции coll</li></ul><p>Функция EXTRACT применяется, если нужно вернуть по одному свойству от каждого узла или отношения из коллекции.</p><hr /><p>Функция FILTER возвращает все элементы коллекции, обращающие предикат в true:</p><p class="syntax">Синтаксис: FILTER(identifier IN collection WHERE predicate)</p><p>Пример: Вывести все целые числа от 0 до 10, куб которых больше 7 и квадрат меньше 60.</p><p class="code">RETURN filter(x IN range(0,10) WHERE x^3&gt;7 and x^2&lt;60)</p><p>Результат</p><p class="result">[2,3,4,5,6,7]</p><hr /><p>Функция EXTRACT применяется, если нужно вернуть по одному свойству от узла или отношения:</p><p class="syntax">Синтаксис: EXTRACT( identifier in collection | expression )</p><p>identifier - переменная области видимости выражения expression, в которой хранится текущий элемент коллекции; expression - выражение, применяемое к каждому элементу коллекции.</p><hr /><p>Функция REDUCE проходит по коллекции и к каждому ее элементу применяет выражение, результат которого записывается в переменную-аккумулятор:</p><p class="syntax">Синтаксис: REDUCE( accumulator = initial, identifier in collection | expression )</p><p>Пример: посчитать среднее арифметическое квадратов чисел от 0 до 10.</p><p class="code">RETURN REDUCE(counter=0, x IN range(0,10) | counter + x^2)/length(range(0,10))</p><p>Результат</p><p class="result">35</p>',11,false);
insert into help_chapters(id,name,author,content,pos,published) values(22,'Оператор RETURN',23,'<p>Оператор RETURN позволяет возвращать из запроса узлы, отношения, а также коллекции. Для этого их надо перечислить после ключевого слова RETURN.</p><p>Синтаксис:</p><p class="code">RETURN [DISTINCT] идентификатор_сущности_1 [AS name_1] | выражение [AS name_2] [, идентификатор_сущности_2, ...] | *;</p><p class="code">MATCH (n { name: "Alex" })</p><p class="code">RETURN n</p><p>Результатом будет коллекция узлов</p><p class="code">MATCH (n { name: "Alex" })-[r:KNOWS]-&gt;(m)</p><p class="code">RETURN r, n, m</p><p>Результат - коллекция отношений (r) и узлов(n,m).</p><p class="code">MATCH (n { name: "Alex" })</p><p class="code">RETURN n.age</p><p>Возвращает значение свойства "age". Если у узла или отношения такое свойство отсутствует, будет возвращено null.</p><p class="code">MATCH (n { name: "Alex" })-[r:KNOWS]-&gt;(m)</p><p class="code">RETURN *</p><p>Возвратит значения всех идентификаторов, примененных в запросе (аналог RETURN n,r,m)</p><p>DISTINCT возвратит только уникальные значения и сущности:</p><p class="code">MATCH (n { name: "A" })--&gt;(m)</p><p class="code">RETURN DISTINCT m</p>',12,true);
insert into help_chapters(id,name,author,content,pos,published) values(23,'ORDER BY',23,'<p>Предложение ORDER BY применяется для сортировки результирующего набора.</p><p>Синтаксис:</p><p class="code">ORDER BY имя_сущности.имя_свойства [, имя_сущности.имя_свойства2 ...] [ DESC | DESCENDING ]</p><p>Если в списке указать несколько свойств через запятую, то сортировка будет выполняться в порядке их записи, таким образом</p><p class="code">MATCH (n { name: "Alex" })</p><p class="code">RETURN n</p><p class="code">ORDER BY n.name, n.age</p><p>Результирующий набор узлов будет отсортирован сначала по свойству "name", потом по свойству "age"</p><p>При сортировке по возрастанию набора, содержащего null значения, они будут помещены в конец результирующего набора узлов будет отсортирован сначала по свойству "name", потом по свойству "age"</p>',13,true);
insert into help_chapters(id,name,author,content,pos,published) values(24,'Оператор LIMIT',23,'<p>Оператор LIMIT ограничивает количество элеменов в результирующем наборе.</p><p>Пример:</p><p class="code">MATCH (n { name: "Alex" })</p><p class="code">RETURN n</p><p class="code">LIMIT 5</p><p>Возвратит первые 5 элементов, попавших в результирующий набор</p>',14,true);
insert into help_chapters(id,name,author,content,pos,published) values(25,'Оператор SKIP',23,'<p>Оператор SKIP исключает из результирующего набора N первых элементов. Необходимо учитывать, что SKIP предварительно не сортирует результирующий набор.</p><p>Пример:</p><p class="code">MATCH (n { name: "Alex" })</p><p class="code">RETURN n</p><p class="code">SKIP 2</p><p>Возвратит всё, кроме первых 2 узлов</p><p>SKIP можно комбинировать с LIMIT:</p><p class="code">MATCH (n { name: "Alex" })</p><p class="code">RETURN n</p><p class="code">ORDER BY n.name</p><p class="code">SKIP 2</p><p class="code">LIMIT 3</p><p>Результирующий набор будет сначала отсортирован по значениям свойства name, потом из него будут исключены 2 первых узла и возвращены 3 оставшихся</p>',15,true);
---==== Конец =====
